# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

module AST
end

class AST::Node
  def +(array); end

  def <<(element); end

  def ==(other); end

  def append(element); end

  def assign_properties(properties); end

  def children(); end

  def clone(); end

  def concat(array); end

  def eql?(other); end

  def fancy_type(); end

  def initialize(type, children=T.unsafe(nil), properties=T.unsafe(nil)); end

  def inspect(indent=T.unsafe(nil)); end

  def to_a(); end

  def to_ast(); end

  def to_s(indent=T.unsafe(nil)); end

  def to_sexp(indent=T.unsafe(nil)); end

  def to_sexp_array(); end

  def type(); end

  def updated(type=T.unsafe(nil), children=T.unsafe(nil), properties=T.unsafe(nil)); end
end

class AST::Node
end

class AST::Processor
  include ::AST::Processor::Mixin
end

module AST::Processor::Mixin
  def handler_missing(node); end

  def process(node); end

  def process_all(nodes); end
end

module AST::Processor::Mixin
end

class AST::Processor
end

module AST::Sexp
  def s(type, *children); end
end

module AST::Sexp
end

module AST
end

class AbstractController::DoubleRenderError
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

module AbstractController::Rendering
  DEFAULT_PROTECTED_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
end

module ActionCable
  INTERNAL = ::T.let(nil, ::T.untyped)
end

module ActionCable::Channel::TestCase::Behavior
  CHANNEL_IDENTIFIER = ::T.let(nil, ::T.untyped)
end

class ActionCable::Connection::ClientSocket
  CLOSED = ::T.let(nil, ::T.untyped)
  CLOSING = ::T.let(nil, ::T.untyped)
  CONNECTING = ::T.let(nil, ::T.untyped)
  OPEN = ::T.let(nil, ::T.untyped)
end

module ActionCable::Connection::TestCase::Behavior
  DEFAULT_PATH = ::T.let(nil, ::T.untyped)
end

class ActionCable::RemoteConnections::RemoteConnection
  include ::ActionCable::Connection::InternalChannel
end

module ActionCable::Server::Connections
  BEAT_INTERVAL = ::T.let(nil, ::T.untyped)
end

module ActionCable::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class ActionController::API
  MODULES = ::T.let(nil, ::T.untyped)
end

class ActionController::Base
  MODULES = ::T.let(nil, ::T.untyped)
  PROTECTED_IVARS = ::T.let(nil, ::T.untyped)
end

module ActionController::DataStreaming
  DEFAULT_SEND_FILE_DISPOSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_SEND_FILE_TYPE = ::T.let(nil, ::T.untyped)
end

module ActionController::ForceSSL
  ACTION_OPTIONS = ::T.let(nil, ::T.untyped)
  REDIRECT_OPTIONS = ::T.let(nil, ::T.untyped)
  URL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActionController::HttpAuthentication::Token
  AUTHN_PAIR_DELIMITERS = ::T.let(nil, ::T.untyped)
  TOKEN_KEY = ::T.let(nil, ::T.untyped)
  TOKEN_REGEX = ::T.let(nil, ::T.untyped)
end

class ActionController::Live::SSE
  PERMITTED_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionController::LogSubscriber
  def exist_fragment?(event); end

  def expire_fragment(event); end

  def expire_page(event); end

  def halted_callback(event); end

  def process_action(event); end

  def read_fragment(event); end

  def redirect_to(event); end

  def send_data(event); end

  def send_file(event); end

  def start_processing(event); end

  def unpermitted_parameters(event); end

  def write_fragment(event); end

  def write_page(event); end
  INTERNAL_PARAMS = ::T.let(nil, ::T.untyped)
end

class ActionController::MiddlewareStack
  EXCLUDE = ::T.let(nil, ::T.untyped)
  INCLUDE = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
end

class ActionController::Parameters
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  PERMITTED_SCALAR_TYPES = ::T.let(nil, ::T.untyped)
end

module ActionController::ParamsWrapper
  EXCLUDE_PARAMETERS = ::T.let(nil, ::T.untyped)
end

class ActionController::Renderer
  DEFAULTS = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  RACK_KEY_TRANSLATION = ::T.let(nil, ::T.untyped)
  RACK_VALUE_TRANSLATION = ::T.let(nil, ::T.untyped)
end

module ActionController::Renderers
  def _render_with_renderer_component(component_name, options); end
  RENDERERS = ::T.let(nil, ::T.untyped)
end

module ActionController::Rendering
  RENDER_FORMATS_IN_PRIORITY = ::T.let(nil, ::T.untyped)
end

module ActionController::RequestForgeryProtection
  AUTHENTICITY_TOKEN_LENGTH = ::T.let(nil, ::T.untyped)
  NULL_ORIGIN_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActionController::RespondToMismatchError
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActionController::SessionOverflowError
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActionController::TestRequest
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
  ENCODER = ::T.let(nil, ::T.untyped)
end

class ActionController::TestSession
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::AssertionResponse
  def code(); end

  def code_and_name(); end

  def initialize(code_or_name); end

  def name(); end
  GENERIC_RESPONSE_CODES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::AssertionResponse
end

module ActionDispatch::Assertions::ResponseAssertions
  RESPONSE_PREDICATES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::ContentSecurityPolicy::Middleware
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  POLICY = ::T.let(nil, ::T.untyped)
  POLICY_REPORT_ONLY = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::ContentSecurityPolicy::Request
  NONCE = ::T.let(nil, ::T.untyped)
  NONCE_DIRECTIVES = ::T.let(nil, ::T.untyped)
  NONCE_GENERATOR = ::T.let(nil, ::T.untyped)
  POLICY = ::T.let(nil, ::T.untyped)
  POLICY_REPORT_ONLY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Cookies
  AUTHENTICATED_ENCRYPTED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  COOKIES_DIGEST = ::T.let(nil, ::T.untyped)
  COOKIES_ROTATIONS = ::T.let(nil, ::T.untyped)
  COOKIES_SERIALIZER = ::T.let(nil, ::T.untyped)
  ENCRYPTED_COOKIE_CIPHER = ::T.let(nil, ::T.untyped)
  ENCRYPTED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  ENCRYPTED_SIGNED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  GENERATOR_KEY = ::T.let(nil, ::T.untyped)
  HTTP_HEADER = ::T.let(nil, ::T.untyped)
  MAX_COOKIE_SIZE = ::T.let(nil, ::T.untyped)
  SECRET_KEY_BASE = ::T.let(nil, ::T.untyped)
  SIGNED_COOKIE_DIGEST = ::T.let(nil, ::T.untyped)
  SIGNED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  USE_AUTHENTICATED_COOKIE_ENCRYPTION = ::T.let(nil, ::T.untyped)
  USE_COOKIES_WITH_METADATA = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Cookies::CookieJar
  include ::ActionDispatch::Cookies::ChainedCookieJars
  DOMAIN_REGEXP = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Cookies::SerializedCookieJars
  MARSHAL_SIGNATURE = ::T.let(nil, ::T.untyped)
end

ActionDispatch::Cookies::SerializedCookieJars::SERIALIZER = ActiveSupport::MessageEncryptor::NullSerializer

class ActionDispatch::DebugLocks
  def call(env); end

  def initialize(app, path=T.unsafe(nil)); end
end

class ActionDispatch::DebugLocks
end

class ActionDispatch::DebugView
  def debug_hash(object); end

  def debug_headers(headers); end

  def debug_params(params); end

  def initialize(assigns); end

  def params_valid?(); end

  def protect_against_forgery?(); end

  def render(*_); end
  RESCUES_TEMPLATE_PATH = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::DebugView
end

class ActionDispatch::Flash
  KEY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::HostAuthorization
  DEFAULT_RESPONSE_APP = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http
  include ::ActiveSupport::Deprecation::DeprecatedConstantAccessor
end

module ActionDispatch::Http::Cache::Request
  HTTP_IF_MODIFIED_SINCE = ::T.let(nil, ::T.untyped)
  HTTP_IF_NONE_MATCH = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::Cache::Response
  DATE = ::T.let(nil, ::T.untyped)
  DEFAULT_CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  LAST_MODIFIED = ::T.let(nil, ::T.untyped)
  MUST_REVALIDATE = ::T.let(nil, ::T.untyped)
  NO_CACHE = ::T.let(nil, ::T.untyped)
  PRIVATE = ::T.let(nil, ::T.untyped)
  PUBLIC = ::T.let(nil, ::T.untyped)
  SPECIAL_KEYS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Http::ContentDisposition
  RFC_5987_ESCAPED_CHAR = ::T.let(nil, ::T.untyped)
  TRADITIONAL_ESCAPED_CHAR = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::FilterParameters
  ENV_MATCH = ::T.let(nil, ::T.untyped)
  KV_RE = ::T.let(nil, ::T.untyped)
  NULL_ENV_FILTER = ::T.let(nil, ::T.untyped)
  NULL_PARAM_FILTER = ::T.let(nil, ::T.untyped)
  PAIR_RE = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::FilterRedirect
  FILTERED = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Http::Headers
  CGI_VARIABLES = ::T.let(nil, ::T.untyped)
  DEFAULT = ::T.let(nil, ::T.untyped)
  HTTP_HEADER = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::MimeNegotiation
  BROWSER_LIKE_ACCEPTS = ::T.let(nil, ::T.untyped)
  RESCUABLE_MIME_FORMAT_ERRORS = ::T.let(nil, ::T.untyped)
end

ActionDispatch::Http::ParameterFilter = ActiveSupport::ParameterFilter

module ActionDispatch::Http::Parameters
  DEFAULT_PARSERS = ::T.let(nil, ::T.untyped)
  PARAMETERS_KEY = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::URL
  HOST_REGEXP = ::T.let(nil, ::T.untyped)
  IP_HOST_REGEXP = ::T.let(nil, ::T.untyped)
  PROTOCOL_REGEXP = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Integration::Runner
  APP_SESSIONS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Integration::Session
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::Turbolinks::Assertions
  include ::ActionDispatch::Integration::RequestHelpers
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Format
  ESCAPE_PATH = ::T.let(nil, ::T.untyped)
  ESCAPE_SEGMENT = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Journey::Formatter::RegexCaseComparator
  DEFAULT_INPUT = ::T.let(nil, ::T.untyped)
  DEFAULT_REGEX = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::GTG::Builder
  DUMMY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Nodes::Symbol
  DEFAULT_EXP = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Parser
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Journey::Route::VerbMatchers
  VERBS = ::T.let(nil, ::T.untyped)
  VERB_TO_CLASS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Router::Utils
  ENCODER = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Router::Utils::UriEncoder
  ALPHA = ::T.let(nil, ::T.untyped)
  DEC2HEX = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ENCODE = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  SEGMENT = ::T.let(nil, ::T.untyped)
  SUB_DELIMS = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Dot
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Each
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::FunctionalVisitor
  DISPATCH_CACHE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::String
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Visitor
  DISPATCH_CACHE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::RemoteIp
  TRUSTED_PROXIES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Request
  include ::ActionDispatch::Flash::RequestMethods
  ACTION_DISPATCH_REQUEST_ID = ::T.let(nil, ::T.untyped)
  ENV_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_LOOKUP = ::T.let(nil, ::T.untyped)
  LOCALHOST = ::T.let(nil, ::T.untyped)
  RFC2518 = ::T.let(nil, ::T.untyped)
  RFC2616 = ::T.let(nil, ::T.untyped)
  RFC3253 = ::T.let(nil, ::T.untyped)
  RFC3648 = ::T.let(nil, ::T.untyped)
  RFC3744 = ::T.let(nil, ::T.untyped)
  RFC4791 = ::T.let(nil, ::T.untyped)
  RFC5323 = ::T.let(nil, ::T.untyped)
  RFC5789 = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::RequestId
  X_REQUEST_ID = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Response
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE_PARSER = ::T.let(nil, ::T.untyped)
  LOCATION = ::T.let(nil, ::T.untyped)
  NO_CONTENT_CODES = ::T.let(nil, ::T.untyped)
  NullContentTypeHeader = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  SEPARATORS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper
  URL_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Constraints
  CALL = ::T.let(nil, ::T.untyped)
  SERVE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Mapping
  ANCHOR_CHARACTERS_REGEX = ::T.let(nil, ::T.untyped)
  JOINED_SEPARATORS = ::T.let(nil, ::T.untyped)
  OPTIONAL_FORMAT_REGEX = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::Resources
  CANONICAL_ACTIONS = ::T.let(nil, ::T.untyped)
  RESOURCE_OPTIONS = ::T.let(nil, ::T.untyped)
  VALID_ON_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Scope
  NULL = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  RESOURCE_METHOD_SCOPES = ::T.let(nil, ::T.untyped)
  RESOURCE_SCOPES = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::Scoping
  POISON = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::PathRedirect
  URL_PARTS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RouteSet
  DEFAULT_CONFIG = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  RESERVED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RouteSet::Generator
  PARAMETERIZE = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::RouteSet::MountedHelpers
  def _main_app(); end

  def main_app(); end
end

class ActionDispatch::Routing::RouteWrapper
  include ::Sprockets::Rails::RouteWrapper
  def assets_prefix(); end

  def assets_prefix=(val); end

  def assets_prefix?(); end
end

class ActionDispatch::Routing::RouteWrapper
  def self.assets_prefix(); end

  def self.assets_prefix=(val); end

  def self.assets_prefix?(); end
end

class ActionDispatch::Routing::RoutesProxy
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def _routes(); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def initialize(routes, scope, helpers, script_namer=T.unsafe(nil)); end

  def routes(); end

  def routes=(routes); end

  def scope(); end

  def scope=(scope); end
end

class ActionDispatch::Routing::RoutesProxy
  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end
end

class ActionDispatch::SSL
  def call(env); end

  def initialize(app, redirect: T.unsafe(nil), hsts: T.unsafe(nil), secure_cookies: T.unsafe(nil)); end
  HSTS_EXPIRES_IN = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::SSL
  def self.default_hsts_options(); end
end

class ActionDispatch::Session::CacheStore
  def delete_session(env, sid, options); end

  def write_session(env, sid, session, options); end
end

class ActionDispatch::Session::CacheStore
end

class ActionDispatch::ShowExceptions
  FAILSAFE_RESPONSE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::SystemTestCase
  include ::Capybara::DSL
  include ::Capybara::Minitest::Assertions
  include ::ActionDispatch::SystemTesting::TestHelpers::SetupAndTeardown
  include ::ActionDispatch::SystemTesting::TestHelpers::ScreenshotHelper
  def initialize(*_); end

  def method_missing(method, *args, &block); end
end

class ActionDispatch::SystemTestCase
  def self.driven_by(driver, using: T.unsafe(nil), screen_size: T.unsafe(nil), options: T.unsafe(nil), &capabilities); end

  def self.driver(); end

  def self.driver=(val); end

  def self.driver?(); end

  def self.start_application(); end
end

module ActionDispatch::SystemTesting::TestHelpers::ScreenshotHelper
  def take_failed_screenshot(); end

  def take_screenshot(); end
end

module ActionDispatch::SystemTesting::TestHelpers::ScreenshotHelper
end

module ActionDispatch::SystemTesting::TestHelpers::SetupAndTeardown
  def after_teardown(); end

  def before_setup(); end

  def before_teardown(); end

  def host!(host); end
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::SystemTesting::TestHelpers::SetupAndTeardown
end

class ActionDispatch::TestRequest
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::TestResponse
  def parsed_body(); end

  def response_parser(); end
end

class ActionDispatch::TestResponse
  def self.from_response(response); end
end

class ActionMailbox::Base
  include ::ActionMailbox::Routing
end

class ActionMailbox::BaseController
end

class ActionMailbox::BaseController
end

module ActionMailbox::Callbacks
  TERMINATOR = ::T.let(nil, ::T.untyped)
end

class ActionMailbox::InboundEmail
  include ::ActionMailbox::InboundEmail::GeneratedAttributeMethods
  include ::ActionMailbox::InboundEmail::Routable
  include ::ActionMailbox::InboundEmail::MessageId
  include ::ActionMailbox::InboundEmail::Incineratable
  def autosave_associated_records_for_raw_email_attachment(); end

  def autosave_associated_records_for_raw_email_blob(); end

  def mail(); end

  def processed?(); end

  def source(); end
end

class ActionMailbox::InboundEmail::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActionMailbox::InboundEmail::GeneratedRelationMethods
end

class ActionMailbox::InboundEmail::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActionMailbox::InboundEmail::GeneratedRelationMethods
end

class ActionMailbox::InboundEmail::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActionMailbox::InboundEmail::GeneratedRelationMethods
end

module ActionMailbox::InboundEmail::GeneratedAssociationMethods
  def build_raw_email_attachment(*args, &block); end

  def create_raw_email_attachment(*args, &block); end

  def create_raw_email_attachment!(*args, &block); end

  def reload_raw_email_attachment(); end

  def reload_raw_email_blob(); end
end

module ActionMailbox::InboundEmail::GeneratedAttributeMethods
end

module ActionMailbox::InboundEmail::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActionMailbox::InboundEmail::GeneratedRelationMethods
  def bounced(*args, &block); end

  def delivered(*args, &block); end

  def failed(*args, &block); end

  def not_bounced(*args, &block); end

  def not_delivered(*args, &block); end

  def not_failed(*args, &block); end

  def not_pending(*args, &block); end

  def not_processing(*args, &block); end

  def pending(*args, &block); end

  def processing(*args, &block); end

  def with_attached_raw_email(*args, &block); end
end

module ActionMailbox::InboundEmail::GeneratedRelationMethods
  extend ::Mutex_m
end

module ActionMailbox::InboundEmail::Incineratable
  def incinerate(); end

  def incinerate_later(); end
end

class ActionMailbox::InboundEmail::Incineratable::Incineration
  def initialize(inbound_email); end

  def run(); end
end

class ActionMailbox::InboundEmail::Incineratable::Incineration
end

module ActionMailbox::InboundEmail::Incineratable
  extend ::ActiveSupport::Concern
end

module ActionMailbox::InboundEmail::MessageId
end

module ActionMailbox::InboundEmail::MessageId::ClassMethods
  def create_and_extract_message_id!(source, **options); end
end

module ActionMailbox::InboundEmail::MessageId::ClassMethods
end

module ActionMailbox::InboundEmail::MessageId
  extend ::ActiveSupport::Concern
end

module ActionMailbox::InboundEmail::Routable
  def route(); end

  def route_later(); end
end

module ActionMailbox::InboundEmail::Routable
  extend ::ActiveSupport::Concern
end

class ActionMailbox::InboundEmail
  extend ::ActionMailbox::InboundEmail::MessageId::ClassMethods
end

class ActionMailbox::IncinerationJob
  def perform(inbound_email); end
end

class ActionMailbox::IncinerationJob
  def self.schedule(inbound_email); end
end

module ActionMailbox::Ingresses
end

module ActionMailbox::Ingresses::Mailgun
end

class ActionMailbox::Ingresses::Mailgun::InboundEmailsController
  def create(); end
end

class ActionMailbox::Ingresses::Mailgun::InboundEmailsController::Authenticator
  def authenticated?(); end

  def initialize(key:, timestamp:, token:, signature:); end

  def key(); end

  def signature(); end

  def timestamp(); end

  def token(); end
end

class ActionMailbox::Ingresses::Mailgun::InboundEmailsController::Authenticator
end

class ActionMailbox::Ingresses::Mailgun::InboundEmailsController
end

module ActionMailbox::Ingresses::Mailgun
end

module ActionMailbox::Ingresses::Mandrill
end

class ActionMailbox::Ingresses::Mandrill::InboundEmailsController
  def create(); end
end

class ActionMailbox::Ingresses::Mandrill::InboundEmailsController::Authenticator
  def authenticated?(); end

  def initialize(request, key); end

  def key(); end

  def request(); end
end

class ActionMailbox::Ingresses::Mandrill::InboundEmailsController::Authenticator
end

class ActionMailbox::Ingresses::Mandrill::InboundEmailsController
end

module ActionMailbox::Ingresses::Mandrill
end

module ActionMailbox::Ingresses::Postmark
end

class ActionMailbox::Ingresses::Postmark::InboundEmailsController
  def create(); end
end

class ActionMailbox::Ingresses::Postmark::InboundEmailsController
end

module ActionMailbox::Ingresses::Postmark
end

module ActionMailbox::Ingresses::Relay
end

class ActionMailbox::Ingresses::Relay::InboundEmailsController
  def create(); end
end

class ActionMailbox::Ingresses::Relay::InboundEmailsController
end

module ActionMailbox::Ingresses::Relay
end

module ActionMailbox::Ingresses::Sendgrid
end

class ActionMailbox::Ingresses::Sendgrid::InboundEmailsController
  def create(); end
end

class ActionMailbox::Ingresses::Sendgrid::InboundEmailsController
end

module ActionMailbox::Ingresses::Sendgrid
end

module ActionMailbox::Ingresses
end

class ActionMailbox::RoutingJob
  def perform(inbound_email); end
end

class ActionMailbox::RoutingJob
end

class ActionMailer::Base
  PROTECTED_IVARS = ::T.let(nil, ::T.untyped)
end

class ActionMailer::InlinePreviewInterceptor
  PATTERN = ::T.let(nil, ::T.untyped)
end

class ActionMailer::LogSubscriber
  def deliver(event); end

  def process(event); end

  def receive(event); end
end

module ActionMailer::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionPack::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionText::Attachable
  LOCATOR_NAME = ::T.let(nil, ::T.untyped)
end

class ActionText::Attachment
  include ::ActionText::Attachments::Caching
  include ::ActionText::Attachments::Minification
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SELECTOR = ::T.let(nil, ::T.untyped)
  TAG_NAME = ::T.let(nil, ::T.untyped)
end

class ActionText::RichText
  include ::ActionText::RichText::GeneratedAttributeMethods
  def after_add_for_embeds_attachments(); end

  def after_add_for_embeds_attachments=(val); end

  def after_add_for_embeds_attachments?(); end

  def after_add_for_embeds_blobs(); end

  def after_add_for_embeds_blobs=(val); end

  def after_add_for_embeds_blobs?(); end

  def after_remove_for_embeds_attachments(); end

  def after_remove_for_embeds_attachments=(val); end

  def after_remove_for_embeds_attachments?(); end

  def after_remove_for_embeds_blobs(); end

  def after_remove_for_embeds_blobs=(val); end

  def after_remove_for_embeds_blobs?(); end

  def autosave_associated_records_for_embeds_attachments(*args); end

  def autosave_associated_records_for_embeds_blobs(*args); end

  def autosave_associated_records_for_record(*args); end

  def before_add_for_embeds_attachments(); end

  def before_add_for_embeds_attachments=(val); end

  def before_add_for_embeds_attachments?(); end

  def before_add_for_embeds_blobs(); end

  def before_add_for_embeds_blobs=(val); end

  def before_add_for_embeds_blobs?(); end

  def before_remove_for_embeds_attachments(); end

  def before_remove_for_embeds_attachments=(val); end

  def before_remove_for_embeds_attachments?(); end

  def before_remove_for_embeds_blobs(); end

  def before_remove_for_embeds_blobs=(val); end

  def before_remove_for_embeds_blobs?(); end

  def blank?(*args, &block); end

  def empty?(*args, &block); end

  def nil?(*args, &block); end

  def present?(*args, &block); end

  def to_plain_text(); end

  def to_s(*args, &block); end

  def validate_associated_records_for_embeds_attachments(*args); end

  def validate_associated_records_for_embeds_blobs(*args); end
end

class ActionText::RichText::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActionText::RichText::GeneratedRelationMethods
end

class ActionText::RichText::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActionText::RichText::GeneratedRelationMethods
end

class ActionText::RichText::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActionText::RichText::GeneratedRelationMethods
end

module ActionText::RichText::EmbedsAttachmentsAssociationExtension
  def purge(); end

  def purge_later(); end
end

module ActionText::RichText::EmbedsAttachmentsAssociationExtension
end

module ActionText::RichText::GeneratedAssociationMethods
  def embeds_attachment_ids(); end

  def embeds_attachment_ids=(ids); end

  def embeds_blob_ids(); end

  def embeds_blob_ids=(ids); end

  def reload_record(); end
end

module ActionText::RichText::GeneratedAttributeMethods
end

module ActionText::RichText::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActionText::RichText::GeneratedRelationMethods
  def with_attached_embeds(*args, &block); end
end

module ActionText::RichText::GeneratedRelationMethods
  extend ::Mutex_m
end

class ActionText::RichText
  def self.after_add_for_embeds_attachments(); end

  def self.after_add_for_embeds_attachments=(val); end

  def self.after_add_for_embeds_attachments?(); end

  def self.after_add_for_embeds_blobs(); end

  def self.after_add_for_embeds_blobs=(val); end

  def self.after_add_for_embeds_blobs?(); end

  def self.after_remove_for_embeds_attachments(); end

  def self.after_remove_for_embeds_attachments=(val); end

  def self.after_remove_for_embeds_attachments?(); end

  def self.after_remove_for_embeds_blobs(); end

  def self.after_remove_for_embeds_blobs=(val); end

  def self.after_remove_for_embeds_blobs?(); end

  def self.before_add_for_embeds_attachments(); end

  def self.before_add_for_embeds_attachments=(val); end

  def self.before_add_for_embeds_attachments?(); end

  def self.before_add_for_embeds_blobs(); end

  def self.before_add_for_embeds_blobs=(val); end

  def self.before_add_for_embeds_blobs?(); end

  def self.before_remove_for_embeds_attachments(); end

  def self.before_remove_for_embeds_attachments=(val); end

  def self.before_remove_for_embeds_attachments?(); end

  def self.before_remove_for_embeds_blobs(); end

  def self.before_remove_for_embeds_blobs=(val); end

  def self.before_remove_for_embeds_blobs?(); end
end

class ActionText::TrixAttachment
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_TYPES = ::T.let(nil, ::T.untyped)
  COMPOSED_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SELECTOR = ::T.let(nil, ::T.untyped)
  TAG_NAME = ::T.let(nil, ::T.untyped)
end

module ActionView
  ENCODING_FLAG = ::T.let(nil, ::T.untyped)
end

class ActionView::AbstractRenderer::RenderedTemplate
  EMPTY_SPACER = ::T.let(nil, ::T.untyped)
end

class ActionView::Base
  include ::ActionView::Context
  include ::ERB::Util
  include ::ActionCable::Helpers::ActionCableHelper
  include ::Webpacker::Helper
  include ::Sprockets::Rails::Helper
  include ::Sprockets::Rails::Utils
  def assets_environment(); end

  def assets_environment=(val); end

  def assets_environment?(); end

  def assets_manifest(); end

  def assets_manifest=(val); end

  def assets_manifest?(); end

  def assets_precompile(); end

  def assets_precompile=(val); end

  def assets_precompile?(); end

  def assets_prefix(); end

  def assets_prefix=(val); end

  def assets_prefix?(); end

  def check_precompiled_asset(); end

  def check_precompiled_asset=(val); end

  def check_precompiled_asset?(); end

  def debug_assets(); end

  def debug_assets=(val); end

  def debug_assets?(); end

  def digest_assets(); end

  def digest_assets=(val); end

  def digest_assets?(); end

  def precompiled_asset_checker(); end

  def precompiled_asset_checker=(val); end

  def precompiled_asset_checker?(); end

  def resolve_assets_with(); end

  def resolve_assets_with=(val); end

  def resolve_assets_with?(); end

  def unknown_asset_fallback(); end

  def unknown_asset_fallback=(val); end

  def unknown_asset_fallback?(); end
  NULL = ::T.let(nil, ::T.untyped)
end

class ActionView::Base
  def self.assets_environment(); end

  def self.assets_environment=(val); end

  def self.assets_environment?(); end

  def self.assets_manifest(); end

  def self.assets_manifest=(val); end

  def self.assets_manifest?(); end

  def self.assets_precompile(); end

  def self.assets_precompile=(val); end

  def self.assets_precompile?(); end

  def self.assets_prefix(); end

  def self.assets_prefix=(val); end

  def self.assets_prefix?(); end

  def self.check_precompiled_asset(); end

  def self.check_precompiled_asset=(val); end

  def self.check_precompiled_asset?(); end

  def self.debug_assets(); end

  def self.debug_assets=(val); end

  def self.debug_assets?(); end

  def self.digest_assets(); end

  def self.digest_assets=(val); end

  def self.digest_assets?(); end

  def self.precompiled_asset_checker(); end

  def self.precompiled_asset_checker=(val); end

  def self.precompiled_asset_checker?(); end

  def self.resolve_assets_with(); end

  def self.resolve_assets_with=(val); end

  def self.resolve_assets_with?(); end

  def self.unknown_asset_fallback(); end

  def self.unknown_asset_fallback=(val); end

  def self.unknown_asset_fallback?(); end
end

class ActionView::DependencyTracker::ERBTracker
  EXPLICIT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  IDENTIFIER = ::T.let(nil, ::T.untyped)
  LAYOUT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  LAYOUT_HASH_KEY = ::T.let(nil, ::T.untyped)
  PARTIAL_HASH_KEY = ::T.let(nil, ::T.untyped)
  RENDER_ARGUMENTS = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  VARIABLE_OR_METHOD_CHAIN = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::AssetUrlHelper
  ASSET_EXTENSIONS = ::T.let(nil, ::T.untyped)
  ASSET_PUBLIC_DIRECTORIES = ::T.let(nil, ::T.untyped)
  URI_REGEXP = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::ControllerHelper
  CONTROLLER_DELEGATES = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::DateHelper
  MINUTES_IN_QUARTER_YEAR = ::T.let(nil, ::T.untyped)
  MINUTES_IN_THREE_QUARTERS_YEAR = ::T.let(nil, ::T.untyped)
  MINUTES_IN_YEAR = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::JavaScriptHelper
  JS_ESCAPE_MAP = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::TagHelper
  BOOLEAN_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  PRE_CONTENT_STRINGS = ::T.let(nil, ::T.untyped)
  TAG_PREFIXES = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::UrlHelper
  BUTTON_TAG_METHOD_VERBS = ::T.let(nil, ::T.untyped)
  STRINGIFIED_COMMON_METHODS = ::T.let(nil, ::T.untyped)
end

class ActionView::LogSubscriber
  def render_collection(event); end

  def render_partial(event); end

  def render_template(event); end
  EMPTY = ::T.let(nil, ::T.untyped)
  VIEWS_PATTERN = ::T.let(nil, ::T.untyped)
end

module ActionView::LookupContext::Accessors
  DEFAULT_PROCS = ::T.let(nil, ::T.untyped)
end

class ActionView::OutputBuffer
  def append=(value); end

  def initialize(*_); end

  def safe_append=(value); end

  def safe_expr_append=(val); end
end

class ActionView::OutputBuffer
end

class ActionView::OutputFlow
  def append(key, value); end

  def append!(key, value); end

  def content(); end

  def get(key); end

  def set(key, value); end
end

class ActionView::OutputFlow
end

class ActionView::PartialRenderer
  include ::ActiveRecord::Railties::CollectionCacheAssociationLoading
  IDENTIFIER_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
  OPTION_AS_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
  PREFIXED_PARTIAL_NAMES = ::T.let(nil, ::T.untyped)
end

class ActionView::PathResolver
  DEFAULT_PATTERN = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class ActionView::Railtie
  NULL_OPTION = ::T.let(nil, ::T.untyped)
end

module ActionView::RecordIdentifier
  JOIN = ::T.let(nil, ::T.untyped)
  NEW = ::T.let(nil, ::T.untyped)
end

class ActionView::Renderer
  def cache_hits(); end

  def initialize(lookup_context); end

  def lookup_context(); end

  def lookup_context=(lookup_context); end

  def render(context, options); end

  def render_body(context, options); end

  def render_partial(context, options, &block); end

  def render_partial_to_object(context, options, &block); end

  def render_template(context, options); end

  def render_template_to_object(context, options); end

  def render_to_object(context, options); end
end

class ActionView::Renderer
end

class ActionView::Resolver::Cache
  KEY_BLOCK = ::T.let(nil, ::T.untyped)
  NAME_BLOCK = ::T.let(nil, ::T.untyped)
  NO_TEMPLATES = ::T.let(nil, ::T.untyped)
  PARTIAL_BLOCK = ::T.let(nil, ::T.untyped)
  PREFIX_BLOCK = ::T.let(nil, ::T.untyped)
end

class ActionView::StreamingBuffer
  def <<(value); end

  def append=(value); end

  def concat(value); end

  def html_safe(); end

  def initialize(block); end

  def safe_append=(value); end

  def safe_concat(value); end
end

class ActionView::StreamingBuffer
end

class ActionView::StreamingFlow
  def initialize(view, fiber); end
end

class ActionView::StreamingFlow
end

class ActionView::StreamingTemplateRenderer
  def render_template(view, template, layout_name=T.unsafe(nil), locals=T.unsafe(nil)); end
end

class ActionView::StreamingTemplateRenderer::Body
  def each(&block); end

  def initialize(&start); end
end

class ActionView::StreamingTemplateRenderer::Body
end

class ActionView::StreamingTemplateRenderer
end

class ActionView::Template::Error
  SOURCE_CODE_RADIUS = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Handlers::ERB
  ENCODING_TAG = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Handlers::ERB::Erubi
  BLOCK_EXPR = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Inline
  Finalizer = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Sources::File
  def initialize(filename); end
end

class ActionView::Template::Sources::File
end

class ActionView::Template::Types::Type
  SET = ::T.let(nil, ::T.untyped)
end

class ActionView::TemplateRenderer
  def render(context, options); end
end

class ActionView::TemplateRenderer
end

class ActionView::TestCase
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
end

module ActionView::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  INTERNAL_IVARS = ::T.let(nil, ::T.untyped)
end

module ActionView::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveJob::Arguments
  OBJECT_SERIALIZER_KEY = ::T.let(nil, ::T.untyped)
end

module ActiveJob::Callbacks
  extend ::ActiveSupport::Callbacks
end

class ActiveJob::ConfiguredJob
  def initialize(job_class, options=T.unsafe(nil)); end

  def perform_later(*args); end

  def perform_now(*args); end
end

class ActiveJob::ConfiguredJob
end

class ActiveJob::QueueAdapters::AsyncAdapter::Scheduler
  DEFAULT_EXECUTOR_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveJob::QueueAdapters::InlineAdapter
  def enqueue(job); end

  def enqueue_at(*_); end
end

class ActiveJob::QueueAdapters::InlineAdapter
end

class ActiveJob::QueueAdapters::TestAdapter
  def enqueue(job); end

  def enqueue_at(job, timestamp); end

  def enqueued_jobs(); end

  def enqueued_jobs=(enqueued_jobs); end

  def filter(); end

  def filter=(filter); end

  def perform_enqueued_at_jobs(); end

  def perform_enqueued_at_jobs=(perform_enqueued_at_jobs); end

  def perform_enqueued_jobs(); end

  def perform_enqueued_jobs=(perform_enqueued_jobs); end

  def performed_jobs(); end

  def performed_jobs=(performed_jobs); end

  def queue(); end

  def queue=(queue); end

  def reject(); end

  def reject=(reject); end
end

class ActiveJob::QueueAdapters::TestAdapter
end

class ActiveJob::TestCase
  include ::ActiveJob::TestHelper
end

class ActiveJob::TestCase
end

module ActiveJob::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveModel::AttributeMethods
  CALL_COMPILABLE_REGEXP = ::T.let(nil, ::T.untyped)
  NAME_COMPILABLE_REGEXP = ::T.let(nil, ::T.untyped)
end

class ActiveModel::AttributeMutationTracker
  OPTION_NOT_GIVEN = ::T.let(nil, ::T.untyped)
end

module ActiveModel::Attributes
  def attribute_names(); end

  def attributes(); end

  def initialize(*_); end
end

module ActiveModel::Attributes::ClassMethods
  def attribute(name, type=T.unsafe(nil), **options); end

  def attribute_names(); end
end

module ActiveModel::Attributes::ClassMethods
end

module ActiveModel::Attributes
  extend ::ActiveSupport::Concern
end

class ActiveModel::Errors
  CALLBACKS_OPTIONS = ::T.let(nil, ::T.untyped)
  MESSAGE_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActiveModel::Lint
end

module ActiveModel::Lint::Tests
  def test_errors_aref(); end

  def test_model_naming(); end

  def test_persisted?(); end

  def test_to_key(); end

  def test_to_param(); end

  def test_to_partial_path(); end
end

module ActiveModel::Lint::Tests
end

module ActiveModel::Lint
end

module ActiveModel::SecurePassword
  MAX_PASSWORD_LENGTH_ALLOWED = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Boolean
  FALSE_VALUES = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Date
  ISO_DATE = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Decimal
  BIGDECIMAL_PRECISION = ::T.let(nil, ::T.untyped)
end

module ActiveModel::Type::Helpers::TimeValue
  ISO_DATETIME = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Integer
  DEFAULT_LIMIT = ::T.let(nil, ::T.untyped)
end

module ActiveModel::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::AttributeMethods
  RESTRICTED_CLASS_METHODS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Base::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActiveRecord::Batches
  ORDER_IGNORE_MESSAGE = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Callbacks
  CALLBACKS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Coders::JSON
end

class ActiveRecord::Coders::JSON
  def self.dump(obj); end

  def self.load(json); end
end

class ActiveRecord::Coders::YAMLColumn
  def assert_valid_value(obj, action:); end

  def dump(obj); end

  def initialize(attr_name, object_class=T.unsafe(nil)); end

  def load(yaml); end

  def object_class(); end

  def object_class=(object_class); end
end

class ActiveRecord::Coders::YAMLColumn
end

class ActiveRecord::ConcurrentMigrationError
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
  RELEASE_LOCK_FAILED_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter
  include ::ActiveRecord::ConnectionAdapters::SchemaStatements
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::ConnectionAdapters::DatabaseStatements
  ADAPTER_NAME = ::T.let(nil, ::T.untyped)
  SIMPLE_INT = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::DatabaseStatements
  BYTEA_COLUMN_TYPE_OID = ::T.let(nil, ::T.untyped)
  MONEY_COLUMN_TYPE_OID = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Name
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Hstore
  HstorePair = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Uuid
  ACCEPTABLE_UUID = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter
  ADAPTER_NAME = ::T.let(nil, ::T.untyped)
  CACHED_PLAN_HEURISTIC = ::T.let(nil, ::T.untyped)
  DEADLOCK_DETECTED = ::T.let(nil, ::T.untyped)
  FEATURE_NOT_SUPPORTED = ::T.let(nil, ::T.untyped)
  FOREIGN_KEY_VIOLATION = ::T.let(nil, ::T.untyped)
  LOCK_NOT_AVAILABLE = ::T.let(nil, ::T.untyped)
  NATIVE_DATABASE_TYPES = ::T.let(nil, ::T.untyped)
  NOT_NULL_VIOLATION = ::T.let(nil, ::T.untyped)
  NUMERIC_VALUE_OUT_OF_RANGE = ::T.let(nil, ::T.untyped)
  OPERATION_ALIASES = ::T.let(nil, ::T.untyped)
  QUERY_CANCELED = ::T.let(nil, ::T.untyped)
  SERIALIZATION_FAILURE = ::T.let(nil, ::T.untyped)
  UNIQUE_VIOLATION = ::T.let(nil, ::T.untyped)
  VALUE_LIMIT_VIOLATION = ::T.let(nil, ::T.untyped)
end

ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::OID = ActiveRecord::ConnectionAdapters::PostgreSQL::OID

ActiveRecord::ConnectionAdapters::PostgreSQLColumn = ActiveRecord::ConnectionAdapters::PostgreSQL::Column

ActiveRecord::ConnectionAdapters::PostgreSQLTypeMetadata = ActiveRecord::ConnectionAdapters::PostgreSQL::TypeMetadata

ActiveRecord::ConnectionAdapters::SchemaCreation = ActiveRecord::ConnectionAdapters::AbstractAdapter::SchemaCreation

class ActiveRecord::ConnectionAdapters::StatementPool
  DEFAULT_STATEMENT_LIMIT = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::TransactionManager
  NULL_TRANSACTION = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::ConnectionHandling
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
  RAILS_ENV = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ExplainSubscriber
  EXPLAINED_SQLS = ::T.let(nil, ::T.untyped)
  IGNORED_PAYLOADS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::FinderMethods
  ONE_AS_ONE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::FixtureSet
  MAX_ID = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::InternalMetadata::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActiveRecord::InternalMetadata::GeneratedRelationMethods
  extend ::Mutex_m
end

module ActiveRecord::LegacyYamlAdapter
end

module ActiveRecord::LegacyYamlAdapter::Rails41
end

module ActiveRecord::LegacyYamlAdapter::Rails41
  def self.convert(klass, coder); end
end

module ActiveRecord::LegacyYamlAdapter::Rails420
end

module ActiveRecord::LegacyYamlAdapter::Rails420
  def self.convert(klass, coder); end
end

module ActiveRecord::LegacyYamlAdapter
  def self.convert(klass, coder); end
end

class ActiveRecord::LogSubscriber
  def backtrace_cleaner(); end

  def backtrace_cleaner=(val); end

  def backtrace_cleaner?(); end

  def sql(event); end
  IGNORE_PAYLOAD_NAMES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Middleware::DatabaseSelector
  def call(env); end

  def context_klass(); end

  def initialize(app, resolver_klass=T.unsafe(nil), context_klass=T.unsafe(nil), options=T.unsafe(nil)); end

  def options(); end

  def resolver_klass(); end
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver
  def context(); end

  def delay(); end

  def initialize(context, options=T.unsafe(nil)); end

  def instrumenter(); end

  def read(&blk); end

  def write(&blk); end
  SEND_TO_REPLICA_DELAY = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver::Session
  def initialize(session); end

  def last_write_timestamp(); end

  def session(); end

  def update_last_write_timestamp(); end
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver::Session
  def self.call(request); end

  def self.convert_time_to_timestamp(time); end

  def self.convert_timestamp_to_time(timestamp); end
end

class ActiveRecord::Middleware::DatabaseSelector::Resolver
  def self.call(context, options=T.unsafe(nil)); end
end

class ActiveRecord::Middleware::DatabaseSelector
end

class ActiveRecord::Migration
  MigrationFilenameRegexp = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Migration::CommandRecorder
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::Migration::CommandRecorder::StraightReversions
  def add_belongs_to(*args, &block); end

  def add_column(*args, &block); end

  def add_foreign_key(*args, &block); end

  def add_index(*args, &block); end

  def add_reference(*args, &block); end

  def add_timestamps(*args, &block); end

  def change_column(*args, &block); end

  def change_column_comment(*args, &block); end

  def change_column_default(*args, &block); end

  def change_column_null(*args, &block); end

  def change_table(table_name, options=T.unsafe(nil)); end

  def change_table_comment(*args, &block); end

  def commands(); end

  def commands=(commands); end

  def create_join_table(*args, &block); end

  def create_table(*args, &block); end

  def delegate(); end

  def delegate=(delegate); end

  def disable_extension(*args, &block); end

  def drop_join_table(*args, &block); end

  def drop_table(*args, &block); end

  def enable_extension(*args, &block); end

  def execute(*args, &block); end

  def execute_block(*args, &block); end

  def initialize(delegate=T.unsafe(nil)); end

  def inverse_of(command, args, &block); end

  def invert_add_belongs_to(args, &block); end

  def invert_remove_belongs_to(args, &block); end

  def record(*command, &block); end

  def remove_belongs_to(*args, &block); end

  def remove_column(*args, &block); end

  def remove_columns(*args, &block); end

  def remove_foreign_key(*args, &block); end

  def remove_index(*args, &block); end

  def remove_reference(*args, &block); end

  def remove_timestamps(*args, &block); end

  def rename_column(*args, &block); end

  def rename_index(*args, &block); end

  def rename_table(*args, &block); end

  def replay(migration); end

  def revert(); end

  def reverting(); end

  def reverting=(reverting); end

  def transaction(*args, &block); end
  ReversibleAndIrreversibleMethods = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Migration::CommandRecorder::StraightReversions
  def invert_add_column(args, &block); end

  def invert_add_reference(args, &block); end

  def invert_add_timestamps(args, &block); end

  def invert_create_join_table(args, &block); end

  def invert_create_table(args, &block); end

  def invert_disable_extension(args, &block); end

  def invert_drop_join_table(args, &block); end

  def invert_drop_table(args, &block); end

  def invert_enable_extension(args, &block); end

  def invert_execute_block(args, &block); end

  def invert_remove_column(args, &block); end

  def invert_remove_reference(args, &block); end

  def invert_remove_timestamps(args, &block); end
end

module ActiveRecord::Migration::CommandRecorder::StraightReversions
end

class ActiveRecord::Migration::CommandRecorder
end

class ActiveRecord::Migration::Compatibility::V4_2
  def index_exists?(table_name, column_name, options=T.unsafe(nil)); end

  def remove_index(table_name, options=T.unsafe(nil)); end
end

module ActiveRecord::Migration::Compatibility::V4_2::TableDefinition
  def belongs_to(*_, **options); end

  def references(*_, **options); end

  def timestamps(**options); end
end

module ActiveRecord::Migration::Compatibility::V4_2::TableDefinition
end

class ActiveRecord::Migration::Compatibility::V4_2
end

class ActiveRecord::Migration::Compatibility::V5_0
  def add_belongs_to(table_name, ref_name, **options); end

  def add_column(table_name, column_name, type, options=T.unsafe(nil)); end

  def add_reference(table_name, ref_name, **options); end

  def create_join_table(table_1, table_2, column_options: T.unsafe(nil), **options); end
end

module ActiveRecord::Migration::Compatibility::V5_0::TableDefinition
  def belongs_to(*args, **options); end

  def primary_key(name, type=T.unsafe(nil), **options); end

  def references(*args, **options); end
end

module ActiveRecord::Migration::Compatibility::V5_0::TableDefinition
end

class ActiveRecord::Migration::Compatibility::V5_0
end

class ActiveRecord::Migration::Compatibility::V5_1
  def change_column(table_name, column_name, type, options=T.unsafe(nil)); end

  def create_table(table_name, options=T.unsafe(nil)); end
end

class ActiveRecord::Migration::Compatibility::V5_2
  def add_timestamps(table_name, **options); end

  def change_table(table_name, **options); end

  def create_join_table(table_1, table_2, **options); end
end

module ActiveRecord::Migration::Compatibility::V5_2::CommandRecorder
  def invert_change_column_comment(args); end

  def invert_change_table_comment(args); end

  def invert_transaction(args, &block); end
end

module ActiveRecord::Migration::Compatibility::V5_2::CommandRecorder
end

module ActiveRecord::Migration::Compatibility::V5_2::TableDefinition
  def timestamps(**options); end
end

module ActiveRecord::Migration::Compatibility::V5_2::TableDefinition
end

module ActiveRecord::Migration::Compatibility
  def self.find(version); end
end

class ActiveRecord::Migrator
  MIGRATOR_SALT = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::NestedAttributes
  UNASSIGNABLE_KEYS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::NullRelation
  def any?(); end

  def calculate(operation, _column_name); end

  def delete(_id_or_array); end

  def delete_all(); end

  def empty?(); end

  def exists?(_conditions=T.unsafe(nil)); end

  def many?(); end

  def none?(); end

  def one?(); end

  def or(other); end

  def pluck(*column_names); end

  def to_sql(); end

  def update_all(_updates); end
end

module ActiveRecord::NullRelation
end

module ActiveRecord::QueryMethods
  DEFAULT_VALUES = ::T.let(nil, ::T.untyped)
  FROZEN_EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  FROZEN_EMPTY_HASH = ::T.let(nil, ::T.untyped)
  STRUCTURAL_OR_METHODS = ::T.let(nil, ::T.untyped)
  VALID_DIRECTIONS = ::T.let(nil, ::T.untyped)
  VALID_UNSCOPING_VALUES = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Querying
  QUERYING_METHODS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Reflection
  extend ::ActiveStorage::Reflection::ReflectionExtension
end

class ActiveRecord::Relation
  include ::ActiveRecord::Delegation
  include ::ActiveRecord::Explain
  include ::ActiveRecord::Batches
  include ::ActiveRecord::QueryMethods
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveRecord::SpawnMethods
  include ::ActiveRecord::Calculations
  CLAUSE_METHODS = ::T.let(nil, ::T.untyped)
  INVALID_METHODS_FOR_DELETE_ALL = ::T.let(nil, ::T.untyped)
  MULTI_VALUE_METHODS = ::T.let(nil, ::T.untyped)
  SINGLE_VALUE_METHODS = ::T.let(nil, ::T.untyped)
  VALUE_METHODS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::SchemaMigration::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActiveRecord::SchemaMigration::GeneratedRelationMethods
  extend ::Mutex_m
end

module ActiveRecord::Tasks::DatabaseTasks
  LOCAL_HOSTS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Tasks::MySQLDatabaseTasks
  def charset(); end

  def collation(); end

  def connection(*args, &block); end

  def create(); end

  def drop(); end

  def establish_connection(*args, &block); end

  def initialize(configuration); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
  ER_DB_CREATE_EXISTS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Tasks::MySQLDatabaseTasks
end

class ActiveRecord::Tasks::PostgreSQLDatabaseTasks
  def charset(); end

  def clear_active_connections!(*args, &block); end

  def collation(); end

  def connection(*args, &block); end

  def create(master_established=T.unsafe(nil)); end

  def drop(); end

  def establish_connection(*args, &block); end

  def initialize(configuration); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
  DEFAULT_ENCODING = ::T.let(nil, ::T.untyped)
  ON_ERROR_STOP_1 = ::T.let(nil, ::T.untyped)
  SQL_COMMENT_BEGIN = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Tasks::PostgreSQLDatabaseTasks
end

class ActiveRecord::Tasks::SQLiteDatabaseTasks
  def charset(); end

  def connection(*args, &block); end

  def create(); end

  def drop(); end

  def establish_connection(*args, &block); end

  def initialize(configuration, root=T.unsafe(nil)); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
end

class ActiveRecord::Tasks::SQLiteDatabaseTasks
end

module ActiveRecord::Transactions
  ACTIONS = ::T.let(nil, ::T.untyped)
end

ActiveRecord::Type::BigInteger = ActiveModel::Type::BigInteger

ActiveRecord::Type::Binary = ActiveModel::Type::Binary

ActiveRecord::Type::Decimal = ActiveModel::Type::Decimal

ActiveRecord::Type::Float = ActiveModel::Type::Float

ActiveRecord::Type::Integer = ActiveModel::Type::Integer

module ActiveRecord::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class ActiveStorage::AnalyzeJob
  def perform(blob); end
end

class ActiveStorage::AnalyzeJob
end

class ActiveStorage::Analyzer::NullAnalyzer
end

class ActiveStorage::Analyzer::NullAnalyzer
end

class ActiveStorage::Attachment
  include ::ActiveStorage::Attachment::GeneratedAttributeMethods
  def autosave_associated_records_for_blob(*args); end

  def autosave_associated_records_for_record(*args); end

  def purge(); end

  def purge_later(); end
end

class ActiveStorage::Attachment::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveStorage::Attachment::GeneratedRelationMethods
end

class ActiveStorage::Attachment::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveStorage::Attachment::GeneratedRelationMethods
end

class ActiveStorage::Attachment::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveStorage::Attachment::GeneratedRelationMethods
end

module ActiveStorage::Attachment::GeneratedAssociationMethods
  def build_blob(*args, &block); end

  def create_blob(*args, &block); end

  def create_blob!(*args, &block); end

  def reload_blob(); end

  def reload_record(); end
end

module ActiveStorage::Attachment::GeneratedAttributeMethods
end

module ActiveStorage::Attachment::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActiveStorage::Attachment::GeneratedRelationMethods
end

module ActiveStorage::Attachment::GeneratedRelationMethods
  extend ::Mutex_m
end

class ActiveStorage::BaseController
  include ::ActiveStorage::SetCurrent
end

class ActiveStorage::BaseController
end

class ActiveStorage::BaseJob
end

class ActiveStorage::BaseJob
end

class ActiveStorage::Blob
  include ::ActiveStorage::Blob::GeneratedAttributeMethods
  include ::ActiveStorage::Blob::Analyzable
  include ::ActiveStorage::Blob::Identifiable
  include ::ActionText::Attachable
  def after_add_for_attachments(); end

  def after_add_for_attachments=(val); end

  def after_add_for_attachments?(); end

  def after_remove_for_attachments(); end

  def after_remove_for_attachments=(val); end

  def after_remove_for_attachments?(); end

  def attachable_plain_text_representation(caption=T.unsafe(nil)); end

  def audio?(); end

  def autosave_associated_records_for_attachments(*args); end

  def autosave_associated_records_for_preview_image_attachment(); end

  def autosave_associated_records_for_preview_image_blob(); end

  def before_add_for_attachments(); end

  def before_add_for_attachments=(val); end

  def before_add_for_attachments?(); end

  def before_remove_for_attachments(); end

  def before_remove_for_attachments=(val); end

  def before_remove_for_attachments?(); end

  def download(&block); end

  def filename(); end

  def image?(); end

  def key(); end

  def open(tmpdir: T.unsafe(nil), &block); end

  def purge(); end

  def purge_later(); end

  def regenerate_key(); end

  def service(); end

  def service=(val); end

  def service?(); end

  def service_headers_for_direct_upload(); end

  def service_url(expires_in: T.unsafe(nil), disposition: T.unsafe(nil), filename: T.unsafe(nil), **options); end

  def service_url_for_direct_upload(expires_in: T.unsafe(nil)); end

  def signed_id(); end

  def text?(); end

  def unfurl(io, identify: T.unsafe(nil)); end

  def upload(io, identify: T.unsafe(nil)); end

  def upload_without_unfurling(io); end

  def validate_associated_records_for_attachments(*args); end

  def video?(); end
end

class ActiveStorage::Blob::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveStorage::Blob::GeneratedRelationMethods
end

class ActiveStorage::Blob::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveStorage::Blob::GeneratedRelationMethods
end

class ActiveStorage::Blob::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ActiveStorage::Blob::GeneratedRelationMethods
end

module ActiveStorage::Blob::Analyzable
  def analyze(); end

  def analyze_later(); end

  def analyzed?(); end
end

module ActiveStorage::Blob::Analyzable
end

module ActiveStorage::Blob::GeneratedAssociationMethods
  def attachment_ids(); end

  def attachment_ids=(ids); end

  def build_preview_image_attachment(*args, &block); end

  def create_preview_image_attachment(*args, &block); end

  def create_preview_image_attachment!(*args, &block); end

  def reload_preview_image_attachment(); end

  def reload_preview_image_blob(); end
end

module ActiveStorage::Blob::GeneratedAttributeMethods
end

module ActiveStorage::Blob::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ActiveStorage::Blob::GeneratedRelationMethods
  def unattached(*args, &block); end

  def with_attached_preview_image(*args, &block); end
end

module ActiveStorage::Blob::GeneratedRelationMethods
  extend ::Mutex_m
end

module ActiveStorage::Blob::Identifiable
  def identified?(); end

  def identify(); end
end

module ActiveStorage::Blob::Identifiable
end

module ActiveStorage::Blob::Representable
  def preview(transformations); end

  def previewable?(); end

  def representable?(); end

  def representation(transformations); end

  def variable?(); end
end

module ActiveStorage::Blob::Representable
  extend ::ActiveSupport::Concern
end

class ActiveStorage::Blob
  extend ::ActionText::Attachable::ClassMethods
  def self.after_add_for_attachments(); end

  def self.after_add_for_attachments=(val); end

  def self.after_add_for_attachments?(); end

  def self.after_remove_for_attachments(); end

  def self.after_remove_for_attachments=(val); end

  def self.after_remove_for_attachments?(); end

  def self.before_add_for_attachments(); end

  def self.before_add_for_attachments=(val); end

  def self.before_add_for_attachments?(); end

  def self.before_remove_for_attachments(); end

  def self.before_remove_for_attachments=(val); end

  def self.before_remove_for_attachments?(); end

  def self.build_after_unfurling(io:, filename:, content_type: T.unsafe(nil), metadata: T.unsafe(nil), identify: T.unsafe(nil)); end

  def self.build_after_upload(io:, filename:, content_type: T.unsafe(nil), metadata: T.unsafe(nil), identify: T.unsafe(nil)); end

  def self.create_after_unfurling!(io:, filename:, content_type: T.unsafe(nil), metadata: T.unsafe(nil), identify: T.unsafe(nil), record: T.unsafe(nil)); end

  def self.create_after_upload!(io:, filename:, content_type: T.unsafe(nil), metadata: T.unsafe(nil), identify: T.unsafe(nil), record: T.unsafe(nil)); end

  def self.create_and_upload!(io:, filename:, content_type: T.unsafe(nil), metadata: T.unsafe(nil), identify: T.unsafe(nil), record: T.unsafe(nil)); end

  def self.create_before_direct_upload!(filename:, byte_size:, checksum:, content_type: T.unsafe(nil), metadata: T.unsafe(nil)); end

  def self.find_signed(id); end

  def self.service(); end

  def self.service=(val); end

  def self.service?(); end
end

class ActiveStorage::BlobsController
  include ::ActiveStorage::SetBlob
  def show(); end
end

class ActiveStorage::BlobsController
end

class ActiveStorage::Current
end

class ActiveStorage::Current
  def self.host(); end

  def self.host=(attribute); end
end

class ActiveStorage::DirectUploadsController
  def create(); end
end

class ActiveStorage::DirectUploadsController
end

class ActiveStorage::DiskController
  def show(); end

  def update(); end
end

class ActiveStorage::DiskController
end

class ActiveStorage::Filename
  include ::Comparable
  def as_json(*_); end

  def base(); end

  def extension(); end

  def extension_with_delimiter(); end

  def extension_without_delimiter(); end

  def initialize(filename); end

  def sanitized(); end

  def to_json(); end
end

class ActiveStorage::Filename
  def self.wrap(filename); end
end

class ActiveStorage::LogSubscriber
  def service_delete(event); end

  def service_delete_prefixed(event); end

  def service_download(event); end

  def service_exist(event); end

  def service_streaming_download(event); end

  def service_upload(event); end

  def service_url(event); end
end

class ActiveStorage::Preview
  def blob(); end

  def image(); end

  def initialize(blob, variation_or_variation_key); end

  def processed(); end

  def service_url(**options); end

  def variation(); end
end

class ActiveStorage::Preview::UnprocessedError
end

class ActiveStorage::Preview::UnprocessedError
end

class ActiveStorage::Preview
end

class ActiveStorage::PurgeJob
  def perform(blob); end
end

class ActiveStorage::PurgeJob
end

class ActiveStorage::RepresentationsController
  include ::ActiveStorage::SetBlob
  def show(); end
end

class ActiveStorage::RepresentationsController
end

class ActiveStorage::Service::DiskService
  def download(key, &block); end

  def headers_for_direct_upload(key, content_type:, **_); end

  def initialize(root:); end

  def path_for(key); end

  def root(); end

  def upload(key, io, checksum: T.unsafe(nil), **_); end

  def url(key, expires_in:, filename:, disposition:, content_type:); end
end

class ActiveStorage::Service::DiskService
end

module ActiveStorage::SetBlob
end

module ActiveStorage::SetBlob
  extend ::ActiveSupport::Concern
end

module ActiveStorage::SetCurrent
end

module ActiveStorage::SetCurrent
  extend ::ActiveSupport::Concern
end

module ActiveStorage::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class ActiveStorage::Variant
  def blob(); end

  def content_type(*args, &block); end

  def filename(*args, &block); end

  def format(*args, &block); end

  def image(); end

  def initialize(blob, variation_or_variation_key); end

  def key(); end

  def processed(); end

  def service(*args, &block); end

  def service_url(expires_in: T.unsafe(nil), disposition: T.unsafe(nil)); end

  def variation(); end
  WEB_IMAGE_CONTENT_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveStorage::Variant::Specification
end

class ActiveStorage::Variant::Specification
end

class ActiveStorage::Variant
end

class ActiveStorage::Variation
  def initialize(transformations); end

  def key(); end

  def transform(file, format: T.unsafe(nil), &block); end

  def transformations(); end
end

class ActiveStorage::Variation
  def self.decode(key); end

  def self.encode(transformations); end

  def self.wrap(variator); end
end

class ActiveSupport::BacktraceCleaner
  FORMATTED_GEMS_PATTERN = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache
  UNIVERSAL_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::Entry
  DEFAULT_COMPRESS_LIMIT = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::FileStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
  DIR_FORMATTER = ::T.let(nil, ::T.untyped)
  FILENAME_MAX_SIZE = ::T.let(nil, ::T.untyped)
  FILEPATH_MAX_SIZE = ::T.let(nil, ::T.untyped)
  GITKEEP_FILES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::MemoryStore
  PER_ENTRY_OVERHEAD = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::NullStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
end

module ActiveSupport::Callbacks
  CALLBACK_FILTER_TYPES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Dependencies
  Reference = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Dependencies
  extend ::Bootsnap::LoadPathCache::CoreExt::ActiveSupport::ClassMethods
  extend ::ActiveSupport::Dependencies::ZeitwerkIntegration::Decorations
end

class ActiveSupport::Deprecation
  def deprecation_horizon(); end

  def deprecation_horizon=(deprecation_horizon); end

  def initialize(deprecation_horizon=T.unsafe(nil), gem_name=T.unsafe(nil)); end
  DEFAULT_BEHAVIORS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Deprecation::Reporting
  RAILS_GEM_ROOT = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Deprecation
  extend ::ActiveSupport::Deprecation::InstanceDelegator::OverrideDelegators
end

class ActiveSupport::Duration
  PARTS = ::T.let(nil, ::T.untyped)
  PARTS_IN_SECONDS = ::T.let(nil, ::T.untyped)
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
  SECONDS_PER_HOUR = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MINUTE = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MONTH = ::T.let(nil, ::T.untyped)
  SECONDS_PER_WEEK = ::T.let(nil, ::T.untyped)
  SECONDS_PER_YEAR = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Parser
  COMMA = ::T.let(nil, ::T.untyped)
  DATE_COMPONENT = ::T.let(nil, ::T.untyped)
  DATE_COMPONENTS = ::T.let(nil, ::T.untyped)
  DATE_MARKER = ::T.let(nil, ::T.untyped)
  DATE_TO_PART = ::T.let(nil, ::T.untyped)
  PERIOD = ::T.let(nil, ::T.untyped)
  PERIOD_OR_COMMA = ::T.let(nil, ::T.untyped)
  SIGN_MARKER = ::T.let(nil, ::T.untyped)
  TIME_COMPONENT = ::T.let(nil, ::T.untyped)
  TIME_COMPONENTS = ::T.let(nil, ::T.untyped)
  TIME_MARKER = ::T.let(nil, ::T.untyped)
  TIME_TO_PART = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::EncryptedFile
  CIPHER = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::ExecutionWrapper
  Null = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::JSON
  DATETIME_REGEX = ::T.let(nil, ::T.untyped)
  DATE_REGEX = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::LogSubscriber
  def colorize_logging(); end

  def colorize_logging=(obj); end

  def debug(progname=T.unsafe(nil), &block); end

  def error(progname=T.unsafe(nil), &block); end

  def fatal(progname=T.unsafe(nil), &block); end

  def info(progname=T.unsafe(nil), &block); end

  def logger(); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::MessageEncryptor
  include ::ActiveSupport::Messages::Rotator::Encryptor
  include ::ActiveSupport::Messages::Rotator
end

ActiveSupport::MessageEncryptor::OpenSSLCipherError = OpenSSL::Cipher::CipherError

class ActiveSupport::MessageVerifier
  include ::ActiveSupport::Messages::Rotator::Verifier
  include ::ActiveSupport::Messages::Rotator
end

module ActiveSupport::Multibyte::Unicode
  NORMALIZATION_FORMS = ::T.let(nil, ::T.untyped)
  NORMALIZATION_FORM_ALIASES = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberConverter
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter
  DEFAULT_DELIMITER_REGEX = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanConverter
  DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
  INVERTED_DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter
  STORAGE_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::ParameterFilter
  FILTERED = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::RangeWithFormat
  RANGE_FORMATS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::SafeBuffer
  UNSAFE_STRING_METHODS = ::T.let(nil, ::T.untyped)
  UNSAFE_STRING_METHODS_WITH_BACKREF = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Subscriber
  def finish(name, id, payload); end

  def patterns(); end

  def start(name, id, payload); end
end

class ActiveSupport::TestCase
  include ::Minitest::Parallel::Test
  include ::ActiveSupport::Testing::SetupAndTeardown
end

module ActiveSupport::Testing::Assertions
  UNTRACKED = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Testing::Isolation::Subprocess
  ORIG_ARGV = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Testing::Parallelization::Server
  include ::DRb::DRbUndumped
end

class ActiveSupport::TimeWithZone
  include ::DateAndTime::Compatibility
  PRECISIONS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::TimeZone
  MAPPING = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::XMLConverter
  DISALLOWED_TYPES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini
  DEFAULT_ENCODINGS = ::T.let(nil, ::T.untyped)
  FORMATTING = ::T.let(nil, ::T.untyped)
  PARSING = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini_REXML
  CONTENT_KEY = ::T.let(nil, ::T.untyped)
end

module Addressable::IDNA
  ACE_MAX_LENGTH = ::T.let(nil, ::T.untyped)
  ACE_PREFIX = ::T.let(nil, ::T.untyped)
  COMPOSITION_TABLE = ::T.let(nil, ::T.untyped)
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
  PUNYCODE_BASE = ::T.let(nil, ::T.untyped)
  PUNYCODE_DAMP = ::T.let(nil, ::T.untyped)
  PUNYCODE_DELIMITER = ::T.let(nil, ::T.untyped)
  PUNYCODE_INITIAL_BIAS = ::T.let(nil, ::T.untyped)
  PUNYCODE_INITIAL_N = ::T.let(nil, ::T.untyped)
  PUNYCODE_MAXINT = ::T.let(nil, ::T.untyped)
  PUNYCODE_PRINT_ASCII = ::T.let(nil, ::T.untyped)
  PUNYCODE_SKEW = ::T.let(nil, ::T.untyped)
  PUNYCODE_TMAX = ::T.let(nil, ::T.untyped)
  PUNYCODE_TMIN = ::T.let(nil, ::T.untyped)
  UNICODE_DATA = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_CANONICAL = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_COMBINING_CLASS = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_COMPATIBILITY = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_EXCLUSION = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_LOWERCASE = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_TITLECASE = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_UPPERCASE = ::T.let(nil, ::T.untyped)
  UNICODE_MAX_LENGTH = ::T.let(nil, ::T.untyped)
  UNICODE_TABLE = ::T.let(nil, ::T.untyped)
  UTF8_REGEX = ::T.let(nil, ::T.untyped)
  UTF8_REGEX_MULTIBYTE = ::T.let(nil, ::T.untyped)
end

class Addressable::Template
  EXPRESSION = ::T.let(nil, ::T.untyped)
  JOINERS = ::T.let(nil, ::T.untyped)
  LEADERS = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  VARIABLE_LIST = ::T.let(nil, ::T.untyped)
  VARNAME = ::T.let(nil, ::T.untyped)
  VARSPEC = ::T.let(nil, ::T.untyped)
end

class Addressable::URI
  EMPTY_STR = ::T.let(nil, ::T.untyped)
  NORMPATH = ::T.let(nil, ::T.untyped)
  PARENT = ::T.let(nil, ::T.untyped)
  PORT_MAPPING = ::T.let(nil, ::T.untyped)
  RULE_2A = ::T.let(nil, ::T.untyped)
  RULE_2B_2C = ::T.let(nil, ::T.untyped)
  RULE_2D = ::T.let(nil, ::T.untyped)
  RULE_PREFIXED_PARENT = ::T.let(nil, ::T.untyped)
  SELF_REF = ::T.let(nil, ::T.untyped)
  SEQUENCE_ENCODING_TABLE = ::T.let(nil, ::T.untyped)
  SEQUENCE_UPCASED_PERCENT_ENCODING_TABLE = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
  URIREGEX = ::T.let(nil, ::T.untyped)
end

module Addressable::URI::CharacterClasses
  ALPHA = ::T.let(nil, ::T.untyped)
  AUTHORITY = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  GEN_DELIMS = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  PCHAR = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  SUB_DELIMS = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
end

module Addressable::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

class ApplicationRecord
  include ::ApplicationRecord::GeneratedAttributeMethods
  include ::ApplicationRecord::GeneratedAssociationMethods
end

class ApplicationRecord::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ApplicationRecord::GeneratedRelationMethods
end

class ApplicationRecord::ActiveRecord_AssociationRelation
end

class ApplicationRecord::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ApplicationRecord::GeneratedRelationMethods
end

class ApplicationRecord::ActiveRecord_Associations_CollectionProxy
end

class ApplicationRecord::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::ApplicationRecord::GeneratedRelationMethods
end

class ApplicationRecord::ActiveRecord_Relation
end

module ApplicationRecord::GeneratedAssociationMethods
end

module ApplicationRecord::GeneratedAssociationMethods
end

module ApplicationRecord::GeneratedAttributeMethods
end

module ApplicationRecord::GeneratedAttributeMethods
  extend ::Mutex_m
end

module ApplicationRecord::GeneratedRelationMethods
end

module ApplicationRecord::GeneratedRelationMethods
  extend ::Mutex_m
end

module Arel
  VERSION = ::T.let(nil, ::T.untyped)
end

Arel::Attribute = Arel::Attributes::Attribute

Arel::Node = Arel::Nodes::Node

class Arel::SelectManager
  STRING_OR_SYMBOL_CLASS = ::T.let(nil, ::T.untyped)
end

class Arel::Visitors::DepthFirst
  DISPATCH = ::T.let(nil, ::T.untyped)
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def bsearch(); end

  def bsearch_index(); end

  def collect!(); end

  def dig(*_); end

  def flatten!(*_); end

  def pack(*_); end

  def place(*values); end

  def replace(_); end

  def replace_each_string(&block); end

  def shelljoin(); end

  def to_csv(**options); end

  def to_h(); end

end

class Array
  def self.try_convert(_); end
end

module BCrypt
end

class BCrypt::Engine
  DEFAULT_COST = ::T.let(nil, ::T.untyped)
  MAX_SALT_LENGTH = ::T.let(nil, ::T.untyped)
  MIN_COST = ::T.let(nil, ::T.untyped)
end

class BCrypt::Engine
  def self.autodetect_cost(salt); end

  def self.calibrate(upper_time_limit_in_ms); end

  def self.cost(); end

  def self.cost=(cost); end

  def self.generate_salt(cost=T.unsafe(nil)); end

  def self.hash_secret(secret, salt, _=T.unsafe(nil)); end

  def self.valid_salt?(salt); end

  def self.valid_secret?(secret); end
end

class BCrypt::Error
end

class BCrypt::Error
end

module BCrypt::Errors
end

class BCrypt::Errors::InvalidCost
end

class BCrypt::Errors::InvalidCost
end

class BCrypt::Errors::InvalidHash
end

class BCrypt::Errors::InvalidHash
end

class BCrypt::Errors::InvalidSalt
end

class BCrypt::Errors::InvalidSalt
end

class BCrypt::Errors::InvalidSecret
end

class BCrypt::Errors::InvalidSecret
end

module BCrypt::Errors
end

class BCrypt::Password
  def ==(secret); end

  def checksum(); end

  def cost(); end

  def initialize(raw_hash); end

  def is_password?(secret); end

  def salt(); end

  def version(); end
end

class BCrypt::Password
  def self.create(secret, options=T.unsafe(nil)); end

  def self.valid_hash?(h); end
end

module BCrypt
end

module Babel::Source
  DATE = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Babel::Transpiler
  VERSION = ::T.let(nil, ::T.untyped)
end

module Backport
  VERSION = ::T.let(nil, ::T.untyped)
end

class Backport::Adapter
  def close(); end

  def closed?(); end

  def closing(); end

  def initialize(output, remote=T.unsafe(nil)); end

  def opening(); end

  def receiving(data); end

  def remote(); end

  def write(data); end

  def write_line(data); end
end

class Backport::Adapter
end

class Backport::Client
  include ::Observable
  def adapter(); end

  def initialize(input, output, adapter, remote=T.unsafe(nil)); end

  def run(); end

  def start(); end

  def stop(); end

  def stopped?(); end

  def tick(); end
end

class Backport::Client
end

class Backport::Machine
  def prepare(server); end

  def run(); end

  def servers(); end

  def stop(); end

  def stopped?(); end

  def update(server); end
end

class Backport::Machine
end

module Backport::Server
end

class Backport::Server::Base
  include ::Observable
  def start(); end

  def started?(); end

  def starting(); end

  def stop(); end

  def stopped?(); end

  def stopping(); end

  def tick(); end
end

class Backport::Server::Base
end

module Backport::Server::Connectable
  def clients(); end

  def starting(); end

  def stopping(); end
end

module Backport::Server::Connectable
end

class Backport::Server::Interval
  def initialize(period, &block); end
end

class Backport::Server::Interval
end

class Backport::Server::Stdio
  include ::Backport::Server::Connectable
  def initialize(input: T.unsafe(nil), output: T.unsafe(nil), adapter: T.unsafe(nil)); end

  def update(client); end
end

class Backport::Server::Stdio
end

class Backport::Server::Tcpip
  include ::Backport::Server::Connectable
  def accept(); end

  def initialize(host: T.unsafe(nil), port: T.unsafe(nil), adapter: T.unsafe(nil), socket_class: T.unsafe(nil)); end

  def update(client); end
end

class Backport::Server::Tcpip
end

module Backport::Server
end

module Backport
  def self.logger(); end

  def self.prepare_interval(period, &block); end

  def self.prepare_stdio_server(adapter: T.unsafe(nil)); end

  def self.prepare_tcp_server(host: T.unsafe(nil), port: T.unsafe(nil), adapter: T.unsafe(nil)); end

  def self.run(&block); end

  def self.stop(); end
end

BasicObject::BasicObject = BasicObject

class Benchmark::Job
  def initialize(width); end
end

class Benchmark::Report
  def initialize(width=T.unsafe(nil), format=T.unsafe(nil)); end
end

class Benchmark::Tms
  def *(x); end

  def +(other); end

  def -(other); end

  def /(x); end

  def add(&blk); end

  def add!(&blk); end

  def cstime(); end

  def cutime(); end

  def format(format=T.unsafe(nil), *args); end

  def initialize(utime=T.unsafe(nil), stime=T.unsafe(nil), cutime=T.unsafe(nil), cstime=T.unsafe(nil), real=T.unsafe(nil), label=T.unsafe(nil)); end

  def label(); end

  def memberwise(op, x); end

  def real(); end

  def stime(); end

  def to_a(); end

  def total(); end

  def utime(); end
end

class BigDecimal
  include ::ActiveSupport::BigDecimalWithDefaultFormat
  include ::ActiveSupport::NumericWithFormat
  def clone(); end

  def to_d(); end

  def to_digits(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.new(*args, **kwargs); end
end

Bindex = Skiptrace

class Binding
  def clone(); end

  def irb(); end
end

module Bootsnap
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bootsnap::CompileCache::Uncompilable
end

class Bootsnap::CompileCache::Uncompilable
end

module Bootsnap::ExplicitRequire
  ARCHDIR = ::T.let(nil, ::T.untyped)
  DLEXT = ::T.let(nil, ::T.untyped)
  RUBYLIBDIR = ::T.let(nil, ::T.untyped)
end

module Bootsnap::LoadPathCache
  CACHED_EXTENSIONS = ::T.let(nil, ::T.untyped)
  DLEXT = ::T.let(nil, ::T.untyped)
  DLEXT2 = ::T.let(nil, ::T.untyped)
  DL_EXTENSIONS = ::T.let(nil, ::T.untyped)
  DOT_RB = ::T.let(nil, ::T.untyped)
  DOT_SO = ::T.let(nil, ::T.untyped)
  ERROR_TAG_IVAR = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
end

class Bootsnap::LoadPathCache::Cache
  AGE_THRESHOLD = ::T.let(nil, ::T.untyped)
  BUILTIN_FEATURES = ::T.let(nil, ::T.untyped)
end

class Bootsnap::LoadPathCache::Path
  RUBY_LIBDIR = ::T.let(nil, ::T.untyped)
  RUBY_SITEDIR = ::T.let(nil, ::T.untyped)
  STABLE = ::T.let(nil, ::T.untyped)
  VOLATILE = ::T.let(nil, ::T.untyped)
end

module Bootsnap::LoadPathCache::PathScanner
  ALL_FILES = ::T.let(nil, ::T.untyped)
  ALTERNATIVE_NATIVE_EXTENSIONS_PATTERN = ::T.let(nil, ::T.untyped)
  BUNDLE_PATH = ::T.let(nil, ::T.untyped)
  NORMALIZE_NATIVE_EXTENSIONS = ::T.let(nil, ::T.untyped)
  REQUIRABLE_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class Bundler::Dependency
  def branch(); end

  def expanded_platforms(); end

  def git(); end
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end
end

class Bundler::GemHelper
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_command(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_input(cmd); end

  def sh_with_status(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::Molinillo::DependencyGraph
  include ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Vertex
  def _recursive_predecessors(vertices=T.unsafe(nil)); end

  def _recursive_successors(vertices=T.unsafe(nil)); end
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index
  def installed_plugins(); end

  def plugin_commands(plugin); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  def self.list(); end
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubygemsIntegration
  def add_to_load_path(paths); end

  def all_specs(); end

  def backport_ext_builder_monitor(); end

  def correct_for_windows_path(path); end

  def default_stubs(); end

  def find_name(name); end

  def gem_remote_fetcher(); end

  def plain_specs(); end

  def plain_specs=(specs); end

  def stub_rubygems(specs); end

  def use_gemdeps(gemfile); end
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::Source::Git
  def glob(); end
end

class Bundler::SpecSet
  include ::Enumerable
end

class Bundler::Thor
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  Correctable = ::T.let(nil, ::T.untyped)
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Actions::CapturableERB
end

class Bundler::Thor::Actions::CapturableERB
end

module Bundler::Thor::Actions::ClassMethods
  def add_runtime_options!(); end

  def source_paths(); end

  def source_paths_for_search(); end

  def source_root(path=T.unsafe(nil)); end
end

module Bundler::Thor::Actions::ClassMethods
end

class Bundler::Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Bundler::Thor::Actions::CreateFile
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::Directory
  def execute!(); end

  def file_level_lookup(previous_lookup); end

  def files(lookup); end

  def initialize(base, source, destination=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def source(); end
end

class Bundler::Thor::Actions::Directory
end

class Bundler::Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Bundler::Thor::Actions::EmptyDirectory
end

class Bundler::Thor::Actions::InjectIntoFile
  def behavior(); end

  def flag(); end

  def initialize(base, destination, data, config); end

  def replace!(regexp, string, force); end

  def replacement(); end

  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

class Bundler::Thor::Actions::InjectIntoFile
end

module Bundler::Thor::Actions
  def self.included(base); end
end

class Bundler::Thor::AmbiguousCommandError
end

class Bundler::Thor::AmbiguousCommandError
end

Bundler::Thor::AmbiguousTaskError = Bundler::Thor::AmbiguousCommandError

class Bundler::Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Argument
end

class Bundler::Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

module Bundler::Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Bundler::Thor::Base::ClassMethods
  def all_commands(); end

  def all_tasks(); end

  def allow_incompatible_default_type!(); end

  def argument(name, options=T.unsafe(nil)); end

  def arguments(); end

  def attr_accessor(*_); end

  def attr_reader(*_); end

  def attr_writer(*_); end

  def baseclass(); end

  def basename(); end

  def build_option(name, options, scope); end

  def build_options(options, scope); end

  def check_default_type(); end

  def check_default_type!(); end

  def check_unknown_options(); end

  def check_unknown_options!(); end

  def check_unknown_options?(config); end

  def class_option(name, options=T.unsafe(nil)); end

  def class_options(options=T.unsafe(nil)); end

  def class_options_help(shell, groups=T.unsafe(nil)); end

  def commands(); end

  def create_command(meth); end

  def create_task(meth); end

  def disable_required_check?(command_name); end

  def dispatch(command, given_args, given_opts, config); end

  def exit_on_failure?(); end

  def find_and_refresh_command(name); end

  def find_and_refresh_task(name); end

  def from_superclass(method, default=T.unsafe(nil)); end

  def group(name=T.unsafe(nil)); end

  def handle_argument_error(command, error, args, arity); end

  def handle_no_command_error(command, has_namespace=T.unsafe(nil)); end

  def handle_no_task_error(command, has_namespace=T.unsafe(nil)); end

  def inherited(klass); end

  def initialize_added(); end

  def is_thor_reserved_word?(word, type); end

  def method_added(meth); end

  def namespace(name=T.unsafe(nil)); end

  def no_commands(&block); end

  def no_commands?(); end

  def no_commands_context(); end

  def no_tasks(&block); end

  def print_options(shell, options, group_name=T.unsafe(nil)); end

  def public_command(*names); end

  def public_task(*names); end

  def remove_argument(*names); end

  def remove_class_option(*names); end

  def remove_command(*names); end

  def remove_task(*names); end

  def start(given_args=T.unsafe(nil), config=T.unsafe(nil)); end

  def stop_on_unknown_option?(command_name); end

  def strict_args_position(); end

  def strict_args_position!(); end

  def strict_args_position?(config); end

  def tasks(); end
end

module Bundler::Thor::Base::ClassMethods
end

module Bundler::Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Bundler::Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, usage, options=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Command
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def values_at(*indices); end
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Bundler::Thor::DynamicCommand
end

Bundler::Thor::DynamicTask = Bundler::Thor::DynamicCommand

class Bundler::Thor::Error
end

class Bundler::Thor::Error
end

class Bundler::Thor::Group
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Bundler::Thor::Group
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*_); end

  def self.printable_tasks(*_); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Bundler::Thor::HiddenCommand
end

class Bundler::Thor::HiddenCommand
end

Bundler::Thor::HiddenTask = Bundler::Thor::HiddenCommand

module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Bundler::Thor::Invocation::ClassMethods
  def prepare_for_invocation(key, name); end
end

module Bundler::Thor::Invocation::ClassMethods
end

module Bundler::Thor::Invocation
  def self.included(base); end
end

class Bundler::Thor::InvocationError
end

class Bundler::Thor::InvocationError
end

module Bundler::Thor::LineEditor
end

class Bundler::Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Bundler::Thor::LineEditor::Basic
  def self.available?(); end
end

class Bundler::Thor::LineEditor::Readline
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
end

class Bundler::Thor::LineEditor::Readline
end

module Bundler::Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Bundler::Thor::NestedContext
end

class Bundler::Thor::Option
  def aliases(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Option
  def self.parse(key, value); end
end

class Bundler::Thor::Options
  def assign_result!(option, result); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Options
  def self.to_switches(options); end
end

module Bundler::Thor::RakeCompat
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Bundler::Thor::RakeCompat
  def self.included(base); end

  def self.rake_classes(); end
end

class Bundler::Thor::RequiredArgumentMissingError
end

class Bundler::Thor::RequiredArgumentMissingError
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
  def answer_match(possibilities, answer, case_insensitive); end

  def as_unicode(); end

  def ask(statement, *args); end

  def ask_filtered(statement, color, options); end

  def ask_simply(statement, color, options); end

  def base(); end

  def base=(base); end

  def can_display_colors?(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def error(statement); end

  def file_collision(destination); end

  def file_collision_help(); end

  def git_merge_tool(); end

  def indent(count=T.unsafe(nil)); end

  def is?(value); end

  def lookup_color(color); end

  def merge(destination, content); end

  def merge_tool(); end

  def mute(); end

  def mute?(); end

  def no?(statement, color=T.unsafe(nil)); end

  def padding(); end

  def padding=(value); end

  def prepare_message(message, *color); end

  def print_in_columns(array); end

  def print_table(array, options=T.unsafe(nil)); end

  def print_wrapped(message, options=T.unsafe(nil)); end

  def quiet?(); end

  def say(message=T.unsafe(nil), color=T.unsafe(nil), force_new_line=T.unsafe(nil)); end

  def say_status(status, message, log_status=T.unsafe(nil)); end

  def set_color(string, *_); end

  def show_diff(destination, content); end

  def stderr(); end

  def stdout(); end

  def terminal_width(); end

  def truncate(string, width); end

  def unix?(); end

  def yes?(statement, color=T.unsafe(nil)); end
  DEFAULT_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
end

class Bundler::Thor::Shell::Color
  def are_colors_disabled?(); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Color
end

class Bundler::Thor::Shell::HTML
  def ask(statement, color=T.unsafe(nil)); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::HTML
end

module Bundler::Thor::Shell
end

Bundler::Thor::Task = Bundler::Thor::Command

class Bundler::Thor::UndefinedCommandError
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
end

class Bundler::Thor::UndefinedCommandError
end

Bundler::Thor::UndefinedTaskError = Bundler::Thor::UndefinedCommandError

class Bundler::Thor::UnknownArgumentError
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
end

class Bundler::Thor::UnknownArgumentError
end

module Bundler::Thor::Util
end

module Bundler::Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Bundler::Thor
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ABS_URI_REF = ::T.let(nil, ::T.untyped)
  DEFAULT_PARSER = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  OPAQUE = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  REL_URI_REF = ::T.let(nil, ::T.untyped)
  RFC3986_PARSER = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TBLDECWWWCOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCWWWCOMP_ = ::T.let(nil, ::T.untyped)
  UNSAFE = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_CODE = ::T.let(nil, ::T.untyped)
  WEB_ENCODINGS_ = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::BadURIError
end

class Bundler::URI::BadURIError
end

class Bundler::URI::Error
end

class Bundler::URI::Error
end

module Bundler::URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

module Bundler::URI::Escape
end

class Bundler::URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  TYPECODE = ::T.let(nil, ::T.untyped)
  TYPECODE_PREFIX = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class Bundler::URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::File
end

class Bundler::URI::Generic
  include ::Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  USE_REGISTRY = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::Generic
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class Bundler::URI::HTTP
  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTP
end

class Bundler::URI::HTTPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTPS
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  SCOPE = ::T.let(nil, ::T.untyped)
  SCOPE_BASE = ::T.let(nil, ::T.untyped)
  SCOPE_ONE = ::T.let(nil, ::T.untyped)
  SCOPE_SUB = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAP
end

class Bundler::URI::LDAPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAPS
end

class Bundler::URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EMAIL_REGEXP = ::T.let(nil, ::T.untyped)
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::MailTo
end

Bundler::URI::Parser = Bundler::URI::RFC2396_Parser

Bundler::URI::REGEXP = Bundler::URI::RFC2396_REGEXP

class Bundler::URI::RFC2396_Parser
  include ::Bundler::URI::RFC2396_REGEXP
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class Bundler::URI::RFC2396_Parser
end

module Bundler::URI::RFC2396_REGEXP
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ALNUM = ::T.let(nil, ::T.untyped)
  ALPHA = ::T.let(nil, ::T.untyped)
  DOMLABEL = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HEX = ::T.let(nil, ::T.untyped)
  HIER_PART = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  HOSTNAME = ::T.let(nil, ::T.untyped)
  HOSTPORT = ::T.let(nil, ::T.untyped)
  IPV4ADDR = ::T.let(nil, ::T.untyped)
  IPV6ADDR = ::T.let(nil, ::T.untyped)
  IPV6REF = ::T.let(nil, ::T.untyped)
  NET_PATH = ::T.let(nil, ::T.untyped)
  OPAQUE_PART = ::T.let(nil, ::T.untyped)
  PATH_SEGMENTS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REG_NAME = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_SEGMENT = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TOPLABEL = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  URIC = ::T.let(nil, ::T.untyped)
  URIC_NO_SLASH = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  X_ABS_URI = ::T.let(nil, ::T.untyped)
  X_REL_URI = ::T.let(nil, ::T.untyped)
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
end

module Bundler::URI::RFC2396_REGEXP
end

class Bundler::URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_URI = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::RFC3986_Parser
end

module Bundler::URI::Util
end

module Bundler::URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module Bundler::URI
  extend ::Bundler::URI::Escape
  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.decode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.extract(str, schemes=T.unsafe(nil), &block); end

  def self.get_encoding(label); end

  def self.join(*str); end

  def self.parse(uri); end

  def self.regexp(schemes=T.unsafe(nil)); end

  def self.scheme_list(); end

  def self.split(uri); end
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Bundler
  def self.original_exec(*args); end

  def self.original_system(*args); end

  def self.unbundled_env(); end

  def self.unbundled_exec(*args); end

  def self.unbundled_system(*args); end

  def self.with_unbundled_env(); end
end

module Byebug
  PORT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoirbSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutolistSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoprySetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutosaveSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::CallstyleSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::Command
  extend ::Byebug::Helpers::StringHelper
end

class Byebug::Context
  extend ::Byebug::Helpers::PathHelper
end

class Byebug::FullpathSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistfileSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistsizeSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::ListsizeSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::LocalInterface
  EOF_ALIAS = ::T.let(nil, ::T.untyped)
end

class Byebug::Printers::Base
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Byebug::SavefileSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::Setting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::ThreadsTable
end

class Byebug::ThreadsTable
end

class Byebug::WidthSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

module Capybara
  VERSION = ::T.let(nil, ::T.untyped)
end

class Capybara::Config
  OPTIONS = ::T.let(nil, ::T.untyped)
end

module Capybara::DSL
  def accept_alert(*args, &block); end

  def accept_confirm(*args, &block); end

  def accept_prompt(*args, &block); end

  def all(*args, &block); end

  def assert_all_of_selectors(*args, &block); end

  def assert_any_of_selectors(*args, &block); end

  def assert_current_path(*args, &block); end

  def assert_no_current_path(*args, &block); end

  def assert_no_selector(*args, &block); end

  def assert_no_text(*args, &block); end

  def assert_no_title(*args, &block); end

  def assert_none_of_selectors(*args, &block); end

  def assert_selector(*args, &block); end

  def assert_text(*args, &block); end

  def assert_title(*args, &block); end

  def attach_file(*args, &block); end

  def body(*args, &block); end

  def check(*args, &block); end

  def choose(*args, &block); end

  def click_button(*args, &block); end

  def click_link(*args, &block); end

  def click_link_or_button(*args, &block); end

  def click_on(*args, &block); end

  def current_host(*args, &block); end

  def current_path(*args, &block); end

  def current_scope(*args, &block); end

  def current_url(*args, &block); end

  def current_window(*args, &block); end

  def dismiss_confirm(*args, &block); end

  def dismiss_prompt(*args, &block); end

  def evaluate_script(*args, &block); end

  def execute_script(*args, &block); end

  def fill_in(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_button(*args, &block); end

  def find_by_id(*args, &block); end

  def find_field(*args, &block); end

  def find_link(*args, &block); end

  def first(*args, &block); end

  def go_back(*args, &block); end

  def go_forward(*args, &block); end

  def has_button?(*args, &block); end

  def has_checked_field?(*args, &block); end

  def has_content?(*args, &block); end

  def has_css?(*args, &block); end

  def has_current_path?(*args, &block); end

  def has_field?(*args, &block); end

  def has_link?(*args, &block); end

  def has_no_button?(*args, &block); end

  def has_no_checked_field?(*args, &block); end

  def has_no_content?(*args, &block); end

  def has_no_css?(*args, &block); end

  def has_no_current_path?(*args, &block); end

  def has_no_field?(*args, &block); end

  def has_no_link?(*args, &block); end

  def has_no_select?(*args, &block); end

  def has_no_selector?(*args, &block); end

  def has_no_table?(*args, &block); end

  def has_no_text?(*args, &block); end

  def has_no_title?(*args, &block); end

  def has_no_unchecked_field?(*args, &block); end

  def has_no_xpath?(*args, &block); end

  def has_select?(*args, &block); end

  def has_selector?(*args, &block); end

  def has_table?(*args, &block); end

  def has_text?(*args, &block); end

  def has_title?(*args, &block); end

  def has_unchecked_field?(*args, &block); end

  def has_xpath?(*args, &block); end

  def html(*args, &block); end

  def open_new_window(*args, &block); end

  def page(); end

  def query(*args, &block); end

  def refresh(*args, &block); end

  def refute_selector(*args, &block); end

  def reset_session!(*args, &block); end

  def response_headers(*args, &block); end

  def save_and_open_page(*args, &block); end

  def save_and_open_screenshot(*args, &block); end

  def save_page(*args, &block); end

  def save_screenshot(*args, &block); end

  def scroll_by(*args, &block); end

  def scroll_to(*args, &block); end

  def select(*args, &block); end

  def source(*args, &block); end

  def status_code(*args, &block); end

  def switch_to_frame(*args, &block); end

  def switch_to_window(*args, &block); end

  def text(*args, &block); end

  def title(*args, &block); end

  def uncheck(*args, &block); end

  def unselect(*args, &block); end

  def using_session(name_or_session, &block); end

  def using_wait_time(seconds, &block); end

  def visit(*args, &block); end

  def window_opened_by(*args, &block); end

  def windows(*args, &block); end

  def within(*args, &block); end

  def within_element(*args, &block); end

  def within_fieldset(*args, &block); end

  def within_frame(*args, &block); end

  def within_table(*args, &block); end

  def within_window(*args, &block); end
end

module Capybara::DSL
  def self.extended(base); end

  def self.included(base); end
end

module Capybara::Minitest
end

module Capybara::Minitest::Assertions
  def assert_all_of_selectors(*args, &optional_filter_block); end

  def assert_ancestor(*args, &optional_filter_block); end

  def assert_any_of_selectors(*args, &optional_filter_block); end

  def assert_button(*args, &optional_filter_block); end

  def assert_checked_field(*args, &optional_filter_block); end

  def assert_content(*args); end

  def assert_css(*args, &optional_filter_block); end

  def assert_current_path(*args); end

  def assert_field(*args, &optional_filter_block); end

  def assert_link(*args, &optional_filter_block); end

  def assert_matches_css(*args, &optional_filter_block); end

  def assert_matches_selector(*args, &optional_filter_block); end

  def assert_matches_style(*args, &optional_filter_block); end

  def assert_matches_xpath(*args, &optional_filter_block); end

  def assert_no_ancestor(*args, &optional_filter_block); end

  def assert_no_button(*args, &optional_filter_block); end

  def assert_no_checked_field(*args, &optional_filter_block); end

  def assert_no_content(*args); end

  def assert_no_css(*args, &optional_filter_block); end

  def assert_no_current_path(*args); end

  def assert_no_field(*args, &optional_filter_block); end

  def assert_no_link(*args, &optional_filter_block); end

  def assert_no_select(*args, &optional_filter_block); end

  def assert_no_selector(*args, &optional_filter_block); end

  def assert_no_sibling(*args, &optional_filter_block); end

  def assert_no_table(*args, &optional_filter_block); end

  def assert_no_text(*args); end

  def assert_no_title(*args); end

  def assert_no_unchecked_field(*args, &optional_filter_block); end

  def assert_no_xpath(*args, &optional_filter_block); end

  def assert_none_of_selectors(*args, &optional_filter_block); end

  def assert_not_matches_css(*args, &optional_filter_block); end

  def assert_not_matches_selector(*args, &optional_filter_block); end

  def assert_not_matches_xpath(*args, &optional_filter_block); end

  def assert_select(*args, &optional_filter_block); end

  def assert_selector(*args, &optional_filter_block); end

  def assert_sibling(*args, &optional_filter_block); end

  def assert_table(*args, &optional_filter_block); end

  def assert_text(*args); end

  def assert_title(*args); end

  def assert_unchecked_field(*args, &optional_filter_block); end

  def assert_xpath(*args, &optional_filter_block); end

  def refute_ancestor(*args, &optional_filter_block); end

  def refute_button(*args, &optional_filter_block); end

  def refute_checked_field(*args, &optional_filter_block); end

  def refute_content(*args); end

  def refute_css(*args, &optional_filter_block); end

  def refute_current_path(*args); end

  def refute_field(*args, &optional_filter_block); end

  def refute_link(*args, &optional_filter_block); end

  def refute_matches_css(*args, &optional_filter_block); end

  def refute_matches_selector(*args, &optional_filter_block); end

  def refute_matches_xpath(*args, &optional_filter_block); end

  def refute_select(*args, &optional_filter_block); end

  def refute_selector(*args, &optional_filter_block); end

  def refute_sibling(*args, &optional_filter_block); end

  def refute_table(*args, &optional_filter_block); end

  def refute_text(*args); end

  def refute_title(*args); end

  def refute_unchecked_field(*args, &optional_filter_block); end

  def refute_xpath(*args, &optional_filter_block); end
end

module Capybara::Minitest::Assertions
end

module Capybara::Minitest
end

module Capybara::Node::Actions
  CAPTURE_FILE_ELEMENT_SCRIPT = ::T.let(nil, ::T.untyped)
  DATALIST_OPTIONS_SCRIPT = ::T.let(nil, ::T.untyped)
  RESET_STYLE_SCRIPT = ::T.let(nil, ::T.untyped)
  UPDATE_STYLE_SCRIPT = ::T.let(nil, ::T.untyped)
end

class Capybara::Node::Element
  STYLE_SCRIPT = ::T.let(nil, ::T.untyped)
end

class Capybara::Node::Simple
  VISIBILITY_XPATH = ::T.let(nil, ::T.untyped)
end

class Capybara::Queries::BaseQuery
  COUNT_KEYS = ::T.let(nil, ::T.untyped)
end

class Capybara::Queries::SelectorQuery
  SPATIAL_KEYS = ::T.let(nil, ::T.untyped)
  VALID_KEYS = ::T.let(nil, ::T.untyped)
  VALID_MATCH = ::T.let(nil, ::T.untyped)
end

class Capybara::RackTest::Driver
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Capybara::RackTest::Node
  BLOCK_ELEMENTS = ::T.let(nil, ::T.untyped)
  DISABLED_BY_FIELDSET_XPATH = ::T.let(nil, ::T.untyped)
  OPTION_OWNER_XPATH = ::T.let(nil, ::T.untyped)
end

class Capybara::Selector::CSS
  ESCAPE = ::T.let(nil, ::T.untyped)
  H = ::T.let(nil, ::T.untyped)
  NMSTART = ::T.let(nil, ::T.untyped)
  NONASCII = ::T.let(nil, ::T.untyped)
  S = ::T.let(nil, ::T.untyped)
  UNICODE = ::T.let(nil, ::T.untyped)
end

module Capybara::Selenium::ChromeLogs
  COMMANDS = ::T.let(nil, ::T.untyped)
  LOG_MSG = ::T.let(nil, ::T.untyped)
end

class Capybara::Selenium::Driver
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  SPECIAL_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Capybara::Selenium::Node
  GET_XPATH_SCRIPT = ::T.let(nil, ::T.untyped)
  OBSCURED_OR_OFFSET_SCRIPT = ::T.let(nil, ::T.untyped)
  RAPID_SET_TEXT = ::T.let(nil, ::T.untyped)
end

module Capybara::Selenium::Node::Html5Drag
  ATTACH_FILE = ::T.let(nil, ::T.untyped)
  DROP_FILE = ::T.let(nil, ::T.untyped)
  DROP_STRING = ::T.let(nil, ::T.untyped)
  HTML5_DRAG_DROP_SCRIPT = ::T.let(nil, ::T.untyped)
  LEGACY_DRAG_CHECK = ::T.let(nil, ::T.untyped)
  MOUSEDOWN_TRACKER = ::T.let(nil, ::T.untyped)
end

class Capybara::Selenium::SafariNode
  MODIFIER_KEYS = ::T.let(nil, ::T.untyped)
end

class Capybara::Server::AnimationDisabler
  DISABLE_MARKUP_TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Capybara::Server::Checker
  TRY_HTTPS_ERRORS = ::T.let(nil, ::T.untyped)
end

class Capybara::Session
  DOCUMENT_METHODS = ::T.let(nil, ::T.untyped)
  DSL_METHODS = ::T.let(nil, ::T.untyped)
  MODAL_METHODS = ::T.let(nil, ::T.untyped)
  NODE_METHODS = ::T.let(nil, ::T.untyped)
  SESSION_METHODS = ::T.let(nil, ::T.untyped)
end

class Capybara::SessionConfig
  OPTIONS = ::T.let(nil, ::T.untyped)
end

module Capybara
  extend ::Capybara::DSL
end

module ChildProcess
  VERSION = ::T.let(nil, ::T.untyped)
end

class ChildProcess::AbstractProcess
  POLL_INTERVAL = ::T.let(nil, ::T.untyped)
end

class Class
  def json_creatable?(); end
end

class Complex
  def self.polar(*_); end

  def self.rect(*_); end

  def self.rectangular(*_); end
end

module Concurrent
  NULL = ::T.let(nil, ::T.untyped)
  NULL_LOGGER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExecutorService
  FALLBACK_POLICIES = ::T.let(nil, ::T.untyped)
end

Concurrent::Collection::MapImplementation = Concurrent::Collection::MriMapBackend

class Concurrent::ConcurrentUpdateError
  CONC_UP_ERR_BACKTRACE = ::T.let(nil, ::T.untyped)
end

class Concurrent::LockFreeStack
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Concurrent::MVar
  EMPTY = ::T.let(nil, ::T.untyped)
  TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::Maybe
  NONE = ::T.let(nil, ::T.untyped)
end

module Concurrent::Promises::InternalStates
  PENDING = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  RESOLVED = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReadWriteLock
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReentrantReadWriteLock
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  READER_BITS = ::T.let(nil, ::T.untyped)
  READ_LOCK_MASK = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
  WRITER_BITS = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_HELD = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_MASK = ::T.let(nil, ::T.untyped)
end

class Concurrent::RubyThreadPoolExecutor
  DEFAULT_MAX_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_QUEUE_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MIN_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_THREAD_IDLETIMEOUT = ::T.let(nil, ::T.untyped)
end

Concurrent::Synchronization::Volatile = Concurrent::Synchronization::MriAttrVolatile

module Concurrent::ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

class Concurrent::TimerTask
  EXECUTION_INTERVAL = ::T.let(nil, ::T.untyped)
  TIMEOUT_INTERVAL = ::T.let(nil, ::T.untyped)
end

class Concurrent::Transaction
  ABORTED = ::T.let(nil, ::T.untyped)
end

module Concurrent::Utility::NativeInteger
  MAX_VALUE = ::T.let(nil, ::T.untyped)
  MIN_VALUE = ::T.let(nil, ::T.untyped)
end

class ConnectionPool
  DEFAULTS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class ConnectionPool::Wrapper
  METHODS = ::T.let(nil, ::T.untyped)
end

class Crass::Parser
  BLOCK_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Crass::Tokenizer
  RE_COMMENT_CLOSE = ::T.let(nil, ::T.untyped)
  RE_DIGIT = ::T.let(nil, ::T.untyped)
  RE_ESCAPE = ::T.let(nil, ::T.untyped)
  RE_HEX = ::T.let(nil, ::T.untyped)
  RE_NAME = ::T.let(nil, ::T.untyped)
  RE_NAME_START = ::T.let(nil, ::T.untyped)
  RE_NON_PRINTABLE = ::T.let(nil, ::T.untyped)
  RE_NUMBER_DECIMAL = ::T.let(nil, ::T.untyped)
  RE_NUMBER_EXPONENT = ::T.let(nil, ::T.untyped)
  RE_NUMBER_SIGN = ::T.let(nil, ::T.untyped)
  RE_NUMBER_STR = ::T.let(nil, ::T.untyped)
  RE_QUOTED_URL_START = ::T.let(nil, ::T.untyped)
  RE_UNICODE_RANGE_END = ::T.let(nil, ::T.untyped)
  RE_UNICODE_RANGE_START = ::T.let(nil, ::T.untyped)
  RE_WHITESPACE = ::T.let(nil, ::T.untyped)
  RE_WHITESPACE_ANCHORED = ::T.let(nil, ::T.untyped)
end

module DRb
end

class DRb::DRbArray
  def _dump(lv); end

  def initialize(ary); end
end

class DRb::DRbArray
  def self._load(s); end
end

class DRb::DRbBadScheme
end

class DRb::DRbBadScheme
end

class DRb::DRbBadURI
end

class DRb::DRbBadURI
end

class DRb::DRbConn
  def alive?(); end

  def close(); end

  def initialize(remote_uri); end

  def send_message(ref, msg_id, arg, block); end

  def uri(); end
  POOL_SIZE = ::T.let(nil, ::T.untyped)
end

class DRb::DRbConn
  def self.open(remote_uri); end
end

class DRb::DRbConnError
end

class DRb::DRbConnError
end

class DRb::DRbError
end

class DRb::DRbError
end

class DRb::DRbIdConv
  def to_id(obj); end

  def to_obj(ref); end
end

class DRb::DRbIdConv
end

class DRb::DRbMessage
  def dump(obj, error=T.unsafe(nil)); end

  def initialize(config); end

  def load(soc); end

  def recv_reply(stream); end

  def recv_request(stream); end

  def send_reply(stream, succ, result); end

  def send_request(stream, ref, msg_id, arg, b); end
end

class DRb::DRbMessage
end

class DRb::DRbObject
  def ==(other); end

  def __drbref(); end

  def __drburi(); end

  def _dump(lv); end

  def eql?(other); end

  def initialize(obj, uri=T.unsafe(nil)); end

  def method_missing(msg_id, *a, &b); end

  def respond_to?(msg_id, priv=T.unsafe(nil)); end
end

class DRb::DRbObject
  def self._load(s); end

  def self.new_with(uri, ref); end

  def self.new_with_uri(uri); end

  def self.prepare_backtrace(uri, result); end

  def self.with_friend(uri); end
end

module DRb::DRbProtocol
end

module DRb::DRbProtocol
  def self.add_protocol(prot); end

  def self.auto_load(uri); end

  def self.open(uri, config, first=T.unsafe(nil)); end

  def self.open_server(uri, config, first=T.unsafe(nil)); end

  def self.uri_option(uri, config, first=T.unsafe(nil)); end
end

class DRb::DRbRemoteError
  def initialize(error); end

  def reason(); end
end

class DRb::DRbRemoteError
end

class DRb::DRbServer
  def alive?(); end

  def check_insecure_method(obj, msg_id); end

  def config(); end

  def front(); end

  def here?(uri); end

  def initialize(uri=T.unsafe(nil), front=T.unsafe(nil), config_or_acl=T.unsafe(nil)); end

  def safe_level(); end

  def stop_service(); end

  def thread(); end

  def to_id(obj); end

  def to_obj(ref); end

  def uri(); end

  def verbose(); end

  def verbose=(v); end
  INSECURE_METHOD = ::T.let(nil, ::T.untyped)
end

class DRb::DRbServer::InvokeMethod
  include ::DRb::DRbServer::InvokeMethod18Mixin
  def initialize(drb_server, client); end

  def perform(); end
end

class DRb::DRbServer::InvokeMethod
end

module DRb::DRbServer::InvokeMethod18Mixin
  def block_yield(x); end

  def perform_with_block(); end
end

module DRb::DRbServer::InvokeMethod18Mixin
end

class DRb::DRbServer
  def self.default_acl(acl); end

  def self.default_argc_limit(argc); end

  def self.default_id_conv(idconv); end

  def self.default_load_limit(sz); end

  def self.default_safe_level(level); end

  def self.make_config(hash=T.unsafe(nil)); end

  def self.verbose(); end

  def self.verbose=(on); end
end

class DRb::DRbServerNotFound
end

class DRb::DRbServerNotFound
end

class DRb::DRbTCPSocket
  def accept(); end

  def alive?(); end

  def close(); end

  def initialize(uri, soc, config=T.unsafe(nil)); end

  def peeraddr(); end

  def recv_reply(); end

  def recv_request(); end

  def send_reply(succ, result); end

  def send_request(ref, msg_id, arg, b); end

  def set_sockopt(soc); end

  def shutdown(); end

  def stream(); end

  def uri(); end
end

class DRb::DRbTCPSocket
  def self.getservername(); end

  def self.open(uri, config); end

  def self.open_server(uri, config); end

  def self.open_server_inaddr_any(host, port); end

  def self.parse_uri(uri); end

  def self.uri_option(uri, config); end
end

class DRb::DRbUNIXSocket
  def initialize(uri, soc, config=T.unsafe(nil), server_mode=T.unsafe(nil)); end
  Max_try = ::T.let(nil, ::T.untyped)
end

class DRb::DRbUNIXSocket
  def self.temp_server(); end
end

class DRb::DRbURIOption
  def ==(other); end

  def eql?(other); end

  def initialize(option); end

  def option(); end
end

class DRb::DRbURIOption
end

module DRb::DRbUndumped
  def _dump(dummy); end
end

module DRb::DRbUndumped
end

class DRb::DRbUnknown
  def _dump(lv); end

  def buf(); end

  def exception(); end

  def initialize(err, buf); end

  def name(); end

  def reload(); end
end

class DRb::DRbUnknown
  def self._load(s); end
end

class DRb::DRbUnknownError
  def _dump(lv); end

  def initialize(unknown); end

  def unknown(); end
end

class DRb::DRbUnknownError
  def self._load(s); end
end

module DRb
  def self.config(); end

  def self.current_server(); end

  def self.fetch_server(uri); end

  def self.front(); end

  def self.here?(uri); end

  def self.install_acl(acl); end

  def self.install_id_conv(idconv); end

  def self.mutex(); end

  def self.primary_server(); end

  def self.primary_server=(primary_server); end

  def self.regist_server(server); end

  def self.remove_server(server); end

  def self.start_service(uri=T.unsafe(nil), front=T.unsafe(nil), config=T.unsafe(nil)); end

  def self.stop_service(); end

  def self.thread(); end

  def self.to_id(obj); end

  def self.to_obj(ref); end

  def self.uri(); end
end

DRbIdConv = DRb::DRbIdConv

DRbObject = DRb::DRbObject

DRbUndumped = DRb::DRbUndumped

class Date
  DATE_FORMATS = ::T.let(nil, ::T.untyped)
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

module DateAndTime::Calculations
  DAYS_INTO_WEEK = ::T.let(nil, ::T.untyped)
  WEEKEND_DAYS = ::T.let(nil, ::T.untyped)
end

class Delegator
  def !=(obj); end

  def ==(obj); end

  def __getobj__(); end

  def __setobj__(obj); end

  def eql?(obj); end

  def initialize(obj); end

  def marshal_dump(); end

  def marshal_load(data); end

  def method_missing(m, *args, &block); end

  def methods(all=T.unsafe(nil)); end

  def protected_methods(all=T.unsafe(nil)); end

  def public_methods(all=T.unsafe(nil)); end
end

class Delegator
  def self.const_missing(n); end

  def self.delegating_block(mid); end

  def self.public_api(); end
end

module Digest::UUID
  DNS_NAMESPACE = ::T.let(nil, ::T.untyped)
  OID_NAMESPACE = ::T.let(nil, ::T.untyped)
  URL_NAMESPACE = ::T.let(nil, ::T.untyped)
  X500_NAMESPACE = ::T.let(nil, ::T.untyped)
end

class Dir
  def children(); end

  def each_child(); end
end

class Dir
  def self.children(*_); end

  def self.each_child(*_); end

  def self.empty?(_); end

  def self.exists?(_); end

  def self.tmpdir(); end
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end

  def result_with_hash(hash); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

module ERB::Util
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_ONCE_REGEXP = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE_REGEXP = ::T.let(nil, ::T.untyped)
end

Emitter = Psych::Stream::Emitter

class Encoding
  def _dump(*_); end
end

class Encoding::Converter
  def convert(_); end

  def convpath(); end

  def destination_encoding(); end

  def finish(); end

  def initialize(*_); end

  def insert_output(_); end

  def last_error(); end

  def primitive_convert(*_); end

  def primitive_errinfo(); end

  def putback(*_); end

  def replacement(); end

  def replacement=(replacement); end

  def source_encoding(); end
end

class Encoding::Converter
  def self.asciicompat_encoding(_); end

  def self.search_convpath(*_); end
end

class Encoding::InvalidByteSequenceError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_bytes(); end

  def incomplete_input?(); end

  def readagain_bytes(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding::UndefinedConversionError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_char(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding
  def self._load(_); end

  def self.locale_charmap(); end
end

module Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def chain(*_); end

  def chunk(); end

  def chunk_while(); end

  def each_entry(*_); end

  def grep_v(_); end

  def slice_after(*_); end

  def slice_before(*_); end

  def slice_when(); end

  def sum(identity=T.unsafe(nil), &block); end

  def to_set(klass=T.unsafe(nil), *args, &block); end

  def uniq(); end
end

class Enumerator
  def +(_); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*_); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Chain
end

class Enumerator::Chain
end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

class Enumerator::Lazy
  def chunk(*_); end

  def chunk_while(*_); end

  def force(*_); end

  def slice_when(*_); end
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADARCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADARCH
end

class Errno::EBADEXEC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADEXEC
end

class Errno::EBADMACHO
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADMACHO
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::NOERROR

class Errno::EDEVERR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EDEVERR
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

Errno::EIPSEC = Errno::NOERROR

class Errno::ELAST
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ELAST
end

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

class Errno::ENOPOLICY
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOPOLICY
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::EPWROFF
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPWROFF
end

Errno::EQFULL = Errno::ELAST

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Errno::ESHLIBVERS
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ESHLIBVERS
end

module Erubi
  RANGE_ALL = ::T.let(nil, ::T.untyped)
  RANGE_FIRST = ::T.let(nil, ::T.untyped)
  RANGE_LAST = ::T.let(nil, ::T.untyped)
  TEXT_END = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Exception
  def full_message(*_); end
end

class Exception
  def self.exception(*_); end

  def self.to_tty?(); end
end

module Exception2MessageMapper
  def bind(cl); end

end

Exception2MessageMapper::E2MM = Exception2MessageMapper

class Exception2MessageMapper::ErrNotRegisteredException
end

class Exception2MessageMapper::ErrNotRegisteredException
end

module Exception2MessageMapper
  def self.Fail(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.Raise(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.def_e2message(k, c, m); end

  def self.def_exception(k, n, m, s=T.unsafe(nil)); end

  def self.e2mm_message(klass, exp); end

  def self.extend_object(cl); end

  def self.message(klass, exp); end
end

module ExceptionForMatrix
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end
end

class ExceptionForMatrix::ErrDimensionMismatch
end

class ExceptionForMatrix::ErrDimensionMismatch
end

class ExceptionForMatrix::ErrNotRegular
end

class ExceptionForMatrix::ErrNotRegular
end

class ExceptionForMatrix::ErrOperationNotDefined
end

class ExceptionForMatrix::ErrOperationNotDefined
end

class ExceptionForMatrix::ErrOperationNotImplemented
end

class ExceptionForMatrix::ErrOperationNotImplemented
end

module ExceptionForMatrix
  extend ::Exception2MessageMapper
  def self.included(mod); end
end

module ExecJS
  VERSION = ::T.let(nil, ::T.untyped)
end

module ExecJS::Runtimes
  Disabled = ::T.let(nil, ::T.untyped)
  Duktape = ::T.let(nil, ::T.untyped)
  JScript = ::T.let(nil, ::T.untyped)
  JavaScriptCore = ::T.let(nil, ::T.untyped)
  MiniRacer = ::T.let(nil, ::T.untyped)
  Node = ::T.let(nil, ::T.untyped)
  RubyRacer = ::T.let(nil, ::T.untyped)
  RubyRhino = ::T.let(nil, ::T.untyped)
  SpiderMonkey = ::T.let(nil, ::T.untyped)
  Spidermonkey = ::T.let(nil, ::T.untyped)
  V8 = ::T.let(nil, ::T.untyped)
end

class ExitCalledError
end

class ExitCalledError
end

module FFI
  CURRENT_PROCESS = ::T.let(nil, ::T.untyped)
  SizeTypes = ::T.let(nil, ::T.untyped)
  TYPE_BOOL = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_IN = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  TYPE_BUFFER_OUT = ::T.let(nil, ::T.untyped)
  TYPE_FLOAT32 = ::T.let(nil, ::T.untyped)
  TYPE_FLOAT64 = ::T.let(nil, ::T.untyped)
  TYPE_INT16 = ::T.let(nil, ::T.untyped)
  TYPE_INT32 = ::T.let(nil, ::T.untyped)
  TYPE_INT64 = ::T.let(nil, ::T.untyped)
  TYPE_INT8 = ::T.let(nil, ::T.untyped)
  TYPE_LONG = ::T.let(nil, ::T.untyped)
  TYPE_LONGDOUBLE = ::T.let(nil, ::T.untyped)
  TYPE_POINTER = ::T.let(nil, ::T.untyped)
  TYPE_STRING = ::T.let(nil, ::T.untyped)
  TYPE_UINT16 = ::T.let(nil, ::T.untyped)
  TYPE_UINT32 = ::T.let(nil, ::T.untyped)
  TYPE_UINT64 = ::T.let(nil, ::T.untyped)
  TYPE_UINT8 = ::T.let(nil, ::T.untyped)
  TYPE_ULONG = ::T.let(nil, ::T.untyped)
  TYPE_VARARGS = ::T.let(nil, ::T.untyped)
  TYPE_VOID = ::T.let(nil, ::T.untyped)
  TypeDefs = ::T.let(nil, ::T.untyped)
  USE_THIS_PROCESS_AS_LIBRARY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

FFI::CallbackInfo = FFI::FunctionType

class FFI::DynamicLibrary
  RTLD_ALL_MASK = ::T.let(nil, ::T.untyped)
  RTLD_BINDING_MASK = ::T.let(nil, ::T.untyped)
  RTLD_DEEPBIND = ::T.let(nil, ::T.untyped)
  RTLD_FIRST = ::T.let(nil, ::T.untyped)
  RTLD_GLOBAL = ::T.let(nil, ::T.untyped)
  RTLD_LAZY = ::T.let(nil, ::T.untyped)
  RTLD_LOCAL = ::T.let(nil, ::T.untyped)
  RTLD_LOCATION_MASK = ::T.let(nil, ::T.untyped)
  RTLD_MEMBER = ::T.let(nil, ::T.untyped)
  RTLD_NODELETE = ::T.let(nil, ::T.untyped)
  RTLD_NOLOAD = ::T.let(nil, ::T.untyped)
  RTLD_NOW = ::T.let(nil, ::T.untyped)
end

FFI::FunctionInfo = FFI::FunctionType

module FFI::Library
  CURRENT_PROCESS = ::T.let(nil, ::T.untyped)
  FlagsMap = ::T.let(nil, ::T.untyped)
  LIBC = ::T.let(nil, ::T.untyped)
end

FFI::NativeLibrary = FFI::DynamicLibrary

module FFI::NativeType
  BOOL = ::T.let(nil, ::T.untyped)
  BUFFER_IN = ::T.let(nil, ::T.untyped)
  BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  BUFFER_OUT = ::T.let(nil, ::T.untyped)
  FLOAT32 = ::T.let(nil, ::T.untyped)
  FLOAT64 = ::T.let(nil, ::T.untyped)
  INT16 = ::T.let(nil, ::T.untyped)
  INT32 = ::T.let(nil, ::T.untyped)
  INT64 = ::T.let(nil, ::T.untyped)
  INT8 = ::T.let(nil, ::T.untyped)
  LONG = ::T.let(nil, ::T.untyped)
  LONGDOUBLE = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  UINT16 = ::T.let(nil, ::T.untyped)
  UINT32 = ::T.let(nil, ::T.untyped)
  UINT64 = ::T.let(nil, ::T.untyped)
  UINT8 = ::T.let(nil, ::T.untyped)
  ULONG = ::T.let(nil, ::T.untyped)
  VARARGS = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
end

module FFI::NativeType
end

class FFI::NullPointerError
end

class FFI::NullPointerError
end

module FFI::Platform
  ADDRESS_ALIGN = ::T.let(nil, ::T.untyped)
  ADDRESS_SIZE = ::T.let(nil, ::T.untyped)
  ARCH = ::T.let(nil, ::T.untyped)
  BIG_ENDIAN = ::T.let(nil, ::T.untyped)
  BYTE_ORDER = ::T.let(nil, ::T.untyped)
  CONF_DIR = ::T.let(nil, ::T.untyped)
  CPU = ::T.let(nil, ::T.untyped)
  DOUBLE_ALIGN = ::T.let(nil, ::T.untyped)
  DOUBLE_SIZE = ::T.let(nil, ::T.untyped)
  FLOAT_ALIGN = ::T.let(nil, ::T.untyped)
  FLOAT_SIZE = ::T.let(nil, ::T.untyped)
  INT16_ALIGN = ::T.let(nil, ::T.untyped)
  INT16_SIZE = ::T.let(nil, ::T.untyped)
  INT32_ALIGN = ::T.let(nil, ::T.untyped)
  INT32_SIZE = ::T.let(nil, ::T.untyped)
  INT64_ALIGN = ::T.let(nil, ::T.untyped)
  INT64_SIZE = ::T.let(nil, ::T.untyped)
  INT8_ALIGN = ::T.let(nil, ::T.untyped)
  INT8_SIZE = ::T.let(nil, ::T.untyped)
  IS_BSD = ::T.let(nil, ::T.untyped)
  IS_DRAGONFLYBSD = ::T.let(nil, ::T.untyped)
  IS_FREEBSD = ::T.let(nil, ::T.untyped)
  IS_GNU = ::T.let(nil, ::T.untyped)
  IS_LINUX = ::T.let(nil, ::T.untyped)
  IS_MAC = ::T.let(nil, ::T.untyped)
  IS_NETBSD = ::T.let(nil, ::T.untyped)
  IS_OPENBSD = ::T.let(nil, ::T.untyped)
  IS_SOLARIS = ::T.let(nil, ::T.untyped)
  IS_WINDOWS = ::T.let(nil, ::T.untyped)
  LIBC = ::T.let(nil, ::T.untyped)
  LIBPREFIX = ::T.let(nil, ::T.untyped)
  LIBSUFFIX = ::T.let(nil, ::T.untyped)
  LITTLE_ENDIAN = ::T.let(nil, ::T.untyped)
  LONG_ALIGN = ::T.let(nil, ::T.untyped)
  LONG_SIZE = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  OS = ::T.let(nil, ::T.untyped)
  OSVERSION = ::T.let(nil, ::T.untyped)
end

class FFI::Pointer
  NULL = ::T.let(nil, ::T.untyped)
  SIZE = ::T.let(nil, ::T.untyped)
end

class FFI::Struct::InlineArray
  include ::Enumerable
end

class FFI::StructLayout::Number
end

class FFI::StructLayout::Number
end

class FFI::StructLayout::Pointer
end

class FFI::StructLayout::Pointer
end

class FFI::StructLayout::String
end

class FFI::StructLayout::String
end

class FFI::StructLayoutBuilder
  NUMBER_TYPES = ::T.let(nil, ::T.untyped)
end

class FFI::Type
  BOOL = ::T.let(nil, ::T.untyped)
  BUFFER_IN = ::T.let(nil, ::T.untyped)
  BUFFER_INOUT = ::T.let(nil, ::T.untyped)
  BUFFER_OUT = ::T.let(nil, ::T.untyped)
  CHAR = ::T.let(nil, ::T.untyped)
  DOUBLE = ::T.let(nil, ::T.untyped)
  FLOAT = ::T.let(nil, ::T.untyped)
  FLOAT32 = ::T.let(nil, ::T.untyped)
  FLOAT64 = ::T.let(nil, ::T.untyped)
  INT = ::T.let(nil, ::T.untyped)
  INT16 = ::T.let(nil, ::T.untyped)
  INT32 = ::T.let(nil, ::T.untyped)
  INT64 = ::T.let(nil, ::T.untyped)
  INT8 = ::T.let(nil, ::T.untyped)
  LONG = ::T.let(nil, ::T.untyped)
  LONGDOUBLE = ::T.let(nil, ::T.untyped)
  LONG_LONG = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  SCHAR = ::T.let(nil, ::T.untyped)
  SHORT = ::T.let(nil, ::T.untyped)
  SINT = ::T.let(nil, ::T.untyped)
  SLONG = ::T.let(nil, ::T.untyped)
  SLONG_LONG = ::T.let(nil, ::T.untyped)
  SSHORT = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  UCHAR = ::T.let(nil, ::T.untyped)
  UINT = ::T.let(nil, ::T.untyped)
  UINT16 = ::T.let(nil, ::T.untyped)
  UINT32 = ::T.let(nil, ::T.untyped)
  UINT64 = ::T.let(nil, ::T.untyped)
  UINT8 = ::T.let(nil, ::T.untyped)
  ULONG = ::T.let(nil, ::T.untyped)
  ULONG_LONG = ::T.let(nil, ::T.untyped)
  USHORT = ::T.let(nil, ::T.untyped)
  VARARGS = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
end

FFI::Type::Array = FFI::ArrayType

FFI::Type::Function = FFI::FunctionType

FFI::Type::Struct = FFI::StructByValue

class FSEvent
  VERSION = ::T.let(nil, ::T.untyped)
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

module Fcntl
  FD_CLOEXEC = ::T.let(nil, ::T.untyped)
  F_DUPFD = ::T.let(nil, ::T.untyped)
  F_GETFD = ::T.let(nil, ::T.untyped)
  F_GETFL = ::T.let(nil, ::T.untyped)
  F_GETLK = ::T.let(nil, ::T.untyped)
  F_RDLCK = ::T.let(nil, ::T.untyped)
  F_SETFD = ::T.let(nil, ::T.untyped)
  F_SETFL = ::T.let(nil, ::T.untyped)
  F_SETLK = ::T.let(nil, ::T.untyped)
  F_SETLKW = ::T.let(nil, ::T.untyped)
  F_UNLCK = ::T.let(nil, ::T.untyped)
  F_WRLCK = ::T.let(nil, ::T.untyped)
  O_ACCMODE = ::T.let(nil, ::T.untyped)
  O_APPEND = ::T.let(nil, ::T.untyped)
  O_CREAT = ::T.let(nil, ::T.untyped)
  O_EXCL = ::T.let(nil, ::T.untyped)
  O_NDELAY = ::T.let(nil, ::T.untyped)
  O_NOCTTY = ::T.let(nil, ::T.untyped)
  O_NONBLOCK = ::T.let(nil, ::T.untyped)
  O_RDONLY = ::T.let(nil, ::T.untyped)
  O_RDWR = ::T.let(nil, ::T.untyped)
  O_TRUNC = ::T.let(nil, ::T.untyped)
  O_WRONLY = ::T.let(nil, ::T.untyped)
end

module Fcntl
end

class Fiber
  def resume(*_); end

  def transfer(*_); end
end

class Fiber
  def self.current(); end

  def self.yield(*_); end
end

class File
  RELATIVE_PARENTDIR = ::T.let(nil, ::T.untyped)
  RELATIVE_SAMEDIR = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
end

class File::Stat
  def size?(); end
end

class File
  def self.cleanpath(path, rel_root=T.unsafe(nil)); end

  def self.empty?(_); end

  def self.exists?(_); end

  def self.lutime(*_); end

  def self.mkfifo(*_); end

  def self.open!(file, *args, &block); end

  def self.read_binary(file); end

  def self.relative_path(from, to); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
  LN_SUPPORTED = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

module Find
end

module Find
  def self.find(*paths, ignore_error: T.unsafe(nil)); end

  def self.prune(); end
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
  include ::ActiveSupport::NumericWithFormat
  def to_d(precision=T.unsafe(nil)); end
end

module Forwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_instance_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_instance_delegators(accessor, *methods); end

  def delegate(hash); end

  def instance_delegate(hash); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

module GC
  def garbage_collect(*_); end
end

module GC
  def self.latest_gc_info(*_); end

  def self.stress=(stress); end

  def self.verify_internal_consistency(); end

  def self.verify_transient_heap_internal_consistency(); end
end

Gem::Cache = Gem::SourceIndex

class Gem::RemoteFetcher
  def s3_uri_signer(uri); end
end

class Gem::RemoteFetcher::FetchError
  def initialize(message, uri); end

  def uri(); end

  def uri=(uri); end
end

class Gem::RemoteFetcher::FetchError
end

class Gem::RemoteFetcher::UnknownHostError
end

class Gem::RemoteFetcher::UnknownHostError
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::S3URISigner
  def initialize(uri); end

  def sign(expiration=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end
  BASE64_URI_TRANSLATE = ::T.let(nil, ::T.untyped)
  EC2_IAM_INFO = ::T.let(nil, ::T.untyped)
  EC2_IAM_SECURITY_CREDENTIALS = ::T.let(nil, ::T.untyped)
end

class Gem::S3URISigner::ConfigurationError
  def initialize(message); end
end

class Gem::S3URISigner::ConfigurationError
end

class Gem::S3URISigner::InstanceProfileError
  def initialize(message); end
end

class Gem::S3URISigner::InstanceProfileError
end

class Gem::S3URISigner::S3Config
  def access_key_id(); end

  def access_key_id=(_); end

  def region(); end

  def region=(_); end

  def secret_access_key(); end

  def secret_access_key=(_); end

  def security_token(); end

  def security_token=(_); end
end

class Gem::S3URISigner::S3Config
  def self.[](*_); end

  def self.members(); end
end

class Gem::S3URISigner
end

class Gem::SourceIndex
  include ::Enumerable
  def ==(other); end

  def add_spec(gem_spec, name=T.unsafe(nil)); end

  def add_specs(*gem_specs); end

  def all_gems(); end

  def dump(); end

  def each(&block); end

  def find_name(gem_name, requirement=T.unsafe(nil)); end

  def gem_signature(gem_full_name); end

  def gems(); end

  def index_signature(); end

  def initialize(specifications=T.unsafe(nil)); end

  def latest_specs(include_prerelease=T.unsafe(nil)); end

  def length(); end

  def load_gems_in(*spec_dirs); end

  def outdated(); end

  def prerelease_gems(); end

  def prerelease_specs(); end

  def refresh!(); end

  def released_gems(); end

  def released_specs(); end

  def remove_spec(full_name); end

  def search(gem_pattern, platform_only=T.unsafe(nil)); end

  def size(); end

  def spec_dirs(); end

  def spec_dirs=(spec_dirs); end

  def specification(full_name); end
end

class Gem::SourceIndex
  def self.from_gems_in(*spec_dirs); end

  def self.from_installed_gems(*deprecated); end

  def self.installed_spec_directories(); end

  def self.load_specification(file_name); end
end

class Gem::Specification
  extend ::Enumerable
end

module Gem::Util
  def self.correct_for_windows_path(path); end
end

module Gem
  def self.source_index(); end
end

module GlobalID::Locator
  DEFAULT_LOCATOR = ::T.let(nil, ::T.untyped)
end

class GlobalID::Locator::BaseLocator
  def locate(gid); end

  def locate_many(gids, options=T.unsafe(nil)); end
end

class GlobalID::Locator::BaseLocator
end

class GlobalID::Locator::BlockLocator
  def initialize(block); end

  def locate(gid); end

  def locate_many(gids, options=T.unsafe(nil)); end
end

class GlobalID::Locator::BlockLocator
end

class GlobalID::Locator::UnscopedLocator
end

class GlobalID::Locator::UnscopedLocator
end

module GlobalID::Locator
  def self.locate(gid, options=T.unsafe(nil)); end

  def self.locate_many(gids, options=T.unsafe(nil)); end

  def self.locate_many_signed(sgids, options=T.unsafe(nil)); end

  def self.locate_signed(sgid, options=T.unsafe(nil)); end

  def self.use(app, locator=T.unsafe(nil), &locator_block); end
end

class HTMLSelector
  NO_STRIP = ::T.let(nil, ::T.untyped)
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def <(_); end

  def <=(_); end

  def >(_); end

  def >=(_); end

  def compact(); end

  def compact!(); end

  def default_proc(); end

  def default_proc=(default_proc); end

  def fetch_values(*_); end

  def flatten(*_); end

  def index(_); end

  def replace(_); end

  def slice(*_); end

  def to_h(); end

  def to_proc(); end

  def transform_keys(); end

  def transform_keys!(); end

  def transform_values!(); end

  def update(*_); end
end

class Hash
  def self.try_convert(_); end
end

HashWithIndifferentAccess = ActiveSupport::HashWithIndifferentAccess

module I18n
  DEFAULT_INTERPOLATION_PATTERNS = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  INTERPOLATION_PATTERN = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS_PATTERN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Cache
  def _fetch(cache_key, &block); end

  def cache_key(locale, key, options); end

  def fetch(cache_key, &block); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Cache
end

module I18n::Backend::CacheFile
  def load_file(filename); end

  def normalized_path(file); end

  def path_roots(); end

  def path_roots=(path_roots); end
end

module I18n::Backend::CacheFile
end

module I18n::Backend::Cascade
  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end
end

module I18n::Backend::Cascade
end

class I18n::Backend::Chain
  include ::I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def backends(); end

  def backends=(backends); end

  def eager_load!(); end

  def exists?(locale, key); end

  def init_translations(); end

  def initialize(*backends); end

  def initialized?(); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def namespace_lookup?(result, options); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translate(locale, key, default_options=T.unsafe(nil)); end

  def translations(); end
end

module I18n::Backend::Chain::Implementation
end

class I18n::Backend::Chain
end

module I18n::Backend::Fallbacks
  def exists?(locale, key); end

  def extract_non_symbol_default!(options); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Fallbacks
end

module I18n::Backend::Flatten
  def escape_default_separator(key); end

  def find_link(locale, key); end

  def flatten_keys(hash, escape, prev_key=T.unsafe(nil), &block); end

  def flatten_translations(locale, data, escape, subtree); end

  def links(); end

  def normalize_flat_keys(locale, key, scope, separator); end

  def resolve_link(locale, key); end

  def store_link(locale, key, link); end
  FLATTEN_SEPARATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR_ESCAPE_CHAR = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Flatten
  def self.escape_default_separator(key); end

  def self.normalize_flat_keys(locale, key, scope, separator); end
end

module I18n::Backend::Gettext
  def load_po(filename); end

  def normalize(locale, data); end

  def normalize_pluralization(locale, key, value); end

  def parse(filename); end
end

class I18n::Backend::Gettext::PoData
  def set_comment(msgid_or_sym, comment); end
end

class I18n::Backend::Gettext::PoData
end

module I18n::Backend::Gettext
end

module I18n::Backend::InterpolationCompiler
  def compile_all_strings_in(data); end

  def interpolate(locale, string, values); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::InterpolationCompiler::Compiler
  def compile_if_an_interpolation(string); end

  def compile_interpolation_token(key); end

  def compiled_interpolation_body(str); end

  def direct_key(key); end

  def escape_key_sym(key); end

  def escape_plain_str(str); end

  def handle_interpolation_token(interpolation, matchdata); end

  def interpolate_key(key); end

  def interpolate_or_raise_missing(key); end

  def interpolated_str?(str); end

  def missing_key(key); end

  def nil_key(key); end

  def reserved_key(key); end

  def tokenize(str); end
  INTERPOLATION_SYNTAX_PATTERN = ::T.let(nil, ::T.untyped)
  TOKENIZER = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::InterpolationCompiler::Compiler
  extend ::I18n::Backend::InterpolationCompiler::Compiler
end

module I18n::Backend::InterpolationCompiler
end

class I18n::Backend::KeyValue
  include ::I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def init_translations(); end

  def initialize(store, subtrees=T.unsafe(nil)); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def store(); end

  def store=(store); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translations(); end
end

module I18n::Backend::KeyValue::Implementation
end

class I18n::Backend::KeyValue::SubtreeProxy
  def [](key); end

  def has_key?(key); end

  def initialize(master_key, store); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end
end

class I18n::Backend::KeyValue::SubtreeProxy
end

class I18n::Backend::KeyValue
end

module I18n::Backend::Memoize
  def available_locales(); end

  def eager_load!(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def memoized_lookup(); end

  def reload!(); end

  def reset_memoizations!(locale=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::Memoize
end

module I18n::Backend::Metadata
  def interpolate(locale, entry, values=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def with_metadata(metadata, &block); end
end

module I18n::Backend::Metadata
  def self.included(base); end
end

module I18n::Backend::Pluralization
  def pluralize(locale, entry, count); end

  def pluralizer(locale); end

  def pluralizers(); end
end

module I18n::Backend::Pluralization
end

module I18n::Backend::Transliterator
  DEFAULT_REPLACEMENT_CHAR = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
  DEFAULT_APPROXIMATIONS = ::T.let(nil, ::T.untyped)
end

module I18n::Gettext
  CONTEXT_SEPARATOR = ::T.let(nil, ::T.untyped)
  PLURAL_SEPARATOR = ::T.let(nil, ::T.untyped)
end

module I18n::Gettext::Helpers
  def N_(msgsid); end

  def _(msgid, options=T.unsafe(nil)); end

  def gettext(msgid, options=T.unsafe(nil)); end

  def n_(msgid, msgid_plural, n=T.unsafe(nil)); end

  def ngettext(msgid, msgid_plural, n=T.unsafe(nil)); end

  def np_(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def npgettext(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def ns_(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def nsgettext(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def p_(msgctxt, msgid); end

  def pgettext(msgctxt, msgid); end

  def s_(msgid, separator=T.unsafe(nil)); end

  def sgettext(msgid, separator=T.unsafe(nil)); end
end

module I18n::Gettext::Helpers
end

module I18n::Gettext
  def self.extract_scope(msgid, separator); end

  def self.plural_keys(*args); end
end

module I18n::Locale
end

class I18n::Locale::Fallbacks
  def [](locale); end

  def compute(tags, include_defaults=T.unsafe(nil), exclude=T.unsafe(nil)); end

  def defaults(); end

  def defaults=(defaults); end

  def initialize(*mappings); end

  def map(mappings); end
end

class I18n::Locale::Fallbacks
end

module I18n::Locale::Tag
  RFC4646_FORMATS = ::T.let(nil, ::T.untyped)
  RFC4646_SUBTAGS = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Parents
  def parent(); end

  def parents(); end

  def self_and_parents(); end
end

module I18n::Locale::Tag::Parents
end

class I18n::Locale::Tag::Rfc4646
  include ::I18n::Locale::Tag::Parents
  def to_sym(); end
end

module I18n::Locale::Tag::Rfc4646::Parser
  PATTERN = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Rfc4646::Parser
  def self.match(tag); end
end

class I18n::Locale::Tag::Rfc4646
  def self.parser(); end

  def self.parser=(parser); end

  def self.tag(tag); end
end

class I18n::Locale::Tag::Simple
  include ::I18n::Locale::Tag::Parents
  def initialize(*tag); end

  def subtags(); end

  def tag(); end

  def to_a(); end

  def to_sym(); end
end

class I18n::Locale::Tag::Simple
  def self.tag(tag); end
end

module I18n::Locale::Tag
  def self.implementation(); end

  def self.implementation=(implementation); end

  def self.tag(tag); end
end

module I18n::Locale
end

class I18n::Middleware
  def call(env); end

  def initialize(app); end
end

class I18n::Middleware
end

module I18n::Tests
end

module I18n::Tests::Localization
end

module I18n::Tests::Localization
  def self.included(base); end
end

module I18n::Tests
end

module I18n
  def self.cache_key_digest(); end

  def self.cache_key_digest=(key_digest); end

  def self.cache_namespace(); end

  def self.cache_namespace=(namespace); end

  def self.cache_store(); end

  def self.cache_store=(store); end

  def self.fallbacks(); end

  def self.fallbacks=(fallbacks); end

  def self.perform_caching?(); end
end

module INotify
  VERSION = ::T.let(nil, ::T.untyped)
end

class IO
  def beep(); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(); end

  def echo=(echo); end

  def echo?(); end

  def external_encoding(); end

  def getch(*_); end

  def getpass(*_); end

  def goto(); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def oflush(); end

  def pathconf(_); end

  def pread(*_); end

  def pressed?(); end

  def pwrite(_, _1); end

  def raw(*_); end

  def raw!(*_); end

  def ready?(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def winsize(); end

  def winsize=(winsize); end

  def write_nonblock(buf, exception: T.unsafe(nil)); end
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.console(*_); end

  def self.console_size(); end

  def self.default_console_size(); end

  def self.foreach(*_); end
end

class IPAddr
  include ::Comparable
  def &(other); end

  def <<(num); end

  def ==(other); end

  def ===(other); end

  def >>(num); end

  def eql?(other); end

  def family(); end

  def hton(); end

  def include?(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end

  def ip6_arpa(); end

  def ip6_int(); end

  def ipv4?(); end

  def ipv4_compat(); end

  def ipv4_compat?(); end

  def ipv4_mapped(); end

  def ipv4_mapped?(); end

  def ipv6?(); end

  def link_local?(); end

  def loopback?(); end

  def mask(prefixlen); end

  def mask!(mask); end

  def native(); end

  def prefix(); end

  def prefix=(prefix); end

  def private?(); end

  def reverse(); end

  def set(addr, *family); end

  def succ(); end

  def to_i(); end

  def to_range(); end

  def to_string(); end

  def |(other); end

  def ~(); end
  IN4MASK = ::T.let(nil, ::T.untyped)
  IN6FORMAT = ::T.let(nil, ::T.untyped)
  IN6MASK = ::T.let(nil, ::T.untyped)
  RE_IPV4ADDRLIKE = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_COMPRESSED = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_FULL = ::T.let(nil, ::T.untyped)
end

class IPAddr::AddressFamilyError
end

class IPAddr::AddressFamilyError
end

class IPAddr::Error
end

class IPAddr::Error
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidPrefixError
end

class IPAddr::InvalidPrefixError
end

class IPAddr
  def self.new_ntoh(addr); end

  def self.ntop(addr); end
end

module IRB
  IRBRC_EXT = ::T.let(nil, ::T.untyped)
  MagicFile = ::T.let(nil, ::T.untyped)
  STDIN_FILE_NAME = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class IRB::Abort
end

class IRB::Abort
end

class IRB::Context
  def __exit__(*_); end

  def __inspect__(); end

  def __to_s__(); end

  def ap_name(); end

  def ap_name=(ap_name); end

  def auto_indent_mode(); end

  def auto_indent_mode=(auto_indent_mode); end

  def back_trace_limit(); end

  def back_trace_limit=(back_trace_limit); end

  def debug?(); end

  def debug_level(); end

  def debug_level=(value); end

  def echo(); end

  def echo=(echo); end

  def echo?(); end

  def eval_history=(*opts, &b); end

  def evaluate(line, line_no, exception: T.unsafe(nil)); end

  def exit(ret=T.unsafe(nil)); end

  def file_input?(); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end

  def ignore_eof?(); end

  def ignore_sigint(); end

  def ignore_sigint=(ignore_sigint); end

  def ignore_sigint?(); end

  def initialize(irb, workspace=T.unsafe(nil), input_method=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def inspect?(); end

  def inspect_last_value(); end

  def inspect_mode(); end

  def inspect_mode=(opt); end

  def io(); end

  def io=(io); end

  def irb(); end

  def irb=(irb); end

  def irb_name(); end

  def irb_name=(irb_name); end

  def irb_path(); end

  def irb_path=(irb_path); end

  def last_value(); end

  def load_modules(); end

  def load_modules=(load_modules); end

  def main(); end

  def prompt_c(); end

  def prompt_c=(prompt_c); end

  def prompt_i(); end

  def prompt_i=(prompt_i); end

  def prompt_mode(); end

  def prompt_mode=(mode); end

  def prompt_n(); end

  def prompt_n=(prompt_n); end

  def prompt_s(); end

  def prompt_s=(prompt_s); end

  def prompting?(); end

  def rc(); end

  def rc=(rc); end

  def rc?(); end

  def return_format(); end

  def return_format=(return_format); end

  def save_history=(*opts, &b); end

  def set_last_value(value); end

  def thread(); end

  def use_loader=(*opts, &b); end

  def use_readline(); end

  def use_readline=(opt); end

  def use_readline?(); end

  def use_tracer=(*opts, &b); end

  def verbose(); end

  def verbose=(verbose); end

  def verbose?(); end

  def workspace(); end

  def workspace=(workspace); end

  def workspace_home(); end
  IDNAME_IVARS = ::T.let(nil, ::T.untyped)
  NOPRINTING_IVARS = ::T.let(nil, ::T.untyped)
  NO_INSPECTING_IVARS = ::T.let(nil, ::T.untyped)
end

class IRB::Context
end

module IRB::ContextExtender
end

IRB::ContextExtender::CE = IRB::ContextExtender

module IRB::ContextExtender
  def self.def_extend_command(cmd_name, load_file, *aliases); end

  def self.install_extend_commands(); end
end

class IRB::DefaultEncodings
  def external(); end

  def external=(_); end

  def internal(); end

  def internal=(_); end
end

class IRB::DefaultEncodings
  def self.[](*_); end

  def self.members(); end
end

module IRB::ExtendCommandBundle
  def install_alias_method(to, from, override=T.unsafe(nil)); end

  def irb(*opts, &b); end

  def irb_change_workspace(*opts, &b); end

  def irb_context(); end

  def irb_current_working_workspace(*opts, &b); end

  def irb_exit(ret=T.unsafe(nil)); end

  def irb_fg(*opts, &b); end

  def irb_help(*opts, &b); end

  def irb_jobs(*opts, &b); end

  def irb_kill(*opts, &b); end

  def irb_load(*opts, &b); end

  def irb_pop_workspace(*opts, &b); end

  def irb_push_workspace(*opts, &b); end

  def irb_require(*opts, &b); end

  def irb_source(*opts, &b); end

  def irb_workspaces(*opts, &b); end
  NO_OVERRIDE = ::T.let(nil, ::T.untyped)
  OVERRIDE_ALL = ::T.let(nil, ::T.untyped)
  OVERRIDE_PRIVATE_ONLY = ::T.let(nil, ::T.untyped)
end

IRB::ExtendCommandBundle::EXCB = IRB::ExtendCommandBundle

module IRB::ExtendCommandBundle
  def self.def_extend_command(cmd_name, cmd_class, load_file=T.unsafe(nil), *aliases); end

  def self.extend_object(obj); end

  def self.install_extend_commands(); end

  def self.irb_original_method_name(method_name); end
end

class IRB::FileInputMethod
  def encoding(); end

  def eof?(); end

  def initialize(file); end
end

class IRB::FileInputMethod
end

class IRB::InputMethod
  def file_name(); end

  def gets(); end

  def initialize(file=T.unsafe(nil)); end

  def prompt(); end

  def prompt=(prompt); end

  def readable_after_eof?(); end
end

class IRB::InputMethod
end

class IRB::Inspector
  def init(); end

  def initialize(inspect_proc, init_proc=T.unsafe(nil)); end

  def inspect_value(v); end
  INSPECTORS = ::T.let(nil, ::T.untyped)
end

class IRB::Inspector
  def self.def_inspector(key, arg=T.unsafe(nil), &block); end

  def self.keys_with_inspector(inspector); end
end

class IRB::Irb
  def context(); end

  def eval_input(); end

  def handle_exception(exc); end

  def initialize(workspace=T.unsafe(nil), input_method=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def output_value(); end

  def prompt(prompt, ltype, indent, line_no); end

  def run(conf=T.unsafe(nil)); end

  def scanner(); end

  def scanner=(scanner); end

  def signal_handle(); end

  def signal_status(status); end

  def suspend_context(context); end

  def suspend_input_method(input_method); end

  def suspend_name(path=T.unsafe(nil), name=T.unsafe(nil)); end

  def suspend_workspace(workspace); end
  ATTR_PLAIN = ::T.let(nil, ::T.untyped)
  ATTR_TTY = ::T.let(nil, ::T.untyped)
end

class IRB::Irb
end

class IRB::Locale
  def String(mes); end

  def encoding(); end

  def find(file, paths=T.unsafe(nil)); end

  def format(*opts); end

  def gets(*rs); end

  def initialize(locale=T.unsafe(nil)); end

  def lang(); end

  def load(file, priv=T.unsafe(nil)); end

  def modifier(); end

  def print(*opts); end

  def printf(*opts); end

  def puts(*opts); end

  def readline(*rs); end

  def require(file, priv=T.unsafe(nil)); end

  def territory(); end
  LOCALE_DIR = ::T.let(nil, ::T.untyped)
  LOCALE_NAME_RE = ::T.let(nil, ::T.untyped)
end

class IRB::Locale
end

module IRB::MethodExtender
  def def_post_proc(base_method, extend_method); end

  def def_pre_proc(base_method, extend_method); end

  def new_alias_name(name, prefix=T.unsafe(nil), postfix=T.unsafe(nil)); end
end

module IRB::MethodExtender
end

module IRB::Notifier
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end
  D_NOMSG = ::T.let(nil, ::T.untyped)
end

class IRB::Notifier::AbstractNotifier
  def exec_if(); end

  def initialize(prefix, base_notifier); end

  def notify?(); end

  def ppx(prefix, *objs); end

  def prefix(); end

  def print(*opts); end

  def printf(format, *opts); end

  def printn(*opts); end

  def puts(*objs); end
end

class IRB::Notifier::AbstractNotifier
end

class IRB::Notifier::CompositeNotifier
  def def_notifier(level, prefix=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def level_notifier(); end

  def level_notifier=(value); end

  def notifiers(); end
end

class IRB::Notifier::CompositeNotifier
end

class IRB::Notifier::ErrUndefinedNotifier
end

class IRB::Notifier::ErrUndefinedNotifier
end

class IRB::Notifier::ErrUnrecognizedLevel
end

class IRB::Notifier::ErrUnrecognizedLevel
end

class IRB::Notifier::LeveledNotifier
  include ::Comparable
  def initialize(base, level, prefix); end

  def level(); end
end

class IRB::Notifier::LeveledNotifier
end

class IRB::Notifier::NoMsgNotifier
  def initialize(); end
end

class IRB::Notifier::NoMsgNotifier
end

module IRB::Notifier
  extend ::Exception2MessageMapper
  def self.def_notifier(prefix=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def self.included(mod); end
end

class IRB::OutputMethod
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def parse_printf_format(format, opts); end

  def ppx(prefix, *objs); end

  def print(*opts); end

  def printf(format, *opts); end

  def printn(*opts); end

  def puts(*objs); end
end

class IRB::OutputMethod::NotImplementedError
end

class IRB::OutputMethod::NotImplementedError
end

class IRB::OutputMethod
  extend ::Exception2MessageMapper
  def self.included(mod); end
end

class IRB::ReadlineInputMethod
  include ::Readline
  def encoding(); end

  def eof?(); end

  def initialize(); end

  def line(line_no); end
end

class IRB::ReadlineInputMethod
end

class IRB::SLex
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def create(token, preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def def_rule(token, preproc=T.unsafe(nil), postproc=T.unsafe(nil), &block); end

  def def_rules(*tokens, &block); end

  def match(token); end

  def postproc(token); end

  def preproc(token, proc); end

  def search(token); end
  DOUT = ::T.let(nil, ::T.untyped)
  D_DEBUG = ::T.let(nil, ::T.untyped)
  D_DETAIL = ::T.let(nil, ::T.untyped)
  D_WARN = ::T.let(nil, ::T.untyped)
end

class IRB::SLex::ErrNodeAlreadyExists
end

class IRB::SLex::ErrNodeAlreadyExists
end

class IRB::SLex::ErrNodeNothing
end

class IRB::SLex::ErrNodeNothing
end

class IRB::SLex::Node
  def create_subnode(chrs, preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def initialize(preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def match(chrs, op=T.unsafe(nil)); end

  def match_io(io, op=T.unsafe(nil)); end

  def postproc(); end

  def postproc=(postproc); end

  def preproc(); end

  def preproc=(preproc); end

  def search(chrs, opt=T.unsafe(nil)); end
end

class IRB::SLex::Node
end

class IRB::SLex
  extend ::Exception2MessageMapper
  def self.included(mod); end
end

class IRB::StdioInputMethod
  def encoding(); end

  def eof?(); end

  def initialize(); end

  def line(line_no); end
end

class IRB::StdioInputMethod
end

class IRB::StdioOutputMethod
end

class IRB::StdioOutputMethod
end

class IRB::WorkSpace
  def code_around_binding(); end

  def evaluate(context, statements, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def filter_backtrace(bt); end

  def initialize(*main); end

  def local_variable_get(name); end

  def local_variable_set(name, value); end

  def main(); end
end

class IRB::WorkSpace
end

module IRB
  def self.CurrentContext(); end

  def self.Inspector(inspect, init=T.unsafe(nil)); end

  def self.conf(); end

  def self.default_src_encoding(); end

  def self.delete_caller(); end

  def self.init_config(ap_path); end

  def self.init_error(); end

  def self.irb_abort(irb, exception=T.unsafe(nil)); end

  def self.irb_at_exit(); end

  def self.irb_exit(irb, ret); end

  def self.load_modules(); end

  def self.parse_opts(argv: T.unsafe(nil)); end

  def self.rc_file(ext=T.unsafe(nil)); end

  def self.rc_file_generators(); end

  def self.run_config(); end

  def self.setup(ap_path, argv: T.unsafe(nil)); end

  def self.start(ap_path=T.unsafe(nil)); end

  def self.version(); end
end

class Insertion
  def after(val, recursive=T.unsafe(nil)); end

  def after_any(val); end

  def before(val, recursive=T.unsafe(nil)); end

  def before_any(val); end

  def initialize(list, value); end
end

class Insertion
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  include ::ActiveSupport::NumericWithFormat
  def allbits?(_); end

  def anybits?(_); end

  def digits(*_); end

  def nobits?(_); end

  def pow(*_); end

  def to_bn(); end

  def to_d(); end
  GMP_VERSION = ::T.let(nil, ::T.untyped)
end

class Integer
  def self.sqrt(_); end
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

JSONTree = Psych::Visitors::JSONTree

module JaroWinkler
  VERSION = ::T.let(nil, ::T.untyped)
end

class JaroWinkler::Error
end

class JaroWinkler::Error
end

class JaroWinkler::InvalidWeightError
end

class JaroWinkler::InvalidWeightError
end

module JaroWinkler
  def self.distance(*_); end

  def self.jaro_distance(*_); end
end

class Jbuilder
  BLANK = ::T.let(nil, ::T.untyped)
  NON_ENUMERABLES = ::T.let(nil, ::T.untyped)
end

module Jbuilder::DependencyTrackerMethods
  DIRECT_RENDERS = ::T.let(nil, ::T.untyped)
  INDIRECT_RENDERS = ::T.let(nil, ::T.untyped)
end

module Kernel
  def gem(dep, *reqs); end

  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def then(); end

  def yield_self(); end
end

module Kernel
  def self.at_exit(); end

  def self.autoload(_, _1); end
end

class KeyError
  def key(); end

  def receiver(); end
end

module Listen
  VERSION = ::T.let(nil, ::T.untyped)
end

module Listen::Adapter
  OPTIMIZED_ADAPTERS = ::T.let(nil, ::T.untyped)
  POLLING_FALLBACK_MESSAGE = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::BSD
  BUNDLER_DECLARE_GEM = ::T.let(nil, ::T.untyped)
  DEFAULTS = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Base
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Darwin
  DEFAULTS = ::T.let(nil, ::T.untyped)
  INCOMPATIBLE_GEM_VERSION = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Linux
  DEFAULTS = ::T.let(nil, ::T.untyped)
  INOTIFY_LIMIT_MESSAGE = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
  WIKI_URL = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Polling
  DEFAULTS = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Windows
  BUNDLER_DECLARE_GEM = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

module Listen::FSM
  DEFAULT_STATE = ::T.let(nil, ::T.untyped)
end

class Listen::Listener::Config
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Listen::Record::SymlinkDetector
  SYMLINK_LOOP_ERROR = ::T.let(nil, ::T.untyped)
  WIKI = ::T.let(nil, ::T.untyped)
end

class Listen::Silencer
  DEFAULT_IGNORED_DIRECTORIES = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORED_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class LoadError
  def path(); end
end

class LocalJumpError
  def exit_value(); end

  def reason(); end
end

class Logger
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

module Loofah
  VERSION = ::T.let(nil, ::T.untyped)
end

module Loofah::Elements
  BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  LOOSE_BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL_HTML4 = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL_HTML5 = ::T.let(nil, ::T.untyped)
end

module Loofah::HTML5::SafeList
  ACCEPTABLE_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_FUNCTIONS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_KEYWORDS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_ELEMENTS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_PROTOCOLS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_SVG_PROPERTIES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_URI_DATA_MEDIATYPES = ::T.let(nil, ::T.untyped)
  ALLOWED_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_FUNCTIONS = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_KEYWORDS = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  ALLOWED_ELEMENTS = ::T.let(nil, ::T.untyped)
  ALLOWED_ELEMENTS_WITH_LIBXML2 = ::T.let(nil, ::T.untyped)
  ALLOWED_PROTOCOLS = ::T.let(nil, ::T.untyped)
  ALLOWED_SVG_PROPERTIES = ::T.let(nil, ::T.untyped)
  ALLOWED_URI_DATA_MEDIATYPES = ::T.let(nil, ::T.untyped)
  ATTR_VAL_IS_URI = ::T.let(nil, ::T.untyped)
  MATHML_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  MATHML_ELEMENTS = ::T.let(nil, ::T.untyped)
  PROTOCOL_SEPARATOR = ::T.let(nil, ::T.untyped)
  SHORTHAND_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  SVG_ALLOW_LOCAL_HREF = ::T.let(nil, ::T.untyped)
  SVG_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SVG_ATTR_VAL_ALLOWS_REF = ::T.let(nil, ::T.untyped)
  SVG_ELEMENTS = ::T.let(nil, ::T.untyped)
  TAGS_SAFE_WITH_LIBXML2 = ::T.let(nil, ::T.untyped)
  VOID_ELEMENTS = ::T.let(nil, ::T.untyped)
end

module Loofah::HTML5::Scrub
  CONTROL_CHARACTERS = ::T.let(nil, ::T.untyped)
  CRASS_SEMICOLON = ::T.let(nil, ::T.untyped)
  CSS_KEYWORDISH = ::T.let(nil, ::T.untyped)
end

Loofah::HTML5::WhiteList = Loofah::HTML5::SafeList

module Loofah::LibxmlWorkarounds
  BROKEN_ESCAPING_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  BROKEN_ESCAPING_ATTRIBUTES_QUALIFYING_TAG = ::T.let(nil, ::T.untyped)
end

class Loofah::Scrubber
  CONTINUE = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

module Loofah::Scrubbers
  MAP = ::T.let(nil, ::T.untyped)
end

module MaRuKu
  def markdown_extra?(); end

  def new_meta_data?(); end
  Abbreviation = ::T.let(nil, ::T.untyped)
  AttributeDefinitionList = ::T.let(nil, ::T.untyped)
  BLOCK_TAGS = ::T.let(nil, ::T.untyped)
  Definition = ::T.let(nil, ::T.untyped)
  EMailAddress = ::T.let(nil, ::T.untyped)
  FootnoteText = ::T.let(nil, ::T.untyped)
  Globals = ::T.let(nil, ::T.untyped)
  HTML_INLINE_ELEMS = ::T.let(nil, ::T.untyped)
  IncompleteLink = ::T.let(nil, ::T.untyped)
  InlineAttributeList = ::T.let(nil, ::T.untyped)
  LinkRegex = ::T.let(nil, ::T.untyped)
  MARUKU_URL = ::T.let(nil, ::T.untyped)
  MarukuURL = ::T.let(nil, ::T.untyped)
  S5_Fancy = ::T.let(nil, ::T.untyped)
  S5_external = ::T.let(nil, ::T.untyped)
  TableSeparator = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class MaRuKu::AttributeList
  def to_md(); end

  def to_s(); end
end

class MaRuKu::AttributeList
end

module MaRuKu::Errors
  def maruku_error(s, src=T.unsafe(nil), con=T.unsafe(nil), recover=T.unsafe(nil)); end

  def maruku_recover(s, src=T.unsafe(nil), con=T.unsafe(nil), recover=T.unsafe(nil)); end

  def raise_error(s); end

  def tell_user(s); end
  FRAME_WIDTH = ::T.let(nil, ::T.untyped)
end

module MaRuKu::Errors
end

class MaRuKu::Exception
end

class MaRuKu::Exception
end

module MaRuKu::HTMLElement
  def parsed_html(); end

  def parsed_html=(parsed_html); end
end

module MaRuKu::HTMLElement
end

module MaRuKu::HTMLFragment
end

module MaRuKu::HTMLFragment
  def self.new(raw_html); end
end

module MaRuKu::Helpers
  def md_abbr(abbr, title); end

  def md_abbr_def(abbr, text, al=T.unsafe(nil)); end

  def md_ald(id, al); end

  def md_br(); end

  def md_code(code, al=T.unsafe(nil)); end

  def md_codeblock(source, lang=T.unsafe(nil), al=T.unsafe(nil)); end

  def md_el(node_type, children=T.unsafe(nil), meta=T.unsafe(nil), al=T.unsafe(nil)); end

  def md_em(children, al=T.unsafe(nil)); end

  def md_email(email, al=T.unsafe(nil)); end

  def md_emstrong(children, al=T.unsafe(nil)); end

  def md_entity(entity_name, al=T.unsafe(nil)); end

  def md_foot_ref(ref_id, al=T.unsafe(nil)); end

  def md_footnote(footnote_id, children, al=T.unsafe(nil)); end

  def md_header(level, children, al=T.unsafe(nil)); end

  def md_hrule(); end

  def md_html(raw_html, al=T.unsafe(nil)); end

  def md_ial(al); end

  def md_im_image(children, url, title=T.unsafe(nil), al=T.unsafe(nil)); end

  def md_im_link(children, url, title=T.unsafe(nil), al=T.unsafe(nil)); end

  def md_image(children, ref_id, al=T.unsafe(nil)); end

  def md_li(children, want_my_par=T.unsafe(nil), al=T.unsafe(nil)); end

  def md_link(children, ref_id, al=T.unsafe(nil)); end

  def md_par(children, al=T.unsafe(nil)); end

  def md_quote(children, al=T.unsafe(nil)); end

  def md_ref_def(ref_id, url, title=T.unsafe(nil), meta=T.unsafe(nil), al=T.unsafe(nil)); end

  def md_strong(children, al=T.unsafe(nil)); end

  def md_url(url, al=T.unsafe(nil)); end

  def md_xml_instr(target, code); end
end

module MaRuKu::Helpers
end

module MaRuKu::In
end

module MaRuKu::In::Markdown
  def any_matching_block_extension?(line); end

  def check_block_extensions(src, con, line); end

  def check_span_extensions(src, con); end
  BlockExtensions = ::T.let(nil, ::T.untyped)
  SpanExtensions = ::T.let(nil, ::T.untyped)
  SpanExtensionsTrigger = ::T.let(nil, ::T.untyped)
end

module MaRuKu::In::Markdown::BlockLevelParser
  include ::MaRuKu::Strings
  include ::MaRuKu::In::Markdown::SpanLevelParser
  include ::MaRuKu::Helpers
  def count_columns(row); end

  def element_is_non_inline_html?(elem); end

  def eventually_comes_a_def_list(src); end

  def execute_code_blocks(); end

  def expand_attribute_list(al, result); end

  def find_colspan(al); end

  def parse_blocks(src); end

  def parse_doc(s); end

  def parse_text_as_markdown(text); end

  def pick_apart_non_inline_html(children); end

  def read_abbreviation(src); end

  def read_ald(src); end

  def read_code(src); end

  def read_definition(src); end

  def read_footnote_text(src); end

  def read_header12(src); end

  def read_header3(src); end

  def read_indented_content(src, indentation, break_list, item_type, ial_offset=T.unsafe(nil)); end

  def read_list_item(src); end

  def read_paragraph(src); end

  def read_quote(src); end

  def read_raw_html(src); end

  def read_ref_definition(src, out); end

  def read_table(src); end

  def read_text_material(src, output); end

  def read_xml_instruction(src, output); end

  def safe_execute_code(object, code); end

  def search_abbreviations(); end

  def split_cells(s, allowBlank=T.unsafe(nil)); end

  def substitute_markdown_inside_raw_html(); end
end

class MaRuKu::In::Markdown::BlockLevelParser::BlockContext
  def describe(); end
end

class MaRuKu::In::Markdown::BlockLevelParser::BlockContext
end

class MaRuKu::In::Markdown::BlockLevelParser::LineSource
  def cur_index(); end

  def cur_line(); end

  def describe(); end

  def ignore_line(); end

  def initialize(lines, parent=T.unsafe(nil), parent_offset=T.unsafe(nil)); end

  def next_line(); end

  def original_line_number(index); end

  def parent(); end

  def shift_line(); end

  def tell_me_the_future(); end
end

class MaRuKu::In::Markdown::BlockLevelParser::LineSource
end

module MaRuKu::In::Markdown::BlockLevelParser
end

module MaRuKu::In::Markdown::FencedCode
  OpenFence = ::T.let(nil, ::T.untyped)
end

module MaRuKu::In::Markdown::FencedCode
end

class MaRuKu::In::Markdown::SpanExtension
  def block(); end

  def block=(block); end

  def chars(); end

  def chars=(chars); end

  def regexp(); end

  def regexp=(regexp); end
end

class MaRuKu::In::Markdown::SpanExtension
end

module MaRuKu::In::Markdown::SpanLevelParser
  include ::MaRuKu::Helpers
  def extension_meta(src, con, break_on_chars=T.unsafe(nil)); end

  def interpret_extension(src, con, break_on_chars=T.unsafe(nil)); end

  def md_al(s=T.unsafe(nil)); end

  def merge_ial(elements, src, con); end

  def parse_span(string, parent=T.unsafe(nil)); end

  def read_attribute_list(src, con=T.unsafe(nil), break_on_chars=T.unsafe(nil)); end

  def read_em(src, delim); end

  def read_email_el(src, con); end

  def read_emstrong(src, delim); end

  def read_footnote_ref(src, con); end

  def read_image(src, con); end

  def read_inline_code(src, con); end

  def read_inline_html(src, con); end

  def read_link(src, con); end

  def read_quoted(src, con); end

  def read_quoted_or_unquoted(src, con, escaped, exit_on_chars); end

  def read_ref_id(src, con); end

  def read_simple(src, escaped, exit_on_chars=T.unsafe(nil), exit_on_strings=T.unsafe(nil), warn=T.unsafe(nil)); end

  def read_span(src, escaped, exit_on_chars=T.unsafe(nil), exit_on_strings=T.unsafe(nil)); end

  def read_strong(src, delim); end

  def read_url(src, break_on); end

  def read_url_el(src, con); end

  def read_xml_instr_span(src, con); end
  EscapedCharInInlineCode = ::T.let(nil, ::T.untyped)
  EscapedCharInQuotes = ::T.let(nil, ::T.untyped)
  EscapedCharInText = ::T.let(nil, ::T.untyped)
  IgnoreWikiLinks = ::T.let(nil, ::T.untyped)
end

MaRuKu::In::Markdown::SpanLevelParser::CharSource = MaRuKu::In::Markdown::SpanLevelParser::CharSourceManual

class MaRuKu::In::Markdown::SpanLevelParser::CharSourceDebug
  def initialize(s, parent); end

  def method_missing(methodname, *args); end
end

class MaRuKu::In::Markdown::SpanLevelParser::CharSourceDebug
end

class MaRuKu::In::Markdown::SpanLevelParser::CharSourceManual
  def consume_whitespace(); end

  def cur_char(); end

  def cur_chars(n); end

  def cur_chars_are(string); end

  def current_remaining_buffer(); end

  def describe(); end

  def describe_pos(buffer, buffer_index); end

  def ignore_char(); end

  def ignore_chars(n); end

  def initialize(s, parent=T.unsafe(nil)); end

  def next_char(); end

  def next_matches(r); end

  def read_regexp(r); end

  def shift_char(); end
end

class MaRuKu::In::Markdown::SpanLevelParser::CharSourceManual
end

class MaRuKu::In::Markdown::SpanLevelParser::CharSourceStrscan
  def consume_whitespace(); end

  def cur_char(); end

  def cur_chars(n); end

  def cur_chars_are(string); end

  def current_remaining_buffer(); end

  def describe(); end

  def ignore_char(); end

  def ignore_chars(n); end

  def initialize(s, parent=T.unsafe(nil)); end

  def next_char(); end

  def next_matches(r); end

  def read_regexp(r); end

  def shift_char(); end
end

class MaRuKu::In::Markdown::SpanLevelParser::CharSourceStrscan
end

class MaRuKu::In::Markdown::SpanLevelParser::HTMLHelper
  def eat_this(line); end

  def first_tag(); end

  def handle_tag(); end

  def is_finished?(); end

  def rest(); end

  def state(); end

  def state=(state); end

  def stuff_you_read(); end
  CData = ::T.let(nil, ::T.untyped)
  CDataEnd = ::T.let(nil, ::T.untyped)
  CommentEnd = ::T.let(nil, ::T.untyped)
  CommentStart = ::T.let(nil, ::T.untyped)
  EverythingElse = ::T.let(nil, ::T.untyped)
  PartialTag = ::T.let(nil, ::T.untyped)
  TO_SANITIZE = ::T.let(nil, ::T.untyped)
  Tag = ::T.let(nil, ::T.untyped)
end

class MaRuKu::In::Markdown::SpanLevelParser::HTMLHelper
end

class MaRuKu::In::Markdown::SpanLevelParser::SpanContext
  def describe(); end

  def elements(); end

  def elements=(elements); end

  def is_end?(); end

  def push(e); end

  def push_char(c); end

  def push_element(e); end

  def push_elements(a); end

  def push_space(); end

  def push_string_if_present(); end
end

class MaRuKu::In::Markdown::SpanLevelParser::SpanContext
end

module MaRuKu::In::Markdown::SpanLevelParser
end

module MaRuKu::In::Markdown
  def self.register_block_extension(args); end

  def self.register_span_extension(args); end
end

module MaRuKu::In
end

class MaRuKu::MDDocument
  include ::MaRuKu::In::Markdown
  include ::MaRuKu::In::Markdown::BlockLevelParser
  include ::MaRuKu::In::Markdown::SpanLevelParser
  include ::MaRuKu::Out::Latex::MDDocumentExtensions
  def abbreviations(); end

  def abbreviations=(abbreviations); end

  def ald(); end

  def ald=(ald); end

  def create_toc(); end

  def footnotes(); end

  def footnotes=(footnotes); end

  def footnotes_order(); end

  def footnotes_order=(footnotes_order); end

  def header_ids(); end

  def header_ids=(header_ids); end

  def id_counter(); end

  def id_counter=(id_counter); end

  def initialize(s=T.unsafe(nil)); end

  def old_md(context=T.unsafe(nil)); end

  def refid2ref(); end

  def refid2ref=(refid2ref); end

  def refs(); end

  def refs=(refs); end

  def s5_theme(); end

  def to_s5(context=T.unsafe(nil)); end

  def toc(); end

  def toc=(toc); end
end

class MaRuKu::MDDocument
end

class MaRuKu::MDElement
  include ::MaRuKu
  include ::MaRuKu::Out::Markdown
  include ::MaRuKu::Out::HTML
  include ::MaRuKu::Out::Latex
  include ::MaRuKu::Strings
  include ::MaRuKu::Helpers
  include ::MaRuKu::Errors
  def ==(o); end

  def al(); end

  def al=(al); end

  def attributes(); end

  def attributes=(attributes); end

  def children(); end

  def children=(children); end

  def children_to_s(); end

  def doc(); end

  def doc=(doc); end

  def each_element(e_node_type=T.unsafe(nil), &block); end

  def generate_id(); end

  def get_setting(sym); end

  def initialize(node_type=T.unsafe(nil), children=T.unsafe(nil), meta=T.unsafe(nil), al=T.unsafe(nil)); end

  def md_div(children, al=T.unsafe(nil)); end

  def meta_priv(); end

  def meta_priv=(meta_priv); end

  def node_type(); end

  def node_type=(node_type); end

  def replace_each_string(&block); end
  INSPECT_FORMS = ::T.let(nil, ::T.untyped)
end

class MaRuKu::MDElement
end

class MaRuKu::MDHTMLElement
  def parsed_html(); end

  def parsed_html=(parsed_html); end
end

class MaRuKu::MDHTMLElement
end

class MaRuKu::MDLine
  def gsub!(*args); end

  def md_type(); end

  def number_of_leading_spaces(); end
end

class MaRuKu::MDLine
end

class MaRuKu::NokogiriHTMLFragment
  def add_class(class_name); end

  def first_node_name(); end

  def initialize(raw_html); end

  def process_markdown_inside_elements(doc); end

  def to_html(); end
end

class MaRuKu::NokogiriHTMLFragment
end

module MaRuKu::Out
end

class MaRuKu::Out::Entity
  def html_entity(); end

  def html_entity=(_); end

  def html_num(); end

  def html_num=(_); end

  def latex_package(); end

  def latex_package=(_); end

  def latex_string(); end

  def latex_string=(_); end
end

class MaRuKu::Out::Entity
  def self.[](*_); end

  def self.members(); end
end

class MaRuKu::Out::EntityTable
  include ::Singleton
  def each(&blk); end

  def entity(name); end
end

class MaRuKu::Out::EntityTable
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

module MaRuKu::Out::HTML
  def add_class_to(el, cl); end

  def add_css_to(head); end

  def add_ws(e); end

  def array_to_html(array); end

  def children_to_html(); end

  def day_suffix(day); end

  def html_element(name, content=T.unsafe(nil), attributes=T.unsafe(nil)); end

  def maruku_html_signature(); end

  def nice_date(); end

  def obfuscate(s); end

  def render_footnotes(); end

  def render_section_number(); end

  def section_number(); end

  def to_html(context=T.unsafe(nil)); end

  def to_html_abbr(); end

  def to_html_cell(); end

  def to_html_code(); end

  def to_html_code_using_pre(source, code_lang=T.unsafe(nil)); end

  def to_html_definition(); end

  def to_html_definition_data(); end

  def to_html_definition_list(); end

  def to_html_definition_term(); end

  def to_html_div(); end

  def to_html_document(context=T.unsafe(nil)); end

  def to_html_document_tree(); end

  def to_html_email_address(); end

  def to_html_emphasis(); end

  def to_html_entity(); end

  def to_html_footnote_reference(); end

  def to_html_head_cell(); end

  def to_html_header(); end

  def to_html_hrule(); end

  def to_html_im_image(); end

  def to_html_im_link(); end

  def to_html_image(); end

  def to_html_immediate_link(); end

  def to_html_inline_code(); end

  def to_html_li(); end

  def to_html_linebreak(); end

  def to_html_link(); end

  def to_html_ol(); end

  def to_html_paragraph(); end

  def to_html_quote(); end

  def to_html_raw_html(); end

  def to_html_ref_definition(); end

  def to_html_strong(); end

  def to_html_table(); end

  def to_html_ul(); end

  def to_html_xml_instr(); end

  def to_latex_ref_definition(); end

  def wrap_as_element(name, attributes=T.unsafe(nil)); end

  def xelem(type); end

  def xml_newline(); end

  def xtext(text); end
  HTML4Attributes = ::T.let(nil, ::T.untyped)
  Xhtml11_mathml2_svg11 = ::T.let(nil, ::T.untyped)
end

module MaRuKu::Out::HTML
  def self.escapeHTML(text); end
end

module MaRuKu::Out::Latex
  def array_to_latex(array, join_char=T.unsafe(nil)); end

  def children_to_latex(); end

  def latex_color(s, command=T.unsafe(nil)); end

  def latex_escape(source); end

  def render_latex_signature(); end

  def string_to_latex(s); end

  def to_latex(); end

  def to_latex_abbr(); end

  def to_latex_cell(); end

  def to_latex_code(); end

  def to_latex_definition(); end

  def to_latex_definition_list(); end

  def to_latex_div(); end

  def to_latex_document(); end

  def to_latex_email_address(); end

  def to_latex_emphasis(); end

  def to_latex_entity(); end

  def to_latex_footnote_reference(); end

  def to_latex_head_cell(); end

  def to_latex_header(); end

  def to_latex_hrule(); end

  def to_latex_im_link(); end

  def to_latex_image(); end

  def to_latex_immediate_link(); end

  def to_latex_inline_code(); end

  def to_latex_li(); end

  def to_latex_linebreak(); end

  def to_latex_link(); end

  def to_latex_ol(); end

  def to_latex_paragraph(); end

  def to_latex_quote(); end

  def to_latex_raw_html(); end

  def to_latex_strong(); end

  def to_latex_table(); end

  def to_latex_ul(); end

  def wrap_as_environment(name); end

  def wrap_as_span(c); end
  LATEX_ADD_SLASH = ::T.let(nil, ::T.untyped)
  LATEX_TO_CHARCODE = ::T.let(nil, ::T.untyped)
  Latex_preamble_enc_cjk = ::T.let(nil, ::T.untyped)
  Latex_preamble_enc_utf8 = ::T.let(nil, ::T.untyped)
  OtherGoodies = ::T.let(nil, ::T.untyped)
  SAFE_CHARS = ::T.let(nil, ::T.untyped)
end

module MaRuKu::Out::Latex::MDDocumentExtensions
  def initialize(*args); end

  def latex_require_package(p); end

  def latex_required_packages(); end

  def latex_required_packages=(latex_required_packages); end
end

module MaRuKu::Out::Latex::MDDocumentExtensions
end

module MaRuKu::Out::Latex
end

module MaRuKu::Out::Markdown
  def add_indent(s, char=T.unsafe(nil)); end

  def array_to_md(array, context, join_char=T.unsafe(nil)); end

  def children_to_md(context); end

  def mysplit(c); end

  def to_md(context=T.unsafe(nil)); end

  def to_md_abbr_def(context); end

  def to_md_code(context); end

  def to_md_email_address(context); end

  def to_md_emphasis(context); end

  def to_md_entity(context); end

  def to_md_header(context); end

  def to_md_hrule(context); end

  def to_md_im_image(context); end

  def to_md_im_link(context); end

  def to_md_image(context); end

  def to_md_immediate_link(context); end

  def to_md_inline_code(context); end

  def to_md_linebreak(context); end

  def to_md_link(context); end

  def to_md_ol(context); end

  def to_md_paragraph(context); end

  def to_md_quote(context); end

  def to_md_ref_definition(context); end

  def to_md_strong(context); end

  def to_md_ul(context); end

  def wrap(array, line_length, context); end
  DefaultLineLength = ::T.let(nil, ::T.untyped)
end

module MaRuKu::Out::Markdown
end

module MaRuKu::Out
end

class MaRuKu::REXMLHTMLFragment
  def add_class(class_name); end

  def first_node_name(); end

  def initialize(raw_html); end

  def process_markdown_inside_elements(doc); end

  def to_html(); end
end

class MaRuKu::REXMLHTMLFragment
end

class MaRuKu::Section
  def _to_html(); end

  def _to_latex(); end

  def header_element(); end

  def header_element=(header_element); end

  def immediate_children(); end

  def immediate_children=(immediate_children); end

  def inspect(indent=T.unsafe(nil)); end

  def numerate(a=T.unsafe(nil)); end

  def section_children(); end

  def section_children=(section_children); end

  def section_level(); end

  def section_level=(section_level); end

  def section_number(); end

  def section_number=(section_number); end

  def to_html(); end

  def to_latex(); end
end

class MaRuKu::Section
end

module MaRuKu::Strings
  def parse_email_headers(s); end

  def sanitize_ref_id(s); end

  def spaces_before_first_char(s); end

  def split_lines(s); end

  def strip_indent(s, n); end

  def unquote(s); end
  TAB_SIZE = ::T.let(nil, ::T.untyped)
end

module MaRuKu::Strings
end

module MaRuKu
end

module Mail
  RANDOM_TAG = ::T.let(nil, ::T.untyped)
end

class Mail::AddressList
  def addresses(); end

  def addresses_grouped_by_group(); end

  def group_names(); end

  def initialize(string); end
end

class Mail::AddressList
end

class Mail::BccField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::CcField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::CommentsField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

module Mail::CommonField
  FILENAME_RE = ::T.let(nil, ::T.untyped)
end

module Mail::Constants
  ASTERISK = ::T.let(nil, ::T.untyped)
  ATOM_UNSAFE = ::T.let(nil, ::T.untyped)
  B_VALUES = ::T.let(nil, ::T.untyped)
  CAPITAL_M = ::T.let(nil, ::T.untyped)
  COLON = ::T.let(nil, ::T.untyped)
  CONTROL_CHAR = ::T.let(nil, ::T.untyped)
  CR = ::T.let(nil, ::T.untyped)
  CRLF = ::T.let(nil, ::T.untyped)
  CR_ENCODED = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ENCODED_VALUE = ::T.let(nil, ::T.untyped)
  EQUAL_LF = ::T.let(nil, ::T.untyped)
  FIELD_BODY = ::T.let(nil, ::T.untyped)
  FIELD_LINE = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
  FIELD_PREFIX = ::T.let(nil, ::T.untyped)
  FIELD_SPLIT = ::T.let(nil, ::T.untyped)
  FULL_ENCODED_VALUE = ::T.let(nil, ::T.untyped)
  FWS = ::T.let(nil, ::T.untyped)
  HEADER_LINE = ::T.let(nil, ::T.untyped)
  HEADER_SPLIT = ::T.let(nil, ::T.untyped)
  HYPHEN = ::T.let(nil, ::T.untyped)
  LF = ::T.let(nil, ::T.untyped)
  LF_ENCODED = ::T.let(nil, ::T.untyped)
  NULL_SENDER = ::T.let(nil, ::T.untyped)
  PHRASE_UNSAFE = ::T.let(nil, ::T.untyped)
  QP_SAFE = ::T.let(nil, ::T.untyped)
  QP_UNSAFE = ::T.let(nil, ::T.untyped)
  Q_VALUES = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  TOKEN_UNSAFE = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
  WSP = ::T.let(nil, ::T.untyped)
end

class Mail::ContentDescriptionField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentDispositionElement
  def disposition_type(); end

  def initialize(string); end

  def parameters(); end
end

class Mail::ContentDispositionElement
end

class Mail::ContentDispositionField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentIdField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentLocationElement
  def initialize(string); end

  def location(); end

  def to_s(*args); end
end

class Mail::ContentLocationElement
end

class Mail::ContentLocationField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentTransferEncodingElement
  def encoding(); end

  def initialize(string); end
end

class Mail::ContentTransferEncodingElement
end

class Mail::ContentTransferEncodingField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentTypeElement
  def initialize(string); end

  def main_type(); end

  def parameters(); end

  def sub_type(); end
end

class Mail::ContentTypeElement
end

class Mail::ContentTypeField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::DateField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::DateTimeElement
  def date_string(); end

  def initialize(string); end

  def time_string(); end
end

class Mail::DateTimeElement
end

class Mail::Encodings::Base64
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::Binary
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::EightBit
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::QuotedPrintable
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::SevenBit
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::TransferEncoding
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::UnixToUnix
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::EnvelopeFromElement
  def address(); end

  def date_time(); end

  def formatted_date_time(); end

  def initialize(string); end
end

class Mail::EnvelopeFromElement
end

class Mail::Exim
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::Exim
end

class Mail::Field
  FIELDS_MAP = ::T.let(nil, ::T.untyped)
  FIELD_NAME_MAP = ::T.let(nil, ::T.untyped)
  FIELD_ORDER = ::T.let(nil, ::T.untyped)
  FIELD_ORDER_LOOKUP = ::T.let(nil, ::T.untyped)
  KNOWN_FIELDS = ::T.let(nil, ::T.untyped)
  STRUCTURED_FIELDS = ::T.let(nil, ::T.untyped)
end

class Mail::FromField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::Header
  LIMITED_FIELDS = ::T.let(nil, ::T.untyped)
end

class Mail::IMAP
  def connection(&block); end

  def delete_all(mailbox=T.unsafe(nil)); end

  def find(options=T.unsafe(nil), &block); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::IMAP
end

class Mail::InReplyToField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::KeywordsField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::LoggerDelivery
  include ::Mail::CheckDeliveryParams
  def deliver!(mail); end

  def initialize(settings); end

  def logger(); end

  def settings(); end

  def severity(); end
end

class Mail::LoggerDelivery
end

class Mail::Message
  HEADER_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Mail::MessageIdField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::MessageIdsElement
  def initialize(string); end

  def message_id(); end

  def message_ids(); end
end

class Mail::MessageIdsElement
end

class Mail::MimeVersionElement
  def initialize(string); end

  def major(); end

  def minor(); end
end

class Mail::MimeVersionElement
end

class Mail::MimeVersionField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

module Mail::Multibyte
  VALID_CHARACTER = ::T.let(nil, ::T.untyped)
end

module Mail::Multibyte::Unicode
  HANGUL_JAMO_FIRST = ::T.let(nil, ::T.untyped)
  HANGUL_JAMO_LAST = ::T.let(nil, ::T.untyped)
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SLAST = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
  LEADERS_AND_TRAILERS = ::T.let(nil, ::T.untyped)
  LEADERS_PAT = ::T.let(nil, ::T.untyped)
  NORMALIZATION_FORMS = ::T.let(nil, ::T.untyped)
  TRAILERS_PAT = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  WHITESPACE = ::T.let(nil, ::T.untyped)
end

class Mail::Multibyte::Unicode::UnicodeDatabase
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class Mail::OptionalField
end

class Mail::OptionalField
end

class Mail::POP3
  def connection(&block); end

  def delete_all(); end

  def find(options=T.unsafe(nil), &block); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::POP3
end

class Mail::PhraseList
  def initialize(string); end

  def phrases(); end
end

class Mail::PhraseList
end

class Mail::ReceivedElement
  include ::Mail::Utilities
  include ::Mail::Constants
  def date_time(); end

  def info(); end

  def initialize(string); end

  def to_s(*args); end
end

class Mail::ReceivedElement
end

class Mail::ReceivedField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReferencesField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReplyToField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentBccField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentCcField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentDateField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentFromField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentMessageIdField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentSenderField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentToField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReturnPathField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

Mail::RubyVer = Mail::Ruby19

class Mail::SMTP
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::SMTPConnection
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end

  def smtp(); end

  def smtp=(smtp); end
end

class Mail::SMTPConnection
end

class Mail::SenderField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::Sendmail
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::SubjectField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::TestRetriever
  def find(options=T.unsafe(nil), &block); end

  def initialize(values); end
end

class Mail::TestRetriever
  def self.emails(); end

  def self.emails=(val); end
end

class Mail::ToField
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

module Mail::Utilities
  CRLF = ::T.let(nil, ::T.untyped)
  LF = ::T.let(nil, ::T.untyped)
  TO_CRLF_REGEX = ::T.let(nil, ::T.untyped)
end

module Mail::VERSION
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
end

module Marcel
  VERSION = ::T.let(nil, ::T.untyped)
end

class Marcel::MimeType
  BINARY = ::T.let(nil, ::T.untyped)
end

class Marcel::MimeType
  def self.extend(type, extensions: T.unsafe(nil), parents: T.unsafe(nil), magic: T.unsafe(nil)); end

  def self.for(pathname_or_io=T.unsafe(nil), name: T.unsafe(nil), extension: T.unsafe(nil), declared_type: T.unsafe(nil)); end
end

module Marshal
  extend ::ActiveSupport::MarshalWithAutoloading
  def self.restore(*_); end
end

class Maruku
  def initialize(s=T.unsafe(nil), meta=T.unsafe(nil)); end
end

class Maruku
end

class Matrix
  include ::Enumerable
  include ::ExceptionForMatrix
  include ::Matrix::CoercionHelper
  def *(m); end

  def **(other); end

  def +(m); end

  def +@(); end

  def -(m); end

  def -@(); end

  def /(other); end

  def ==(other); end

  def [](i, j); end

  def []=(i, j, v); end

  def adjugate(); end

  def antisymmetric?(); end

  def coerce(other); end

  def cofactor(row, column); end

  def cofactor_expansion(row: T.unsafe(nil), column: T.unsafe(nil)); end

  def collect(which=T.unsafe(nil), &block); end

  def collect!(which=T.unsafe(nil)); end

  def column(j); end

  def column_count(); end

  def column_size(); end

  def column_vectors(); end

  def combine(*matrices, &block); end

  def component(i, j); end

  def conj(); end

  def conjugate(); end

  def det(); end

  def det_e(); end

  def determinant(); end

  def determinant_e(); end

  def diagonal?(); end

  def each(which=T.unsafe(nil), &blk); end

  def each_with_index(which=T.unsafe(nil)); end

  def eigen(); end

  def eigensystem(); end

  def element(i, j); end

  def elements_to_f(); end

  def elements_to_i(); end

  def elements_to_r(); end

  def empty?(); end

  def entrywise_product(m); end

  def eql?(other); end

  def find_index(*args); end

  def first_minor(row, column); end

  def hadamard_product(m); end

  def hermitian?(); end

  def hstack(*matrices); end

  def imag(); end

  def imaginary(); end

  def index(*args); end

  def initialize(rows, column_count=T.unsafe(nil)); end

  def inv(); end

  def inverse(); end

  def laplace_expansion(row: T.unsafe(nil), column: T.unsafe(nil)); end

  def lower_triangular?(); end

  def lup(); end

  def lup_decomposition(); end

  def map(which=T.unsafe(nil), &block); end

  def map!(which=T.unsafe(nil)); end

  def minor(*param); end

  def normal?(); end

  def orthogonal?(); end

  def permutation?(); end

  def rank(); end

  def rank_e(); end

  def real(); end

  def real?(); end

  def rect(); end

  def rectangular(); end

  def regular?(); end

  def round(ndigits=T.unsafe(nil)); end

  def row(i, &block); end

  def row_count(); end

  def row_size(); end

  def row_vectors(); end

  def rows(); end

  def singular?(); end

  def skew_symmetric?(); end

  def square?(); end

  def symmetric?(); end

  def t(); end

  def to_a(); end

  def to_matrix(); end

  def tr(); end

  def trace(); end

  def transpose(); end

  def unitary?(); end

  def upper_triangular?(); end

  def vstack(*matrices); end

  def zero?(); end
  SELECTORS = ::T.let(nil, ::T.untyped)
end

module Matrix::CoercionHelper
end

module Matrix::CoercionHelper
  def self.check_int(val, count, kind); end

  def self.check_range(val, count, kind); end

  def self.coerce_to(obj, cls, meth); end

  def self.coerce_to_int(obj); end

  def self.coerce_to_matrix(obj); end
end

module Matrix::ConversionHelper
end

module Matrix::ConversionHelper
end

class Matrix::EigenvalueDecomposition
  def d(); end

  def eigenvalue_matrix(); end

  def eigenvalues(); end

  def eigenvector_matrix(); end

  def eigenvector_matrix_inv(); end

  def eigenvectors(); end

  def initialize(a); end

  def to_a(); end

  def to_ary(); end

  def v(); end

  def v_inv(); end
end

class Matrix::EigenvalueDecomposition
end

class Matrix::LUPDecomposition
  include ::Matrix::ConversionHelper
  def det(); end

  def determinant(); end

  def initialize(a); end

  def l(); end

  def p(); end

  def pivots(); end

  def singular?(); end

  def solve(b); end

  def to_a(); end

  def to_ary(); end

  def u(); end
end

class Matrix::LUPDecomposition
end

class Matrix::Scalar
  include ::ExceptionForMatrix
  include ::Matrix::CoercionHelper
  def *(other); end

  def **(other); end

  def +(other); end

  def -(other); end

  def /(other); end

  def initialize(value); end
end

class Matrix::Scalar
  extend ::Exception2MessageMapper
  def self.included(mod); end
end

class Matrix
  extend ::Exception2MessageMapper
  extend ::Matrix::ConversionHelper
  def self.I(n); end

  def self.[](*rows); end

  def self.build(row_count, column_count=T.unsafe(nil)); end

  def self.column_vector(column); end

  def self.columns(columns); end

  def self.combine(*matrices); end

  def self.diagonal(*values); end

  def self.empty(row_count=T.unsafe(nil), column_count=T.unsafe(nil)); end

  def self.hstack(x, *matrices); end

  def self.identity(n); end

  def self.included(mod); end

  def self.row_vector(row); end

  def self.rows(rows, copy=T.unsafe(nil)); end

  def self.scalar(n, value); end

  def self.unit(n); end

  def self.vstack(x, *matrices); end

  def self.zero(row_count, column_count=T.unsafe(nil)); end
end

module MessagePack
  DEFAULT_EMPTY_PARAMS = ::T.let(nil, ::T.untyped)
end

module MessagePack::Time
  Packer = ::T.let(nil, ::T.untyped)
  TIME_AT_3_AVAILABLE = ::T.let(nil, ::T.untyped)
  Unpacker = ::T.let(nil, ::T.untyped)
end

class MessagePack::Timestamp
  TIMESTAMP32_MAX_SEC = ::T.let(nil, ::T.untyped)
  TIMESTAMP64_MAX_SEC = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
end

module MethodSource
  VERSION = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers::IncompleteExpression
  GENERIC_REGEXPS = ::T.let(nil, ::T.untyped)
  RBX_ONLY_REGEXPS = ::T.let(nil, ::T.untyped)
end

Methods = T::Private::Methods

module Mime
  ALL = ::T.let(nil, ::T.untyped)
  EXTENSION_LOOKUP = ::T.let(nil, ::T.untyped)
  LOOKUP = ::T.let(nil, ::T.untyped)
  SET = ::T.let(nil, ::T.untyped)
end

class Mime::Type
  MIME_NAME = ::T.let(nil, ::T.untyped)
  MIME_PARAMETER = ::T.let(nil, ::T.untyped)
  MIME_PARAMETER_KEY = ::T.let(nil, ::T.untyped)
  MIME_PARAMETER_VALUE = ::T.let(nil, ::T.untyped)
  MIME_REGEXP = ::T.let(nil, ::T.untyped)
end

module MiniMime
  VERSION = ::T.let(nil, ::T.untyped)
end

class MiniMime::Db
  LOCK = ::T.let(nil, ::T.untyped)
end

class MiniMime::Db::RandomAccessDb
  MAX_CACHED = ::T.let(nil, ::T.untyped)
end

class MiniMime::Info
  BINARY_ENCODINGS = ::T.let(nil, ::T.untyped)
end

module Minitest
end

MiniTest::Assertions = Minitest::Assertions

MiniTest::Guard = Minitest::Guard

MiniTest::Reportable = Minitest::Reportable

MiniTest::Runnable = Minitest::Runnable

MiniTest::Test = Minitest::Test

module Minitest
end

module Minitest
  ENCS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Minitest::Assertions
  E = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

class Minitest::BacktraceFilter
  MT_RE = ::T.let(nil, ::T.untyped)
end

class Minitest::Runnable
  SIGNALS = ::T.let(nil, ::T.untyped)
end

class Minitest::Test
  PASSTHROUGH_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  TEARDOWN_METHODS = ::T.let(nil, ::T.untyped)
end

class Minitest::Unit
  VERSION = ::T.let(nil, ::T.untyped)
end

class Module
  def class_name(); end

  def deprecate_constant(*_); end

  def undef_method(*_); end
  DELEGATION_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
  DELEGATION_RESERVED_METHOD_NAMES = ::T.let(nil, ::T.untyped)
  RUBY_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
end

class Module
  def self.used_modules(); end
end

class Monitor
  def enter(); end

  def exit(); end

  def try_enter(); end
end

module MonitorMixin
  def initialize(*args); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_mon_enter(); end
end

class MonitorMixin::ConditionVariable
  def broadcast(); end

  def initialize(monitor); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(); end

  def wait_while(); end
end

module MonitorMixin
  def self.extend_object(obj); end
end

module Mutex_m
  VERSION = ::T.let(nil, ::T.untyped)
end

module NIO
  ENGINE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class NIO::ByteBuffer
  include ::Enumerable
end

class NIO::ByteBuffer::MarkUnsetError
end

class NIO::ByteBuffer::MarkUnsetError
end

class NIO::ByteBuffer::OverflowError
end

class NIO::ByteBuffer::OverflowError
end

class NIO::ByteBuffer::UnderflowError
end

class NIO::ByteBuffer::UnderflowError
end

class NameError
  def name(); end

  def receiver(); end
end

class Net::APOP
end

class Net::APOP
end

Net::APOPSession = Net::APOP

class Net::BufferedIO
  def write_timeout(); end

  def write_timeout=(write_timeout); end
end

class Net::HTTP
  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def write_timeout(); end

  def write_timeout=(sec); end
  ENVIRONMENT_VARIABLE_IS_MULTIUSER_SAFE = ::T.let(nil, ::T.untyped)
end

Net::HTTP::ProxyMod = Net::HTTP::ProxyDelta

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

class Net::HTTPClientError
end

Net::HTTPClientErrorCode::EXCEPTION_TYPE = Net::HTTPServerException

class Net::HTTPClientError
end

Net::HTTPClientException = Net::HTTPServerException

class Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPEarlyHints
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

class Net::HTTPGatewayTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPGatewayTimeout
end

class Net::HTTPInformation
end

Net::HTTPInformationCode::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPInformation
end

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPayloadTooLarge
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRangeNotSatisfiable
end

Net::HTTPRedirectionCode = Net::HTTPRedirection

class Net::HTTPRequestTimeout
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRequestTimeout
end

Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

class Net::HTTPRedirection
end

Net::HTTPRetriableCode::EXCEPTION_TYPE = Net::HTTPRetriableError

class Net::HTTPRedirection
end

class Net::HTTPServerError
end

Net::HTTPServerErrorCode::EXCEPTION_TYPE = Net::HTTPFatalError

class Net::HTTPServerError
end

Net::HTTPSession = Net::HTTP

class Net::HTTPSuccess
end

Net::HTTPSuccessCode::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPSuccess
end

class Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPURITooLong
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

class Net::IMAP
  def open_timeout(); end

  RESPONSE_ERRORS = ::T.let(nil, ::T.untyped)
end

module Net::IMAP::NumValidator
  def self.ensure_mod_sequence_value(num); end

  def self.valid_mod_sequence_value?(num); end
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::POP = Net::POP3

class Net::POP3
  def active?(); end

  def address(); end

  def apop?(); end

  def auth_only(account, password); end

  def delete_all(); end

  def disable_ssl(); end

  def each(&block); end

  def each_mail(&block); end

  def enable_ssl(verify_or_params=T.unsafe(nil), certs=T.unsafe(nil), port=T.unsafe(nil)); end

  def finish(); end

  def initialize(addr, port=T.unsafe(nil), isapop=T.unsafe(nil)); end

  def logging(msg); end

  def mails(); end

  def n_bytes(); end

  def n_mails(); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def port(); end

  def read_timeout(); end

  def read_timeout=(sec); end

  def reset(); end

  def set_all_uids(); end

  def set_debug_output(arg); end

  def start(account, password); end

  def started?(); end

  def use_ssl?(); end
  Revision = ::T.let(nil, ::T.untyped)
end

class Net::POP3
  def self.APOP(isapop); end

  def self.auth_only(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil)); end

  def self.certs(); end

  def self.create_ssl_params(verify_or_params=T.unsafe(nil), certs=T.unsafe(nil)); end

  def self.default_pop3_port(); end

  def self.default_pop3s_port(); end

  def self.default_port(); end

  def self.delete_all(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.disable_ssl(); end

  def self.enable_ssl(*args); end

  def self.foreach(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.socket_type(); end

  def self.ssl_params(); end

  def self.start(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.use_ssl?(); end

  def self.verify(); end
end

class Net::POP3Command
  def apop(account, password); end

  def auth(account, password); end

  def dele(num); end

  def initialize(sock); end

  def list(); end

  def quit(); end

  def retr(num, &block); end

  def rset(); end

  def socket(); end

  def stat(); end

  def top(num, lines=T.unsafe(nil), &block); end

  def uidl(num=T.unsafe(nil)); end
end

class Net::POP3Command
end

Net::POP3Session = Net::POP3

class Net::POPAuthenticationError
end

class Net::POPAuthenticationError
end

class Net::POPBadResponse
end

class Net::POPBadResponse
end

class Net::POPError
end

class Net::POPError
end

class Net::POPMail
  def all(dest=T.unsafe(nil), &block); end

  def delete(); end

  def delete!(); end

  def deleted?(); end

  def header(dest=T.unsafe(nil)); end

  def initialize(num, len, pop, cmd); end

  def length(); end

  def mail(dest=T.unsafe(nil), &block); end

  def number(); end

  def pop(dest=T.unsafe(nil), &block); end

  def size(); end

  def top(lines, dest=T.unsafe(nil)); end

  def uid=(uid); end

  def uidl(); end

  def unique_id(); end
end

class Net::POPMail
end

Net::POPSession = Net::POP3

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

Net::SMTPSession = Net::SMTP

class Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Net::WriteTimeout
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  def to_d(); end

  def to_i(); end
end

class NoMethodError
  def args(); end

  def private_call?(); end
end

module Nokogiri
  LIBXML_ICONV_ENABLED = ::T.let(nil, ::T.untyped)
  LIBXML_PARSER_VERSION = ::T.let(nil, ::T.untyped)
  LIBXML_VERSION = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXML2_PATCHES = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXML2_PATH = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXSLT_PATCHES = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXSLT_PATH = ::T.let(nil, ::T.untyped)
  NOKOGIRI_USE_PACKAGED_LIBRARIES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_INFO = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Node
  ALLOW_COMBINATOR_ON_SELF = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Parser
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

module Nokogiri::Decorators::Slop
  XPATH_PREFIX = ::T.let(nil, ::T.untyped)
end

module Nokogiri::HTML
  NamedCharacters = ::T.let(nil, ::T.untyped)
end

class Nokogiri::HTML::ElementDescription
  ACTION_ATTR = ::T.let(nil, ::T.untyped)
  ALIGN_ATTR = ::T.let(nil, ::T.untyped)
  ALT_ATTR = ::T.let(nil, ::T.untyped)
  APPLET_ATTRS = ::T.let(nil, ::T.untyped)
  AREA_ATTRS = ::T.let(nil, ::T.untyped)
  ATTRS = ::T.let(nil, ::T.untyped)
  A_ATTRS = ::T.let(nil, ::T.untyped)
  BASEFONT_ATTRS = ::T.let(nil, ::T.untyped)
  BGCOLOR_ATTR = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  BLOCKLI_ELT = ::T.let(nil, ::T.untyped)
  BODY_ATTRS = ::T.let(nil, ::T.untyped)
  BODY_CONTENTS = ::T.let(nil, ::T.untyped)
  BODY_DEPR = ::T.let(nil, ::T.untyped)
  BUTTON_ATTRS = ::T.let(nil, ::T.untyped)
  CELLHALIGN = ::T.let(nil, ::T.untyped)
  CELLVALIGN = ::T.let(nil, ::T.untyped)
  CLEAR_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ELT = ::T.let(nil, ::T.untyped)
  COMPACT_ATTR = ::T.let(nil, ::T.untyped)
  COMPACT_ATTRS = ::T.let(nil, ::T.untyped)
  CONTENT_ATTR = ::T.let(nil, ::T.untyped)
  COREATTRS = ::T.let(nil, ::T.untyped)
  CORE_ATTRS = ::T.let(nil, ::T.untyped)
  CORE_I18N_ATTRS = ::T.let(nil, ::T.untyped)
  DIR_ATTR = ::T.let(nil, ::T.untyped)
  DL_CONTENTS = ::T.let(nil, ::T.untyped)
  DefaultDescriptions = ::T.let(nil, ::T.untyped)
  EDIT_ATTRS = ::T.let(nil, ::T.untyped)
  EMBED_ATTRS = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  EVENTS = ::T.let(nil, ::T.untyped)
  FIELDSET_CONTENTS = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
  FLOW_PARAM = ::T.let(nil, ::T.untyped)
  FONTSTYLE = ::T.let(nil, ::T.untyped)
  FONT_ATTRS = ::T.let(nil, ::T.untyped)
  FORMCTRL = ::T.let(nil, ::T.untyped)
  FORM_ATTRS = ::T.let(nil, ::T.untyped)
  FORM_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAMESET_ATTRS = ::T.let(nil, ::T.untyped)
  FRAMESET_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAME_ATTRS = ::T.let(nil, ::T.untyped)
  HEADING = ::T.let(nil, ::T.untyped)
  HEAD_ATTRS = ::T.let(nil, ::T.untyped)
  HEAD_CONTENTS = ::T.let(nil, ::T.untyped)
  HREF_ATTRS = ::T.let(nil, ::T.untyped)
  HR_DEPR = ::T.let(nil, ::T.untyped)
  HTML_ATTRS = ::T.let(nil, ::T.untyped)
  HTML_CDATA = ::T.let(nil, ::T.untyped)
  HTML_CONTENT = ::T.let(nil, ::T.untyped)
  HTML_FLOW = ::T.let(nil, ::T.untyped)
  HTML_INLINE = ::T.let(nil, ::T.untyped)
  HTML_PCDATA = ::T.let(nil, ::T.untyped)
  I18N = ::T.let(nil, ::T.untyped)
  I18N_ATTRS = ::T.let(nil, ::T.untyped)
  IFRAME_ATTRS = ::T.let(nil, ::T.untyped)
  IMG_ATTRS = ::T.let(nil, ::T.untyped)
  INLINE = ::T.let(nil, ::T.untyped)
  INLINE_P = ::T.let(nil, ::T.untyped)
  INPUT_ATTRS = ::T.let(nil, ::T.untyped)
  LABEL_ATTR = ::T.let(nil, ::T.untyped)
  LABEL_ATTRS = ::T.let(nil, ::T.untyped)
  LANGUAGE_ATTR = ::T.let(nil, ::T.untyped)
  LEGEND_ATTRS = ::T.let(nil, ::T.untyped)
  LINK_ATTRS = ::T.let(nil, ::T.untyped)
  LIST = ::T.let(nil, ::T.untyped)
  LI_ELT = ::T.let(nil, ::T.untyped)
  MAP_CONTENTS = ::T.let(nil, ::T.untyped)
  META_ATTRS = ::T.let(nil, ::T.untyped)
  MODIFIER = ::T.let(nil, ::T.untyped)
  NAME_ATTR = ::T.let(nil, ::T.untyped)
  NOFRAMES_CONTENT = ::T.let(nil, ::T.untyped)
  OBJECT_ATTRS = ::T.let(nil, ::T.untyped)
  OBJECT_CONTENTS = ::T.let(nil, ::T.untyped)
  OBJECT_DEPR = ::T.let(nil, ::T.untyped)
  OL_ATTRS = ::T.let(nil, ::T.untyped)
  OPTGROUP_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ELT = ::T.let(nil, ::T.untyped)
  PARAM_ATTRS = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PHRASE = ::T.let(nil, ::T.untyped)
  PRE_CONTENT = ::T.let(nil, ::T.untyped)
  PROMPT_ATTRS = ::T.let(nil, ::T.untyped)
  QUOTE_ATTRS = ::T.let(nil, ::T.untyped)
  ROWS_COLS_ATTR = ::T.let(nil, ::T.untyped)
  SCRIPT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_CONTENT = ::T.let(nil, ::T.untyped)
  SPECIAL = ::T.let(nil, ::T.untyped)
  SRC_ALT_ATTRS = ::T.let(nil, ::T.untyped)
  STYLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_CONTENTS = ::T.let(nil, ::T.untyped)
  TABLE_DEPR = ::T.let(nil, ::T.untyped)
  TALIGN_ATTRS = ::T.let(nil, ::T.untyped)
  TARGET_ATTR = ::T.let(nil, ::T.untyped)
  TEXTAREA_ATTRS = ::T.let(nil, ::T.untyped)
  TH_TD_ATTR = ::T.let(nil, ::T.untyped)
  TH_TD_DEPR = ::T.let(nil, ::T.untyped)
  TR_CONTENTS = ::T.let(nil, ::T.untyped)
  TR_ELT = ::T.let(nil, ::T.untyped)
  TYPE_ATTR = ::T.let(nil, ::T.untyped)
  UL_DEPR = ::T.let(nil, ::T.untyped)
  VERSION_ATTR = ::T.let(nil, ::T.untyped)
  WIDTH_ATTR = ::T.let(nil, ::T.untyped)
end

Nokogiri::HTML::ElementDescription::Desc = Struct::HTMLElementDescription

module Nokogiri::XML
  XML_C14N_1_0 = ::T.let(nil, ::T.untyped)
  XML_C14N_1_1 = ::T.let(nil, ::T.untyped)
  XML_C14N_EXCLUSIVE_1_0 = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Document
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NCNAME_CHAR = ::T.let(nil, ::T.untyped)
  NCNAME_RE = ::T.let(nil, ::T.untyped)
  NCNAME_START_CHAR = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::ElementContent
  ELEMENT = ::T.let(nil, ::T.untyped)
  MULT = ::T.let(nil, ::T.untyped)
  ONCE = ::T.let(nil, ::T.untyped)
  OPT = ::T.let(nil, ::T.untyped)
  OR = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PLUS = ::T.let(nil, ::T.untyped)
  SEQ = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::EntityDecl
  EXTERNAL_GENERAL_PARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_GENERAL_UNPARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_GENERAL = ::T.let(nil, ::T.untyped)
  INTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_PREDEFINED = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Node
  ATTRIBUTE_DECL = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_NODE = ::T.let(nil, ::T.untyped)
  CDATA_SECTION_NODE = ::T.let(nil, ::T.untyped)
  COMMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCB_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_FRAG_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_TYPE_NODE = ::T.let(nil, ::T.untyped)
  DTD_NODE = ::T.let(nil, ::T.untyped)
  ELEMENT_DECL = ::T.let(nil, ::T.untyped)
  ELEMENT_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_DECL = ::T.let(nil, ::T.untyped)
  ENTITY_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_REF_NODE = ::T.let(nil, ::T.untyped)
  HTML_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NAMESPACE_DECL = ::T.let(nil, ::T.untyped)
  NOTATION_NODE = ::T.let(nil, ::T.untyped)
  PI_NODE = ::T.let(nil, ::T.untyped)
  TEXT_NODE = ::T.let(nil, ::T.untyped)
  XINCLUDE_END = ::T.let(nil, ::T.untyped)
  XINCLUDE_START = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::NodeSet
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::ParseOptions
  COMPACT = ::T.let(nil, ::T.untyped)
  DEFAULT_HTML = ::T.let(nil, ::T.untyped)
  DEFAULT_XML = ::T.let(nil, ::T.untyped)
  DTDATTR = ::T.let(nil, ::T.untyped)
  DTDLOAD = ::T.let(nil, ::T.untyped)
  DTDVALID = ::T.let(nil, ::T.untyped)
  HUGE = ::T.let(nil, ::T.untyped)
  NOBASEFIX = ::T.let(nil, ::T.untyped)
  NOBLANKS = ::T.let(nil, ::T.untyped)
  NOCDATA = ::T.let(nil, ::T.untyped)
  NODICT = ::T.let(nil, ::T.untyped)
  NOENT = ::T.let(nil, ::T.untyped)
  NOERROR = ::T.let(nil, ::T.untyped)
  NONET = ::T.let(nil, ::T.untyped)
  NOWARNING = ::T.let(nil, ::T.untyped)
  NOXINCNODE = ::T.let(nil, ::T.untyped)
  NSCLEAN = ::T.let(nil, ::T.untyped)
  OLD10 = ::T.let(nil, ::T.untyped)
  PEDANTIC = ::T.let(nil, ::T.untyped)
  RECOVER = ::T.let(nil, ::T.untyped)
  SAX1 = ::T.let(nil, ::T.untyped)
  STRICT = ::T.let(nil, ::T.untyped)
  XINCLUDE = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Reader
  TYPE_ATTRIBUTE = ::T.let(nil, ::T.untyped)
  TYPE_CDATA = ::T.let(nil, ::T.untyped)
  TYPE_COMMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_FRAGMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_TYPE = ::T.let(nil, ::T.untyped)
  TYPE_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY_REFERENCE = ::T.let(nil, ::T.untyped)
  TYPE_NONE = ::T.let(nil, ::T.untyped)
  TYPE_NOTATION = ::T.let(nil, ::T.untyped)
  TYPE_PROCESSING_INSTRUCTION = ::T.let(nil, ::T.untyped)
  TYPE_SIGNIFICANT_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_TEXT = ::T.let(nil, ::T.untyped)
  TYPE_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_XML_DECLARATION = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::SAX::Parser
  ENCODINGS = ::T.let(nil, ::T.untyped)
end

module Nokogiri::XML::Searchable
  LOOKS_LIKE_XPATH = ::T.let(nil, ::T.untyped)
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::PP::ObjectMixin
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::ActiveSupport::Dependencies::ZeitwerkIntegration::RequireDependency
  def dclone(); end

  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  CloseDiv = ::T.let(nil, ::T.untyped)
  DecorativeClosing = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  OpenDiv = ::T.let(nil, ::T.untyped)
  RUBY18 = ::T.let(nil, ::T.untyped)
  RUBY19 = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  StartPipe = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class ObjectSpace::WeakMap
  def [](_); end

  def []=(_, _1); end

  def each(&blk); end

  def each_key(); end

  def each_pair(); end

  def each_value(); end

  def key?(_); end

  def keys(); end

  def length(); end

  def size(); end

  def values(); end
end

module ObjectSpace
  def self.count_objects(*_); end

  def self.define_finalizer(*_); end

  def self.garbage_collect(*_); end

  def self.undefine_finalizer(_); end
end

module Observable
  def add_observer(observer, func=T.unsafe(nil)); end

  def changed(state=T.unsafe(nil)); end

  def changed?(); end

  def count_observers(); end

  def delete_observer(observer); end

  def delete_observers(); end

  def notify_observers(*arg); end
end

module Observable
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(_); end

  def negative?(); end
end

module OpenSSL::Buffering
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  def self.hkdf(*_); end

  def self.pbkdf2_hmac(*_); end

  def self.scrypt(*_); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def to_octet_string(_); end
end

class OpenSSL::PKey::RSA
  def sign_pss(*_); end

  def verify_pss(*_); end
end

module OpenSSL::SSL
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

module OpenSSL::X509
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  def ==(other); end
end

class OpenSSL::X509::CRL
  def ==(other); end
end

class OpenSSL::X509::Extension
  def ==(other); end
end

class OpenSSL::X509::Name
  def to_utf8(); end
end

class OpenSSL::X509::Request
  def ==(other); end
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

module OpenURI
  Options = ::T.let(nil, ::T.untyped)
end

class OpenURI::Buffer
  def <<(str); end

  def io(); end

  def size(); end
  StringMax = ::T.let(nil, ::T.untyped)
end

class OpenURI::Buffer
end

class OpenURI::HTTPError
  def initialize(message, io); end

  def io(); end
end

class OpenURI::HTTPError
end

class OpenURI::HTTPRedirect
  def initialize(message, io, uri); end

  def uri(); end
end

class OpenURI::HTTPRedirect
end

module OpenURI::Meta
  def base_uri(); end

  def base_uri=(base_uri); end

  def charset(); end

  def content_encoding(); end

  def content_type(); end

  def content_type_parse(); end

  def last_modified(); end

  def meta(); end

  def meta_add_field(name, value); end

  def meta_add_field2(name, values); end

  def meta_setup_encoding(); end

  def metas(); end

  def status(); end

  def status=(status); end
  RE_LWS = ::T.let(nil, ::T.untyped)
  RE_PARAMETERS = ::T.let(nil, ::T.untyped)
  RE_QUOTED_STRING = ::T.let(nil, ::T.untyped)
  RE_TOKEN = ::T.let(nil, ::T.untyped)
end

module OpenURI::Meta
  def self.init(obj, src=T.unsafe(nil)); end
end

module OpenURI::OpenRead
  def open(*rest, &block); end

  def read(options=T.unsafe(nil)); end
end

module OpenURI::OpenRead
end

module OpenURI
  def self.check_options(options); end

  def self.open_http(buf, target, proxy, options); end

  def self.open_loop(uri, options); end

  def self.open_uri(name, *rest); end

  def self.redirectable?(uri1, uri2); end

  def self.scan_open_optional_arguments(*rest); end
end

module PG
  include ::PG::Constants
  ERROR_CLASSES = ::T.let(nil, ::T.untyped)
  REVISION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class PG::ActiveSqlTransaction
end

class PG::ActiveSqlTransaction
end

class PG::AdminShutdown
end

class PG::AdminShutdown
end

class PG::AmbiguousAlias
end

class PG::AmbiguousAlias
end

class PG::AmbiguousColumn
end

class PG::AmbiguousColumn
end

class PG::AmbiguousFunction
end

class PG::AmbiguousFunction
end

class PG::AmbiguousParameter
end

class PG::AmbiguousParameter
end

class PG::ArraySubscriptError
end

class PG::ArraySubscriptError
end

class PG::AssertFailure
end

class PG::AssertFailure
end

class PG::BadCopyFileFormat
end

class PG::BadCopyFileFormat
end

class PG::BasicTypeMapForQueries
  DEFAULT_ARRAY_TYPE_MAP = ::T.let(nil, ::T.untyped)
  DEFAULT_TYPE_MAP = ::T.let(nil, ::T.untyped)
end

module PG::BasicTypeRegistry
  CODERS_BY_NAME = ::T.let(nil, ::T.untyped)
  ValidDirections = ::T.let(nil, ::T.untyped)
  ValidFormats = ::T.let(nil, ::T.untyped)
end

class PG::BasicTypeRegistry::CoderMap
  DONT_QUOTE_TYPES = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Boolean
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Bytea
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Float
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Integer
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::String
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Timestamp
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::ToBase64
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Boolean
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Bytea
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::FromBase64
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Int2
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Int4
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Int8
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::String
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BranchTransactionAlreadyActive
end

class PG::BranchTransactionAlreadyActive
end

class PG::CannotCoerce
end

class PG::CannotCoerce
end

class PG::CannotConnectNow
end

class PG::CannotConnectNow
end

class PG::CantChangeRuntimeParam
end

class PG::CantChangeRuntimeParam
end

class PG::CardinalityViolation
end

class PG::CardinalityViolation
end

class PG::CaseNotFound
end

class PG::CaseNotFound
end

class PG::CharacterNotInRepertoire
end

class PG::CharacterNotInRepertoire
end

class PG::CheckViolation
end

class PG::CheckViolation
end

class PG::Coder
  FORMAT_ERROR_MASK = ::T.let(nil, ::T.untyped)
  FORMAT_ERROR_TO_PARTIAL = ::T.let(nil, ::T.untyped)
  FORMAT_ERROR_TO_RAISE = ::T.let(nil, ::T.untyped)
  FORMAT_ERROR_TO_STRING = ::T.let(nil, ::T.untyped)
  TIMESTAMP_APP_LOCAL = ::T.let(nil, ::T.untyped)
  TIMESTAMP_APP_UTC = ::T.let(nil, ::T.untyped)
  TIMESTAMP_DB_LOCAL = ::T.let(nil, ::T.untyped)
  TIMESTAMP_DB_UTC = ::T.let(nil, ::T.untyped)
end

module PG::Coder::BinaryFormatting
  Params = ::T.let(nil, ::T.untyped)
end

class PG::CollationMismatch
end

class PG::CollationMismatch
end

class PG::CompositeDecoder
end

class PG::CompositeDecoder
end

class PG::CompositeEncoder
end

class PG::CompositeEncoder
end

class PG::ConfigFileError
end

class PG::ConfigFileError
end

class PG::ConfigurationLimitExceeded
end

class PG::ConfigurationLimitExceeded
end

class PG::Connection
  include ::PG::Constants
  CONNECT_ARGUMENT_ORDER = ::T.let(nil, ::T.untyped)
  REDIRECT_METHODS = ::T.let(nil, ::T.untyped)
end

class PG::ConnectionBad
end

class PG::ConnectionBad
end

class PG::ConnectionDoesNotExist
end

class PG::ConnectionDoesNotExist
end

class PG::ConnectionException
end

class PG::ConnectionException
end

class PG::ConnectionFailure
end

class PG::ConnectionFailure
end

module PG::Constants
  CONNECTION_AUTH_OK = ::T.let(nil, ::T.untyped)
  CONNECTION_AWAITING_RESPONSE = ::T.let(nil, ::T.untyped)
  CONNECTION_BAD = ::T.let(nil, ::T.untyped)
  CONNECTION_MADE = ::T.let(nil, ::T.untyped)
  CONNECTION_NEEDED = ::T.let(nil, ::T.untyped)
  CONNECTION_OK = ::T.let(nil, ::T.untyped)
  CONNECTION_SETENV = ::T.let(nil, ::T.untyped)
  CONNECTION_SSL_STARTUP = ::T.let(nil, ::T.untyped)
  CONNECTION_STARTED = ::T.let(nil, ::T.untyped)
  INVALID_OID = ::T.let(nil, ::T.untyped)
  INV_READ = ::T.let(nil, ::T.untyped)
  INV_WRITE = ::T.let(nil, ::T.untyped)
  InvalidOid = ::T.let(nil, ::T.untyped)
  PGRES_BAD_RESPONSE = ::T.let(nil, ::T.untyped)
  PGRES_COMMAND_OK = ::T.let(nil, ::T.untyped)
  PGRES_COPY_BOTH = ::T.let(nil, ::T.untyped)
  PGRES_COPY_IN = ::T.let(nil, ::T.untyped)
  PGRES_COPY_OUT = ::T.let(nil, ::T.untyped)
  PGRES_EMPTY_QUERY = ::T.let(nil, ::T.untyped)
  PGRES_FATAL_ERROR = ::T.let(nil, ::T.untyped)
  PGRES_NONFATAL_ERROR = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_FAILED = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_OK = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_READING = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_WRITING = ::T.let(nil, ::T.untyped)
  PGRES_SINGLE_TUPLE = ::T.let(nil, ::T.untyped)
  PGRES_TUPLES_OK = ::T.let(nil, ::T.untyped)
  PG_DIAG_COLUMN_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_CONSTRAINT_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_CONTEXT = ::T.let(nil, ::T.untyped)
  PG_DIAG_DATATYPE_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_INTERNAL_POSITION = ::T.let(nil, ::T.untyped)
  PG_DIAG_INTERNAL_QUERY = ::T.let(nil, ::T.untyped)
  PG_DIAG_MESSAGE_DETAIL = ::T.let(nil, ::T.untyped)
  PG_DIAG_MESSAGE_HINT = ::T.let(nil, ::T.untyped)
  PG_DIAG_MESSAGE_PRIMARY = ::T.let(nil, ::T.untyped)
  PG_DIAG_SCHEMA_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_SEVERITY = ::T.let(nil, ::T.untyped)
  PG_DIAG_SEVERITY_NONLOCALIZED = ::T.let(nil, ::T.untyped)
  PG_DIAG_SOURCE_FILE = ::T.let(nil, ::T.untyped)
  PG_DIAG_SOURCE_FUNCTION = ::T.let(nil, ::T.untyped)
  PG_DIAG_SOURCE_LINE = ::T.let(nil, ::T.untyped)
  PG_DIAG_SQLSTATE = ::T.let(nil, ::T.untyped)
  PG_DIAG_STATEMENT_POSITION = ::T.let(nil, ::T.untyped)
  PG_DIAG_TABLE_NAME = ::T.let(nil, ::T.untyped)
  PQERRORS_DEFAULT = ::T.let(nil, ::T.untyped)
  PQERRORS_TERSE = ::T.let(nil, ::T.untyped)
  PQERRORS_VERBOSE = ::T.let(nil, ::T.untyped)
  PQPING_NO_ATTEMPT = ::T.let(nil, ::T.untyped)
  PQPING_NO_RESPONSE = ::T.let(nil, ::T.untyped)
  PQPING_OK = ::T.let(nil, ::T.untyped)
  PQPING_REJECT = ::T.let(nil, ::T.untyped)
  PQSHOW_CONTEXT_ALWAYS = ::T.let(nil, ::T.untyped)
  PQSHOW_CONTEXT_ERRORS = ::T.let(nil, ::T.untyped)
  PQSHOW_CONTEXT_NEVER = ::T.let(nil, ::T.untyped)
  PQTRANS_ACTIVE = ::T.let(nil, ::T.untyped)
  PQTRANS_IDLE = ::T.let(nil, ::T.untyped)
  PQTRANS_INERROR = ::T.let(nil, ::T.untyped)
  PQTRANS_INTRANS = ::T.let(nil, ::T.untyped)
  PQTRANS_UNKNOWN = ::T.let(nil, ::T.untyped)
  SEEK_CUR = ::T.let(nil, ::T.untyped)
  SEEK_END = ::T.let(nil, ::T.untyped)
  SEEK_SET = ::T.let(nil, ::T.untyped)
end

class PG::CopyDecoder
  include ::PG::Coder::BinaryFormatting
end

class PG::CopyDecoder
end

class PG::CopyEncoder
  include ::PG::Coder::BinaryFormatting
end

class PG::CopyEncoder
end

class PG::CrashShutdown
end

class PG::CrashShutdown
end

class PG::DataCorrupted
end

class PG::DataCorrupted
end

class PG::DataException
end

class PG::DataException
end

class PG::DatabaseDropped
end

class PG::DatabaseDropped
end

class PG::DatatypeMismatch
end

class PG::DatatypeMismatch
end

class PG::DatetimeFieldOverflow
end

class PG::DatetimeFieldOverflow
end

class PG::DependentObjectsStillExist
end

class PG::DependentObjectsStillExist
end

class PG::DependentPrivilegeDescriptorsStillExist
end

class PG::DependentPrivilegeDescriptorsStillExist
end

class PG::DiagnosticsException
end

class PG::DiagnosticsException
end

class PG::DiskFull
end

class PG::DiskFull
end

class PG::DivisionByZero
end

class PG::DivisionByZero
end

class PG::DuplicateAlias
end

class PG::DuplicateAlias
end

class PG::DuplicateColumn
end

class PG::DuplicateColumn
end

class PG::DuplicateCursor
end

class PG::DuplicateCursor
end

class PG::DuplicateDatabase
end

class PG::DuplicateDatabase
end

class PG::DuplicateFile
end

class PG::DuplicateFile
end

class PG::DuplicateFunction
end

class PG::DuplicateFunction
end

class PG::DuplicateJsonObjectKeyValue
end

class PG::DuplicateJsonObjectKeyValue
end

class PG::DuplicateObject
end

class PG::DuplicateObject
end

class PG::DuplicatePstatement
end

class PG::DuplicatePstatement
end

class PG::DuplicateSchema
end

class PG::DuplicateSchema
end

class PG::DuplicateTable
end

class PG::DuplicateTable
end

class PG::EREContainingSqlNotPermitted
end

class PG::EREContainingSqlNotPermitted
end

class PG::EREModifyingSqlDataNotPermitted
end

class PG::EREModifyingSqlDataNotPermitted
end

class PG::EREProhibitedSqlStatementAttempted
end

class PG::EREProhibitedSqlStatementAttempted
end

class PG::EREReadingSqlDataNotPermitted
end

class PG::EREReadingSqlDataNotPermitted
end

class PG::ERIEEventTriggerProtocolViolated
end

class PG::ERIEEventTriggerProtocolViolated
end

class PG::ERIEInvalidSqlstateReturned
end

class PG::ERIEInvalidSqlstateReturned
end

class PG::ERIENullValueNotAllowed
end

class PG::ERIENullValueNotAllowed
end

class PG::ERIESrfProtocolViolated
end

class PG::ERIESrfProtocolViolated
end

class PG::ERIETriggerProtocolViolated
end

class PG::ERIETriggerProtocolViolated
end

class PG::ErrorInAssignment
end

class PG::ErrorInAssignment
end

class PG::EscapeCharacterConflict
end

class PG::EscapeCharacterConflict
end

class PG::ExclusionViolation
end

class PG::ExclusionViolation
end

class PG::ExternalRoutineException
end

class PG::ExternalRoutineException
end

class PG::ExternalRoutineInvocationException
end

class PG::ExternalRoutineInvocationException
end

class PG::FdwColumnNameNotFound
end

class PG::FdwColumnNameNotFound
end

class PG::FdwDynamicParameterValueNeeded
end

class PG::FdwDynamicParameterValueNeeded
end

class PG::FdwError
end

class PG::FdwError
end

class PG::FdwFunctionSequenceError
end

class PG::FdwFunctionSequenceError
end

class PG::FdwInconsistentDescriptorInformation
end

class PG::FdwInconsistentDescriptorInformation
end

class PG::FdwInvalidAttributeValue
end

class PG::FdwInvalidAttributeValue
end

class PG::FdwInvalidColumnName
end

class PG::FdwInvalidColumnName
end

class PG::FdwInvalidColumnNumber
end

class PG::FdwInvalidColumnNumber
end

class PG::FdwInvalidDataType
end

class PG::FdwInvalidDataType
end

class PG::FdwInvalidDataTypeDescriptors
end

class PG::FdwInvalidDataTypeDescriptors
end

class PG::FdwInvalidDescriptorFieldIdentifier
end

class PG::FdwInvalidDescriptorFieldIdentifier
end

class PG::FdwInvalidHandle
end

class PG::FdwInvalidHandle
end

class PG::FdwInvalidOptionIndex
end

class PG::FdwInvalidOptionIndex
end

class PG::FdwInvalidOptionName
end

class PG::FdwInvalidOptionName
end

class PG::FdwInvalidStringFormat
end

class PG::FdwInvalidStringFormat
end

class PG::FdwInvalidStringLengthOrBufferLength
end

class PG::FdwInvalidStringLengthOrBufferLength
end

class PG::FdwInvalidUseOfNullPointer
end

class PG::FdwInvalidUseOfNullPointer
end

class PG::FdwNoSchemas
end

class PG::FdwNoSchemas
end

class PG::FdwOptionNameNotFound
end

class PG::FdwOptionNameNotFound
end

class PG::FdwOutOfMemory
end

class PG::FdwOutOfMemory
end

class PG::FdwReplyHandle
end

class PG::FdwReplyHandle
end

class PG::FdwSchemaNotFound
end

class PG::FdwSchemaNotFound
end

class PG::FdwTableNotFound
end

class PG::FdwTableNotFound
end

class PG::FdwTooManyHandles
end

class PG::FdwTooManyHandles
end

class PG::FdwUnableToCreateExecution
end

class PG::FdwUnableToCreateExecution
end

class PG::FdwUnableToCreateReply
end

class PG::FdwUnableToCreateReply
end

class PG::FdwUnableToEstablishConnection
end

class PG::FdwUnableToEstablishConnection
end

class PG::FeatureNotSupported
end

class PG::FeatureNotSupported
end

class PG::FloatingPointException
end

class PG::FloatingPointException
end

class PG::ForeignKeyViolation
end

class PG::ForeignKeyViolation
end

class PG::GeneratedAlways
end

class PG::GeneratedAlways
end

class PG::GroupingError
end

class PG::GroupingError
end

class PG::HeldCursorRequiresSameIsolationLevel
end

class PG::HeldCursorRequiresSameIsolationLevel
end

class PG::IdleInTransactionSessionTimeout
end

class PG::IdleInTransactionSessionTimeout
end

class PG::InFailedSqlTransaction
end

class PG::InFailedSqlTransaction
end

class PG::InappropriateAccessModeForBranchTransaction
end

class PG::InappropriateAccessModeForBranchTransaction
end

class PG::InappropriateIsolationLevelForBranchTransaction
end

class PG::InappropriateIsolationLevelForBranchTransaction
end

class PG::IndeterminateCollation
end

class PG::IndeterminateCollation
end

class PG::IndeterminateDatatype
end

class PG::IndeterminateDatatype
end

class PG::IndexCorrupted
end

class PG::IndexCorrupted
end

class PG::IndicatorOverflow
end

class PG::IndicatorOverflow
end

class PG::InsufficientPrivilege
end

class PG::InsufficientPrivilege
end

class PG::InsufficientResources
end

class PG::InsufficientResources
end

class PG::IntegrityConstraintViolation
end

class PG::IntegrityConstraintViolation
end

class PG::InternalError
end

class PG::InternalError
end

class PG::IntervalFieldOverflow
end

class PG::IntervalFieldOverflow
end

class PG::InvalidArgumentForLog
end

class PG::InvalidArgumentForLog
end

class PG::InvalidArgumentForNthValue
end

class PG::InvalidArgumentForNthValue
end

class PG::InvalidArgumentForNtile
end

class PG::InvalidArgumentForNtile
end

class PG::InvalidArgumentForPowerFunction
end

class PG::InvalidArgumentForPowerFunction
end

class PG::InvalidArgumentForWidthBucketFunction
end

class PG::InvalidArgumentForWidthBucketFunction
end

class PG::InvalidAuthorizationSpecification
end

class PG::InvalidAuthorizationSpecification
end

class PG::InvalidBinaryRepresentation
end

class PG::InvalidBinaryRepresentation
end

class PG::InvalidCatalogName
end

class PG::InvalidCatalogName
end

class PG::InvalidChangeOfResultFields
end

class PG::InvalidChangeOfResultFields
end

class PG::InvalidCharacterValueForCast
end

class PG::InvalidCharacterValueForCast
end

class PG::InvalidColumnDefinition
end

class PG::InvalidColumnDefinition
end

class PG::InvalidColumnReference
end

class PG::InvalidColumnReference
end

class PG::InvalidCursorDefinition
end

class PG::InvalidCursorDefinition
end

class PG::InvalidCursorName
end

class PG::InvalidCursorName
end

class PG::InvalidCursorState
end

class PG::InvalidCursorState
end

class PG::InvalidDatabaseDefinition
end

class PG::InvalidDatabaseDefinition
end

class PG::InvalidDatetimeFormat
end

class PG::InvalidDatetimeFormat
end

class PG::InvalidEscapeCharacter
end

class PG::InvalidEscapeCharacter
end

class PG::InvalidEscapeOctet
end

class PG::InvalidEscapeOctet
end

class PG::InvalidEscapeSequence
end

class PG::InvalidEscapeSequence
end

class PG::InvalidForeignKey
end

class PG::InvalidForeignKey
end

class PG::InvalidFunctionDefinition
end

class PG::InvalidFunctionDefinition
end

class PG::InvalidGrantOperation
end

class PG::InvalidGrantOperation
end

class PG::InvalidGrantor
end

class PG::InvalidGrantor
end

class PG::InvalidIndicatorParameterValue
end

class PG::InvalidIndicatorParameterValue
end

class PG::InvalidJsonText
end

class PG::InvalidJsonText
end

class PG::InvalidName
end

class PG::InvalidName
end

class PG::InvalidObjectDefinition
end

class PG::InvalidObjectDefinition
end

class PG::InvalidParameterValue
end

class PG::InvalidParameterValue
end

class PG::InvalidPassword
end

class PG::InvalidPassword
end

class PG::InvalidPrecedingOrFollowingSize
end

class PG::InvalidPrecedingOrFollowingSize
end

class PG::InvalidPstatementDefinition
end

class PG::InvalidPstatementDefinition
end

class PG::InvalidRecursion
end

class PG::InvalidRecursion
end

class PG::InvalidRegularExpression
end

class PG::InvalidRegularExpression
end

class PG::InvalidResultStatus
end

class PG::InvalidResultStatus
end

class PG::InvalidRoleSpecification
end

class PG::InvalidRoleSpecification
end

class PG::InvalidRowCountInLimitClause
end

class PG::InvalidRowCountInLimitClause
end

class PG::InvalidRowCountInResultOffsetClause
end

class PG::InvalidRowCountInResultOffsetClause
end

class PG::InvalidSchemaDefinition
end

class PG::InvalidSchemaDefinition
end

class PG::InvalidSchemaName
end

class PG::InvalidSchemaName
end

class PG::InvalidSqlJsonSubscript
end

class PG::InvalidSqlJsonSubscript
end

class PG::InvalidSqlStatementName
end

class PG::InvalidSqlStatementName
end

class PG::InvalidTableDefinition
end

class PG::InvalidTableDefinition
end

class PG::InvalidTablesampleArgument
end

class PG::InvalidTablesampleArgument
end

class PG::InvalidTablesampleRepeat
end

class PG::InvalidTablesampleRepeat
end

class PG::InvalidTextRepresentation
end

class PG::InvalidTextRepresentation
end

class PG::InvalidTimeZoneDisplacementValue
end

class PG::InvalidTimeZoneDisplacementValue
end

class PG::InvalidTransactionInitiation
end

class PG::InvalidTransactionInitiation
end

class PG::InvalidTransactionState
end

class PG::InvalidTransactionState
end

class PG::InvalidTransactionTermination
end

class PG::InvalidTransactionTermination
end

class PG::InvalidUseOfEscapeCharacter
end

class PG::InvalidUseOfEscapeCharacter
end

class PG::InvalidXmlComment
end

class PG::InvalidXmlComment
end

class PG::InvalidXmlContent
end

class PG::InvalidXmlContent
end

class PG::InvalidXmlDocument
end

class PG::InvalidXmlDocument
end

class PG::InvalidXmlProcessingInstruction
end

class PG::InvalidXmlProcessingInstruction
end

class PG::IoError
end

class PG::IoError
end

class PG::LEInvalidSpecification
end

class PG::LEInvalidSpecification
end

class PG::LocatorException
end

class PG::LocatorException
end

class PG::LockFileExists
end

class PG::LockFileExists
end

class PG::LockNotAvailable
end

class PG::LockNotAvailable
end

class PG::MoreThanOneSqlJsonItem
end

class PG::MoreThanOneSqlJsonItem
end

class PG::MostSpecificTypeMismatch
end

class PG::MostSpecificTypeMismatch
end

class PG::NameTooLong
end

class PG::NameTooLong
end

class PG::NoActiveSqlTransaction
end

class PG::NoActiveSqlTransaction
end

class PG::NoActiveSqlTransactionForBranchTransaction
end

class PG::NoActiveSqlTransactionForBranchTransaction
end

class PG::NoDataFound
end

class PG::NoDataFound
end

class PG::NoResultError
end

class PG::NoResultError
end

class PG::NoSqlJsonItem
end

class PG::NoSqlJsonItem
end

class PG::NonNumericSqlJsonItem
end

class PG::NonNumericSqlJsonItem
end

class PG::NonUniqueKeysInAJsonObject
end

class PG::NonUniqueKeysInAJsonObject
end

class PG::NonstandardUseOfEscapeCharacter
end

class PG::NonstandardUseOfEscapeCharacter
end

class PG::NotAnXmlDocument
end

class PG::NotAnXmlDocument
end

class PG::NotNullViolation
end

class PG::NotNullViolation
end

class PG::NullValueNoIndicatorParameter
end

class PG::NullValueNoIndicatorParameter
end

class PG::NullValueNotAllowed
end

class PG::NullValueNotAllowed
end

class PG::NumericValueOutOfRange
end

class PG::NumericValueOutOfRange
end

class PG::ObjectInUse
end

class PG::ObjectInUse
end

class PG::ObjectNotInPrerequisiteState
end

class PG::ObjectNotInPrerequisiteState
end

class PG::OperatorIntervention
end

class PG::OperatorIntervention
end

class PG::OutOfMemory
end

class PG::OutOfMemory
end

class PG::PlpgsqlError
end

class PG::PlpgsqlError
end

class PG::ProgramLimitExceeded
end

class PG::ProgramLimitExceeded
end

class PG::ProtocolViolation
end

class PG::ProtocolViolation
end

class PG::QueryCanceled
end

class PG::QueryCanceled
end

class PG::RaiseException
end

class PG::RaiseException
end

class PG::ReadOnlySqlTransaction
end

class PG::ReadOnlySqlTransaction
end

class PG::RecordDecoder
end

class PG::RecordDecoder
end

class PG::RecordEncoder
end

class PG::RecordEncoder
end

class PG::ReservedName
end

class PG::ReservedName
end

class PG::RestrictViolation
end

class PG::RestrictViolation
end

class PG::Result
  include ::Enumerable
  include ::PG::Constants
end

class PG::SEInvalidSpecification
end

class PG::SEInvalidSpecification
end

class PG::SREFunctionExecutedNoReturnStatement
end

class PG::SREFunctionExecutedNoReturnStatement
end

class PG::SREModifyingSqlDataNotPermitted
end

class PG::SREModifyingSqlDataNotPermitted
end

class PG::SREProhibitedSqlStatementAttempted
end

class PG::SREProhibitedSqlStatementAttempted
end

class PG::SREReadingSqlDataNotPermitted
end

class PG::SREReadingSqlDataNotPermitted
end

class PG::SavepointException
end

class PG::SavepointException
end

class PG::SchemaAndDataStatementMixingNotSupported
end

class PG::SchemaAndDataStatementMixingNotSupported
end

class PG::SequenceGeneratorLimitExceeded
end

class PG::SequenceGeneratorLimitExceeded
end

class PG::ServerError
end

class PG::ServerError
end

class PG::SimpleCoder
end

class PG::SimpleCoder
end

class PG::SimpleDecoder
end

class PG::SimpleDecoder
end

class PG::SimpleEncoder
end

class PG::SimpleEncoder
end

class PG::SingletonSqlJsonItemRequired
end

class PG::SingletonSqlJsonItemRequired
end

class PG::SnapshotTooOld
end

class PG::SnapshotTooOld
end

class PG::SqlJsonArrayNotFound
end

class PG::SqlJsonArrayNotFound
end

class PG::SqlJsonMemberNotFound
end

class PG::SqlJsonMemberNotFound
end

class PG::SqlJsonNumberNotFound
end

class PG::SqlJsonNumberNotFound
end

class PG::SqlJsonObjectNotFound
end

class PG::SqlJsonObjectNotFound
end

class PG::SqlJsonScalarRequired
end

class PG::SqlJsonScalarRequired
end

class PG::SqlRoutineException
end

class PG::SqlRoutineException
end

class PG::SqlStatementNotYetComplete
end

class PG::SqlStatementNotYetComplete
end

class PG::SqlclientUnableToEstablishSqlconnection
end

class PG::SqlclientUnableToEstablishSqlconnection
end

class PG::SqlserverRejectedEstablishmentOfSqlconnection
end

class PG::SqlserverRejectedEstablishmentOfSqlconnection
end

class PG::StackedDiagnosticsAccessedWithoutActiveHandler
end

class PG::StackedDiagnosticsAccessedWithoutActiveHandler
end

class PG::StatementTooComplex
end

class PG::StatementTooComplex
end

class PG::StringDataLengthMismatch
end

class PG::StringDataLengthMismatch
end

class PG::StringDataRightTruncation
end

class PG::StringDataRightTruncation
end

class PG::SubstringError
end

class PG::SubstringError
end

class PG::SyntaxError
end

class PG::SyntaxError
end

class PG::SyntaxErrorOrAccessRuleViolation
end

class PG::SyntaxErrorOrAccessRuleViolation
end

class PG::SystemError
end

class PG::SystemError
end

class PG::TRDeadlockDetected
end

class PG::TRDeadlockDetected
end

class PG::TRIntegrityConstraintViolation
end

class PG::TRIntegrityConstraintViolation
end

class PG::TRSerializationFailure
end

class PG::TRSerializationFailure
end

class PG::TRStatementCompletionUnknown
end

class PG::TRStatementCompletionUnknown
end

class PG::TextDecoder::Array
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Boolean
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Bytea
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::CopyRow
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Date
end

class PG::TextDecoder::Float
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::FromBase64
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Identifier
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Inet
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Integer
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::JSON
end

class PG::TextDecoder::Numeric
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Record
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::String
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Timestamp
  CFUNC = ::T.let(nil, ::T.untyped)
end

PG::TextDecoder::TimestampWithTimeZone = PG::TextDecoder::Timestamp

PG::TextDecoder::TimestampWithoutTimeZone = PG::TextDecoder::TimestampLocal

class PG::TextEncoder::Array
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Boolean
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Bytea
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::CopyRow
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Date
end

class PG::TextEncoder::Float
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Identifier
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Inet
end

class PG::TextEncoder::Integer
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::JSON
end

class PG::TextEncoder::Numeric
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::QuotedLiteral
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Record
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::String
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::TimestampUtc
end

class PG::TextEncoder::TimestampWithTimeZone
end

class PG::TextEncoder::TimestampWithoutTimeZone
end

class PG::TextEncoder::ToBase64
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TooManyArguments
end

class PG::TooManyArguments
end

class PG::TooManyColumns
end

class PG::TooManyColumns
end

class PG::TooManyConnections
end

class PG::TooManyConnections
end

class PG::TooManyJsonArrayElements
end

class PG::TooManyJsonArrayElements
end

class PG::TooManyJsonObjectMembers
end

class PG::TooManyJsonObjectMembers
end

class PG::TooManyRows
end

class PG::TooManyRows
end

class PG::TransactionResolutionUnknown
end

class PG::TransactionResolutionUnknown
end

class PG::TransactionRollback
end

class PG::TransactionRollback
end

class PG::TriggeredActionException
end

class PG::TriggeredActionException
end

class PG::TriggeredDataChangeViolation
end

class PG::TriggeredDataChangeViolation
end

class PG::TrimError
end

class PG::TrimError
end

class PG::Tuple
  include ::Enumerable
end

class PG::TypeMapAllStrings
end

class PG::TypeMapAllStrings
end

class PG::TypeMapByClass
  include ::PG::TypeMap::DefaultTypeMappable
end

class PG::TypeMapByColumn
  include ::PG::TypeMap::DefaultTypeMappable
end

class PG::TypeMapByMriType
  include ::PG::TypeMap::DefaultTypeMappable
end

class PG::TypeMapByOid
  include ::PG::TypeMap::DefaultTypeMappable
end

class PG::TypeMapInRuby
  include ::PG::TypeMap::DefaultTypeMappable
end

class PG::UnableToSend
end

class PG::UnableToSend
end

class PG::UndefinedColumn
end

class PG::UndefinedColumn
end

class PG::UndefinedFile
end

class PG::UndefinedFile
end

class PG::UndefinedFunction
end

class PG::UndefinedFunction
end

class PG::UndefinedObject
end

class PG::UndefinedObject
end

class PG::UndefinedParameter
end

class PG::UndefinedParameter
end

class PG::UndefinedTable
end

class PG::UndefinedTable
end

class PG::UniqueViolation
end

class PG::UniqueViolation
end

class PG::UnsafeNewEnumValueUsage
end

class PG::UnsafeNewEnumValueUsage
end

class PG::UnterminatedCString
end

class PG::UnterminatedCString
end

class PG::UntranslatableCharacter
end

class PG::UntranslatableCharacter
end

class PG::WindowingError
end

class PG::WindowingError
end

class PG::WithCheckOptionViolation
end

class PG::WithCheckOptionViolation
end

class PG::WrongObjectType
end

class PG::WrongObjectType
end

class PG::ZeroLengthCharacterString
end

class PG::ZeroLengthCharacterString
end

module Parallel
  Stop = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Parallel::Break
end

class Parallel::Break
end

class Parallel::DeadWorker
end

class Parallel::DeadWorker
end

class Parallel::ExceptionWrapper
  def exception(); end

  def initialize(exception); end
end

class Parallel::ExceptionWrapper
end

class Parallel::JobFactory
  def initialize(source, mutex); end

  def next(); end

  def pack(item, index); end

  def size(); end

  def unpack(data); end
end

class Parallel::JobFactory
end

class Parallel::Kill
end

class Parallel::Kill
end

module Parallel::ProcessorCount
  def physical_processor_count(); end

  def processor_count(); end
end

module Parallel::ProcessorCount
end

class Parallel::UndumpableException
  def initialize(original); end
end

class Parallel::UndumpableException
end

class Parallel::UserInterruptHandler
  INTERRUPT_SIGNAL = ::T.let(nil, ::T.untyped)
end

class Parallel::UserInterruptHandler
  def self.kill(thing); end

  def self.kill_on_ctrl_c(pids, options); end
end

class Parallel::Worker
  def close_pipes(); end

  def initialize(read, write, pid); end

  def pid(); end

  def read(); end

  def stop(); end

  def thread(); end

  def thread=(thread); end

  def work(data); end

  def write(); end
end

class Parallel::Worker
end

module Parallel
  extend ::Parallel::ProcessorCount
  def self.all?(*args, &block); end

  def self.any?(*args, &block); end

  def self.each(array, options=T.unsafe(nil), &block); end

  def self.each_with_index(array, options=T.unsafe(nil), &block); end

  def self.flat_map(*args, &block); end

  def self.in_processes(options=T.unsafe(nil), &block); end

  def self.in_threads(options=T.unsafe(nil)); end

  def self.map(source, options=T.unsafe(nil), &block); end

  def self.map_with_index(array, options=T.unsafe(nil), &block); end

  def self.worker_number(); end

  def self.worker_number=(worker_num); end
end

module Parlour
  VERSION = ::T.let(nil, ::T.untyped)
end

module Parlour::Debugging::Tree
  INDENT_SPACES = ::T.let(nil, ::T.untyped)
end

class Parlour::RbiGenerator::Parameter
  PREFIXES = ::T.let(nil, ::T.untyped)
end

ParseError = Racc::ParseError

module Parser
  MESSAGES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Parser::AST
end

class Parser::AST::Node
  def loc(); end

  def location(); end
end

class Parser::AST::Node
end

class Parser::AST::Processor
  def on_alias(node); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_arg(node); end

  def on_arg_expr(node); end

  def on_args(node); end

  def on_argument(node); end

  def on_array(node); end

  def on_array_pattern(node); end

  def on_array_pattern_with_tail(node); end

  def on_back_ref(node); end

  def on_begin(node); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_blockarg(node); end

  def on_blockarg_expr(node); end

  def on_break(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_casgn(node); end

  def on_class(node); end

  def on_const(node); end

  def on_const_pattern(node); end

  def on_csend(node); end

  def on_cvar(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_defined?(node); end

  def on_defs(node); end

  def on_dstr(node); end

  def on_dsym(node); end

  def on_eflipflop(node); end

  def on_empty_else(node); end

  def on_ensure(node); end

  def on_erange(node); end

  def on_for(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def on_hash(node); end

  def on_hash_pattern(node); end

  def on_if(node); end

  def on_if_guard(node); end

  def on_iflipflop(node); end

  def on_in_match(node); end

  def on_in_pattern(node); end

  def on_index(node); end

  def on_indexasgn(node); end

  def on_irange(node); end

  def on_ivar(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwbegin(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_kwsplat(node); end

  def on_lambda(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_alt(node); end

  def on_match_as(node); end

  def on_match_current_line(node); end

  def on_match_rest(node); end

  def on_match_var(node); end

  def on_match_with_lvasgn(node); end

  def on_mlhs(node); end

  def on_module(node); end

  def on_next(node); end

  def on_not(node); end

  def on_nth_ref(node); end

  def on_numblock(node); end

  def on_op_asgn(node); end

  def on_optarg(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_pin(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_procarg0(node); end

  def on_redo(node); end

  def on_regexp(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_restarg(node); end

  def on_restarg_expr(node); end

  def on_retry(node); end

  def on_return(node); end

  def on_sclass(node); end

  def on_send(node); end

  def on_shadowarg(node); end

  def on_splat(node); end

  def on_super(node); end

  def on_undef(node); end

  def on_unless_guard(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_var(node); end

  def on_vasgn(node); end

  def on_when(node); end

  def on_while(node); end

  def on_while_post(node); end

  def on_xstr(node); end

  def on_yield(node); end

  def process_argument_node(node); end

  def process_regular_node(node); end

  def process_var_asgn_node(node); end

  def process_variable_node(node); end
end

class Parser::AST::Processor
end

module Parser::AST
end

class Parser::Base
  def builder(); end

  def context(); end

  def current_arg_stack(); end

  def diagnostics(); end

  def initialize(builder=T.unsafe(nil)); end

  def max_numparam_stack(); end

  def parse(source_buffer); end

  def parse_with_comments(source_buffer); end

  def pattern_hash_keys(); end

  def pattern_variables(); end

  def reset(); end

  def source_buffer(); end

  def static_env(); end

  def tokenize(source_buffer, recover=T.unsafe(nil)); end
end

class Parser::Base
  def self.default_parser(); end

  def self.parse(string, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def self.parse_file(filename); end

  def self.parse_file_with_comments(filename); end

  def self.parse_with_comments(string, file=T.unsafe(nil), line=T.unsafe(nil)); end
end

module Parser::Builders
end

class Parser::Builders::Default
  def __ENCODING__(__ENCODING__t); end

  def __FILE__(__FILE__t); end

  def __LINE__(__LINE__t); end

  def accessible(node); end

  def alias(alias_t, to, from); end

  def arg(name_t); end

  def arg_expr(expr); end

  def args(begin_t, args, end_t, check_args=T.unsafe(nil)); end

  def array(begin_t, elements, end_t); end

  def array_pattern(lbrack_t, elements, rbrack_t); end

  def assign(lhs, eql_t, rhs); end

  def assignable(node); end

  def associate(begin_t, pairs, end_t); end

  def attr_asgn(receiver, dot_t, selector_t); end

  def back_ref(token); end

  def begin(begin_t, body, end_t); end

  def begin_body(compound_stmt, rescue_bodies=T.unsafe(nil), else_t=T.unsafe(nil), else_=T.unsafe(nil), ensure_t=T.unsafe(nil), ensure_=T.unsafe(nil)); end

  def begin_keyword(begin_t, body, end_t); end

  def binary_op(receiver, operator_t, arg); end

  def block(method_call, begin_t, args, body, end_t); end

  def block_pass(amper_t, arg); end

  def blockarg(amper_t, name_t); end

  def blockarg_expr(amper_t, expr); end

  def call_lambda(lambda_t); end

  def call_method(receiver, dot_t, selector_t, lparen_t=T.unsafe(nil), args=T.unsafe(nil), rparen_t=T.unsafe(nil)); end

  def call_type_for_dot(dot_t); end

  def case(case_t, expr, when_bodies, else_t, else_body, end_t); end

  def case_match(case_t, expr, in_bodies, else_t, else_body, end_t); end

  def character(char_t); end

  def complex(complex_t); end

  def compstmt(statements); end

  def condition(cond_t, cond, then_t, if_true, else_t, if_false, end_t); end

  def condition_mod(if_true, if_false, cond_t, cond); end

  def const(name_t); end

  def const_fetch(scope, t_colon2, name_t); end

  def const_global(t_colon3, name_t); end

  def const_op_assignable(node); end

  def const_pattern(const, ldelim_t, pattern, rdelim_t); end

  def cvar(token); end

  def dedent_string(node, dedent_level); end

  def def_class(class_t, name, lt_t, superclass, body, end_t); end

  def def_method(def_t, name_t, args, body, end_t); end

  def def_module(module_t, name, body, end_t); end

  def def_sclass(class_t, lshft_t, expr, body, end_t); end

  def def_singleton(def_t, definee, dot_t, name_t, args, body, end_t); end

  def emit_file_line_as_literals(); end

  def emit_file_line_as_literals=(emit_file_line_as_literals); end

  def false(false_t); end

  def float(float_t); end

  def for(for_t, iterator, in_t, iteratee, do_t, body, end_t); end

  def forward_args(begin_t, dots_t, end_t); end

  def forwarded_args(dots_t); end

  def gvar(token); end

  def hash_pattern(lbrace_t, kwargs, rbrace_t); end

  def ident(token); end

  def if_guard(if_t, if_body); end

  def in_match(lhs, in_t, rhs); end

  def in_pattern(in_t, pattern, guard, then_t, body); end

  def index(receiver, lbrack_t, indexes, rbrack_t); end

  def index_asgn(receiver, lbrack_t, indexes, rbrack_t); end

  def integer(integer_t); end

  def ivar(token); end

  def keyword_cmd(type, keyword_t, lparen_t=T.unsafe(nil), args=T.unsafe(nil), rparen_t=T.unsafe(nil)); end

  def kwarg(name_t); end

  def kwnilarg(dstar_t, nil_t); end

  def kwoptarg(name_t, value); end

  def kwrestarg(dstar_t, name_t=T.unsafe(nil)); end

  def kwsplat(dstar_t, arg); end

  def logical_op(type, lhs, op_t, rhs); end

  def loop(type, keyword_t, cond, do_t, body, end_t); end

  def loop_mod(type, body, keyword_t, cond); end

  def match_alt(left, pipe_t, right); end

  def match_as(value, assoc_t, as); end

  def match_hash_var(name_t); end

  def match_hash_var_from_str(begin_t, strings, end_t); end

  def match_label(label_type, label); end

  def match_nil_pattern(dstar_t, nil_t); end

  def match_op(receiver, match_t, arg); end

  def match_pair(label_type, label, value); end

  def match_rest(star_t, name_t=T.unsafe(nil)); end

  def match_var(name_t); end

  def match_with_trailing_comma(match, comma_t); end

  def multi_assign(lhs, eql_t, rhs); end

  def multi_lhs(begin_t, items, end_t); end

  def nil(nil_t); end

  def not_op(not_t, begin_t=T.unsafe(nil), receiver=T.unsafe(nil), end_t=T.unsafe(nil)); end

  def nth_ref(token); end

  def numargs(max_numparam); end

  def objc_kwarg(kwname_t, assoc_t, name_t); end

  def objc_restarg(star_t, name=T.unsafe(nil)); end

  def objc_varargs(pair, rest_of_varargs); end

  def op_assign(lhs, op_t, rhs); end

  def optarg(name_t, eql_t, value); end

  def pair(key, assoc_t, value); end

  def pair_keyword(key_t, value); end

  def pair_list_18(list); end

  def pair_quoted(begin_t, parts, end_t, value); end

  def parser(); end

  def parser=(parser); end

  def pin(pin_t, var); end

  def postexe(postexe_t, lbrace_t, compstmt, rbrace_t); end

  def preexe(preexe_t, lbrace_t, compstmt, rbrace_t); end

  def procarg0(arg); end

  def range_exclusive(lhs, dot3_t, rhs); end

  def range_inclusive(lhs, dot2_t, rhs); end

  def rational(rational_t); end

  def regexp_compose(begin_t, parts, end_t, options); end

  def regexp_options(regopt_t); end

  def rescue_body(rescue_t, exc_list, assoc_t, exc_var, then_t, compound_stmt); end

  def restarg(star_t, name_t=T.unsafe(nil)); end

  def restarg_expr(star_t, expr=T.unsafe(nil)); end

  def self(token); end

  def shadowarg(name_t); end

  def splat(star_t, arg=T.unsafe(nil)); end

  def string(string_t); end

  def string_compose(begin_t, parts, end_t); end

  def string_internal(string_t); end

  def symbol(symbol_t); end

  def symbol_compose(begin_t, parts, end_t); end

  def symbol_internal(symbol_t); end

  def symbols_compose(begin_t, parts, end_t); end

  def ternary(cond, question_t, if_true, colon_t, if_false); end

  def true(true_t); end

  def unary_num(unary_t, numeric); end

  def unary_op(op_t, receiver); end

  def undef_method(undef_t, names); end

  def unless_guard(unless_t, unless_body); end

  def when(when_t, patterns, then_t, body); end

  def word(parts); end

  def words_compose(begin_t, parts, end_t); end

  def xstring_compose(begin_t, parts, end_t); end
end

class Parser::Builders::Default
  def self.emit_arg_inside_procarg0(); end

  def self.emit_arg_inside_procarg0=(emit_arg_inside_procarg0); end

  def self.emit_encoding(); end

  def self.emit_encoding=(emit_encoding); end

  def self.emit_index(); end

  def self.emit_index=(emit_index); end

  def self.emit_lambda(); end

  def self.emit_lambda=(emit_lambda); end

  def self.emit_procarg0(); end

  def self.emit_procarg0=(emit_procarg0); end

  def self.modernize(); end
end

module Parser::Builders
end

class Parser::ClobberingError
end

class Parser::ClobberingError
end

class Parser::Context
  def class_definition_allowed?(); end

  def dynamic_const_definition_allowed?(); end

  def in_block?(); end

  def in_class?(); end

  def in_dynamic_block?(); end

  def in_lambda?(); end

  def indirectly_in_def?(); end

  def module_definition_allowed?(); end

  def pop(); end

  def push(state); end

  def reset(); end

  def stack(); end
end

class Parser::Context
end

class Parser::CurrentArgStack
  def pop(); end

  def push(value); end

  def reset(); end

  def set(value); end

  def stack(); end

  def top(); end
end

class Parser::CurrentArgStack
end

module Parser::Deprecation
  def warn_of_deprecation(); end

  def warned_of_deprecation=(warned_of_deprecation); end
end

module Parser::Deprecation
end

class Parser::Diagnostic
  def arguments(); end

  def highlights(); end

  def initialize(level, reason, arguments, location, highlights=T.unsafe(nil)); end

  def level(); end

  def location(); end

  def message(); end

  def reason(); end

  def render(); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Parser::Diagnostic::Engine
  def all_errors_are_fatal(); end

  def all_errors_are_fatal=(all_errors_are_fatal); end

  def consumer(); end

  def consumer=(consumer); end

  def ignore?(diagnostic); end

  def ignore_warnings(); end

  def ignore_warnings=(ignore_warnings); end

  def initialize(consumer=T.unsafe(nil)); end

  def process(diagnostic); end

  def raise?(diagnostic); end
end

class Parser::Diagnostic::Engine
end

class Parser::Diagnostic
end

class Parser::Lexer
  def advance(); end

  def arg_or_cmdarg(cmd_state); end

  def cmdarg(); end

  def cmdarg=(cmdarg); end

  def command_start(); end

  def command_start=(command_start); end

  def comments(); end

  def comments=(comments); end

  def cond(); end

  def cond=(cond); end

  def context(); end

  def context=(context); end

  def dedent_level(); end

  def diagnostic(type, reason, arguments=T.unsafe(nil), location=T.unsafe(nil), highlights=T.unsafe(nil)); end

  def diagnostics(); end

  def diagnostics=(diagnostics); end

  def emit(type, value=T.unsafe(nil), s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_comment(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_do(do_block=T.unsafe(nil)); end

  def emit_table(table, s=T.unsafe(nil), e=T.unsafe(nil)); end

  def encode_escape(ord); end

  def encoding(); end

  def eof_codepoint?(point); end

  def force_utf32(); end

  def force_utf32=(force_utf32); end

  def in_kwarg(); end

  def in_kwarg=(in_kwarg); end

  def initialize(version); end

  def literal(); end

  def next_state_for_literal(literal); end

  def pop_cmdarg(); end

  def pop_cond(); end

  def pop_literal(); end

  def push_cmdarg(); end

  def push_cond(); end

  def push_literal(*args); end

  def range(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def reset(reset_state=T.unsafe(nil)); end

  def source_buffer(); end

  def source_buffer=(source_buffer); end

  def stack_pop(); end

  def state(); end

  def state=(state); end

  def static_env(); end

  def static_env=(static_env); end

  def tok(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def tokens(); end

  def tokens=(tokens); end

  def version?(*versions); end
  ESCAPES = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_BEGIN = ::T.let(nil, ::T.untyped)
  LEX_STATES = ::T.let(nil, ::T.untyped)
  PUNCTUATION = ::T.let(nil, ::T.untyped)
  PUNCTUATION_BEGIN = ::T.let(nil, ::T.untyped)
  REGEXP_META_CHARACTERS = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
  def dedent(string); end

  def initialize(dedent_level); end

  def interrupt(); end
  TAB_WIDTH = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
end

class Parser::Lexer::Literal
  def backslash_delimited?(); end

  def clear_buffer(); end

  def coerce_encoding(string); end

  def dedent_level(); end

  def delimiter?(delimiter); end

  def emit(token, type, s, e); end

  def emit_start_tok(); end

  def end_interp_brace_and_try_closing(); end

  def extend_content(); end

  def extend_space(ts, te); end

  def extend_string(string, ts, te); end

  def flush_string(); end

  def heredoc?(); end

  def heredoc_e(); end

  def infer_indent_level(line); end

  def initialize(lexer, str_type, delimiter, str_s, heredoc_e=T.unsafe(nil), indent=T.unsafe(nil), dedent_body=T.unsafe(nil), label_allowed=T.unsafe(nil)); end

  def interpolate?(); end

  def munge_escape?(character); end

  def nest_and_try_closing(delimiter, ts, te, lookahead=T.unsafe(nil)); end

  def plain_heredoc?(); end

  def regexp?(); end

  def saved_herebody_s(); end

  def saved_herebody_s=(saved_herebody_s); end

  def squiggly_heredoc?(); end

  def start_interp_brace(); end

  def str_s(); end

  def supports_line_continuation_via_slash?(); end

  def type(); end

  def words?(); end
  DELIMITERS = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Literal
end

class Parser::Lexer::StackState
  def active?(); end

  def clear(); end

  def empty?(); end

  def initialize(name); end

  def lexpop(); end

  def pop(); end

  def push(bit); end
end

class Parser::Lexer::StackState
end

class Parser::Lexer
  def self.lex_en_expr_arg(); end

  def self.lex_en_expr_arg=(lex_en_expr_arg); end

  def self.lex_en_expr_beg(); end

  def self.lex_en_expr_beg=(lex_en_expr_beg); end

  def self.lex_en_expr_cmdarg(); end

  def self.lex_en_expr_cmdarg=(lex_en_expr_cmdarg); end

  def self.lex_en_expr_dot(); end

  def self.lex_en_expr_dot=(lex_en_expr_dot); end

  def self.lex_en_expr_end(); end

  def self.lex_en_expr_end=(lex_en_expr_end); end

  def self.lex_en_expr_endarg(); end

  def self.lex_en_expr_endarg=(lex_en_expr_endarg); end

  def self.lex_en_expr_endfn(); end

  def self.lex_en_expr_endfn=(lex_en_expr_endfn); end

  def self.lex_en_expr_fname(); end

  def self.lex_en_expr_fname=(lex_en_expr_fname); end

  def self.lex_en_expr_labelarg(); end

  def self.lex_en_expr_labelarg=(lex_en_expr_labelarg); end

  def self.lex_en_expr_mid(); end

  def self.lex_en_expr_mid=(lex_en_expr_mid); end

  def self.lex_en_expr_value(); end

  def self.lex_en_expr_value=(lex_en_expr_value); end

  def self.lex_en_expr_variable(); end

  def self.lex_en_expr_variable=(lex_en_expr_variable); end

  def self.lex_en_interp_backslash_delimited(); end

  def self.lex_en_interp_backslash_delimited=(lex_en_interp_backslash_delimited); end

  def self.lex_en_interp_backslash_delimited_words(); end

  def self.lex_en_interp_backslash_delimited_words=(lex_en_interp_backslash_delimited_words); end

  def self.lex_en_interp_string(); end

  def self.lex_en_interp_string=(lex_en_interp_string); end

  def self.lex_en_interp_words(); end

  def self.lex_en_interp_words=(lex_en_interp_words); end

  def self.lex_en_leading_dot(); end

  def self.lex_en_leading_dot=(lex_en_leading_dot); end

  def self.lex_en_line_begin(); end

  def self.lex_en_line_begin=(lex_en_line_begin); end

  def self.lex_en_line_comment(); end

  def self.lex_en_line_comment=(lex_en_line_comment); end

  def self.lex_en_plain_backslash_delimited(); end

  def self.lex_en_plain_backslash_delimited=(lex_en_plain_backslash_delimited); end

  def self.lex_en_plain_backslash_delimited_words(); end

  def self.lex_en_plain_backslash_delimited_words=(lex_en_plain_backslash_delimited_words); end

  def self.lex_en_plain_string(); end

  def self.lex_en_plain_string=(lex_en_plain_string); end

  def self.lex_en_plain_words(); end

  def self.lex_en_plain_words=(lex_en_plain_words); end

  def self.lex_en_regexp_modifiers(); end

  def self.lex_en_regexp_modifiers=(lex_en_regexp_modifiers); end

  def self.lex_error(); end

  def self.lex_error=(lex_error); end

  def self.lex_start(); end

  def self.lex_start=(lex_start); end
end

class Parser::MaxNumparamStack
  def has_numparams?(); end

  def has_ordinary_params!(); end

  def has_ordinary_params?(); end

  def pop(); end

  def push(); end

  def register(numparam); end

  def stack(); end

  def top(); end
end

class Parser::MaxNumparamStack
end

module Parser::Meta
  NODE_TYPES = ::T.let(nil, ::T.untyped)
end

module Parser::Meta
end

class Parser::Rewriter
  def assignment?(node); end

  def initialize(*_); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def replace(range, content); end

  def rewrite(source_buffer, ast); end

  def wrap(range, before, after); end
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Rewriter
  extend ::Parser::Deprecation
end

class Parser::Ruby24
  def _reduce_10(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_108(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_110(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_112(val, _values, result); end

  def _reduce_118(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_122(val, _values, result); end

  def _reduce_123(val, _values, result); end

  def _reduce_124(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_17(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_196(val, _values, result); end

  def _reduce_197(val, _values, result); end

  def _reduce_198(val, _values, result); end

  def _reduce_199(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_200(val, _values, result); end

  def _reduce_201(val, _values, result); end

  def _reduce_202(val, _values, result); end

  def _reduce_203(val, _values, result); end

  def _reduce_204(val, _values, result); end

  def _reduce_205(val, _values, result); end

  def _reduce_206(val, _values, result); end

  def _reduce_207(val, _values, result); end

  def _reduce_208(val, _values, result); end

  def _reduce_209(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_210(val, _values, result); end

  def _reduce_211(val, _values, result); end

  def _reduce_212(val, _values, result); end

  def _reduce_213(val, _values, result); end

  def _reduce_214(val, _values, result); end

  def _reduce_215(val, _values, result); end

  def _reduce_216(val, _values, result); end

  def _reduce_217(val, _values, result); end

  def _reduce_218(val, _values, result); end

  def _reduce_219(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_220(val, _values, result); end

  def _reduce_221(val, _values, result); end

  def _reduce_222(val, _values, result); end

  def _reduce_223(val, _values, result); end

  def _reduce_224(val, _values, result); end

  def _reduce_225(val, _values, result); end

  def _reduce_226(val, _values, result); end

  def _reduce_227(val, _values, result); end

  def _reduce_228(val, _values, result); end

  def _reduce_229(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_230(val, _values, result); end

  def _reduce_231(val, _values, result); end

  def _reduce_232(val, _values, result); end

  def _reduce_233(val, _values, result); end

  def _reduce_234(val, _values, result); end

  def _reduce_235(val, _values, result); end

  def _reduce_236(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_241(val, _values, result); end

  def _reduce_242(val, _values, result); end

  def _reduce_244(val, _values, result); end

  def _reduce_245(val, _values, result); end

  def _reduce_246(val, _values, result); end

  def _reduce_248(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_251(val, _values, result); end

  def _reduce_252(val, _values, result); end

  def _reduce_253(val, _values, result); end

  def _reduce_254(val, _values, result); end

  def _reduce_255(val, _values, result); end

  def _reduce_256(val, _values, result); end

  def _reduce_257(val, _values, result); end

  def _reduce_258(val, _values, result); end

  def _reduce_259(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_260(val, _values, result); end

  def _reduce_261(val, _values, result); end

  def _reduce_262(val, _values, result); end

  def _reduce_263(val, _values, result); end

  def _reduce_264(val, _values, result); end

  def _reduce_265(val, _values, result); end

  def _reduce_266(val, _values, result); end

  def _reduce_267(val, _values, result); end

  def _reduce_269(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_270(val, _values, result); end

  def _reduce_271(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_282(val, _values, result); end

  def _reduce_283(val, _values, result); end

  def _reduce_284(val, _values, result); end

  def _reduce_285(val, _values, result); end

  def _reduce_286(val, _values, result); end

  def _reduce_287(val, _values, result); end

  def _reduce_288(val, _values, result); end

  def _reduce_289(val, _values, result); end

  def _reduce_290(val, _values, result); end

  def _reduce_291(val, _values, result); end

  def _reduce_292(val, _values, result); end

  def _reduce_293(val, _values, result); end

  def _reduce_294(val, _values, result); end

  def _reduce_295(val, _values, result); end

  def _reduce_296(val, _values, result); end

  def _reduce_297(val, _values, result); end

  def _reduce_298(val, _values, result); end

  def _reduce_299(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_300(val, _values, result); end

  def _reduce_301(val, _values, result); end

  def _reduce_303(val, _values, result); end

  def _reduce_304(val, _values, result); end

  def _reduce_305(val, _values, result); end

  def _reduce_306(val, _values, result); end

  def _reduce_307(val, _values, result); end

  def _reduce_308(val, _values, result); end

  def _reduce_309(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_310(val, _values, result); end

  def _reduce_311(val, _values, result); end

  def _reduce_312(val, _values, result); end

  def _reduce_313(val, _values, result); end

  def _reduce_314(val, _values, result); end

  def _reduce_315(val, _values, result); end

  def _reduce_316(val, _values, result); end

  def _reduce_317(val, _values, result); end

  def _reduce_318(val, _values, result); end

  def _reduce_319(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_320(val, _values, result); end

  def _reduce_321(val, _values, result); end

  def _reduce_322(val, _values, result); end

  def _reduce_323(val, _values, result); end

  def _reduce_324(val, _values, result); end

  def _reduce_325(val, _values, result); end

  def _reduce_326(val, _values, result); end

  def _reduce_327(val, _values, result); end

  def _reduce_328(val, _values, result); end

  def _reduce_329(val, _values, result); end

  def _reduce_330(val, _values, result); end

  def _reduce_331(val, _values, result); end

  def _reduce_332(val, _values, result); end

  def _reduce_336(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_340(val, _values, result); end

  def _reduce_342(val, _values, result); end

  def _reduce_345(val, _values, result); end

  def _reduce_346(val, _values, result); end

  def _reduce_347(val, _values, result); end

  def _reduce_348(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_350(val, _values, result); end

  def _reduce_351(val, _values, result); end

  def _reduce_352(val, _values, result); end

  def _reduce_353(val, _values, result); end

  def _reduce_354(val, _values, result); end

  def _reduce_355(val, _values, result); end

  def _reduce_356(val, _values, result); end

  def _reduce_357(val, _values, result); end

  def _reduce_358(val, _values, result); end

  def _reduce_359(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_360(val, _values, result); end

  def _reduce_361(val, _values, result); end

  def _reduce_362(val, _values, result); end

  def _reduce_363(val, _values, result); end

  def _reduce_364(val, _values, result); end

  def _reduce_365(val, _values, result); end

  def _reduce_366(val, _values, result); end

  def _reduce_367(val, _values, result); end

  def _reduce_368(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_370(val, _values, result); end

  def _reduce_371(val, _values, result); end

  def _reduce_372(val, _values, result); end

  def _reduce_373(val, _values, result); end

  def _reduce_374(val, _values, result); end

  def _reduce_375(val, _values, result); end

  def _reduce_376(val, _values, result); end

  def _reduce_377(val, _values, result); end

  def _reduce_379(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_380(val, _values, result); end

  def _reduce_381(val, _values, result); end

  def _reduce_382(val, _values, result); end

  def _reduce_383(val, _values, result); end

  def _reduce_384(val, _values, result); end

  def _reduce_385(val, _values, result); end

  def _reduce_386(val, _values, result); end

  def _reduce_387(val, _values, result); end

  def _reduce_388(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_390(val, _values, result); end

  def _reduce_391(val, _values, result); end

  def _reduce_392(val, _values, result); end

  def _reduce_393(val, _values, result); end

  def _reduce_394(val, _values, result); end

  def _reduce_395(val, _values, result); end

  def _reduce_396(val, _values, result); end

  def _reduce_397(val, _values, result); end

  def _reduce_398(val, _values, result); end

  def _reduce_399(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_400(val, _values, result); end

  def _reduce_401(val, _values, result); end

  def _reduce_402(val, _values, result); end

  def _reduce_403(val, _values, result); end

  def _reduce_404(val, _values, result); end

  def _reduce_405(val, _values, result); end

  def _reduce_406(val, _values, result); end

  def _reduce_407(val, _values, result); end

  def _reduce_408(val, _values, result); end

  def _reduce_409(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_410(val, _values, result); end

  def _reduce_411(val, _values, result); end

  def _reduce_412(val, _values, result); end

  def _reduce_413(val, _values, result); end

  def _reduce_414(val, _values, result); end

  def _reduce_415(val, _values, result); end

  def _reduce_416(val, _values, result); end

  def _reduce_417(val, _values, result); end

  def _reduce_418(val, _values, result); end

  def _reduce_419(val, _values, result); end

  def _reduce_420(val, _values, result); end

  def _reduce_421(val, _values, result); end

  def _reduce_422(val, _values, result); end

  def _reduce_423(val, _values, result); end

  def _reduce_424(val, _values, result); end

  def _reduce_426(val, _values, result); end

  def _reduce_427(val, _values, result); end

  def _reduce_428(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_431(val, _values, result); end

  def _reduce_433(val, _values, result); end

  def _reduce_438(val, _values, result); end

  def _reduce_439(val, _values, result); end

  def _reduce_440(val, _values, result); end

  def _reduce_441(val, _values, result); end

  def _reduce_442(val, _values, result); end

  def _reduce_443(val, _values, result); end

  def _reduce_444(val, _values, result); end

  def _reduce_445(val, _values, result); end

  def _reduce_446(val, _values, result); end

  def _reduce_447(val, _values, result); end

  def _reduce_448(val, _values, result); end

  def _reduce_449(val, _values, result); end

  def _reduce_450(val, _values, result); end

  def _reduce_451(val, _values, result); end

  def _reduce_452(val, _values, result); end

  def _reduce_453(val, _values, result); end

  def _reduce_454(val, _values, result); end

  def _reduce_455(val, _values, result); end

  def _reduce_456(val, _values, result); end

  def _reduce_457(val, _values, result); end

  def _reduce_458(val, _values, result); end

  def _reduce_459(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_460(val, _values, result); end

  def _reduce_461(val, _values, result); end

  def _reduce_462(val, _values, result); end

  def _reduce_463(val, _values, result); end

  def _reduce_464(val, _values, result); end

  def _reduce_465(val, _values, result); end

  def _reduce_466(val, _values, result); end

  def _reduce_467(val, _values, result); end

  def _reduce_468(val, _values, result); end

  def _reduce_469(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_470(val, _values, result); end

  def _reduce_471(val, _values, result); end

  def _reduce_472(val, _values, result); end

  def _reduce_474(val, _values, result); end

  def _reduce_475(val, _values, result); end

  def _reduce_476(val, _values, result); end

  def _reduce_477(val, _values, result); end

  def _reduce_478(val, _values, result); end

  def _reduce_479(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_480(val, _values, result); end

  def _reduce_481(val, _values, result); end

  def _reduce_482(val, _values, result); end

  def _reduce_483(val, _values, result); end

  def _reduce_484(val, _values, result); end

  def _reduce_485(val, _values, result); end

  def _reduce_486(val, _values, result); end

  def _reduce_487(val, _values, result); end

  def _reduce_488(val, _values, result); end

  def _reduce_489(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_490(val, _values, result); end

  def _reduce_491(val, _values, result); end

  def _reduce_492(val, _values, result); end

  def _reduce_493(val, _values, result); end

  def _reduce_494(val, _values, result); end

  def _reduce_495(val, _values, result); end

  def _reduce_496(val, _values, result); end

  def _reduce_497(val, _values, result); end

  def _reduce_498(val, _values, result); end

  def _reduce_499(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_500(val, _values, result); end

  def _reduce_501(val, _values, result); end

  def _reduce_502(val, _values, result); end

  def _reduce_503(val, _values, result); end

  def _reduce_504(val, _values, result); end

  def _reduce_505(val, _values, result); end

  def _reduce_506(val, _values, result); end

  def _reduce_507(val, _values, result); end

  def _reduce_508(val, _values, result); end

  def _reduce_509(val, _values, result); end

  def _reduce_510(val, _values, result); end

  def _reduce_511(val, _values, result); end

  def _reduce_512(val, _values, result); end

  def _reduce_513(val, _values, result); end

  def _reduce_514(val, _values, result); end

  def _reduce_515(val, _values, result); end

  def _reduce_516(val, _values, result); end

  def _reduce_517(val, _values, result); end

  def _reduce_518(val, _values, result); end

  def _reduce_519(val, _values, result); end

  def _reduce_520(val, _values, result); end

  def _reduce_521(val, _values, result); end

  def _reduce_522(val, _values, result); end

  def _reduce_523(val, _values, result); end

  def _reduce_524(val, _values, result); end

  def _reduce_525(val, _values, result); end

  def _reduce_526(val, _values, result); end

  def _reduce_527(val, _values, result); end

  def _reduce_528(val, _values, result); end

  def _reduce_529(val, _values, result); end

  def _reduce_530(val, _values, result); end

  def _reduce_532(val, _values, result); end

  def _reduce_533(val, _values, result); end

  def _reduce_534(val, _values, result); end

  def _reduce_535(val, _values, result); end

  def _reduce_536(val, _values, result); end

  def _reduce_537(val, _values, result); end

  def _reduce_538(val, _values, result); end

  def _reduce_539(val, _values, result); end

  def _reduce_540(val, _values, result); end

  def _reduce_541(val, _values, result); end

  def _reduce_542(val, _values, result); end

  def _reduce_543(val, _values, result); end

  def _reduce_544(val, _values, result); end

  def _reduce_545(val, _values, result); end

  def _reduce_546(val, _values, result); end

  def _reduce_549(val, _values, result); end

  def _reduce_55(val, _values, result); end

  def _reduce_550(val, _values, result); end

  def _reduce_551(val, _values, result); end

  def _reduce_552(val, _values, result); end

  def _reduce_553(val, _values, result); end

  def _reduce_554(val, _values, result); end

  def _reduce_555(val, _values, result); end

  def _reduce_556(val, _values, result); end

  def _reduce_559(val, _values, result); end

  def _reduce_56(val, _values, result); end

  def _reduce_560(val, _values, result); end

  def _reduce_563(val, _values, result); end

  def _reduce_564(val, _values, result); end

  def _reduce_565(val, _values, result); end

  def _reduce_567(val, _values, result); end

  def _reduce_568(val, _values, result); end

  def _reduce_57(val, _values, result); end

  def _reduce_570(val, _values, result); end

  def _reduce_571(val, _values, result); end

  def _reduce_572(val, _values, result); end

  def _reduce_573(val, _values, result); end

  def _reduce_574(val, _values, result); end

  def _reduce_575(val, _values, result); end

  def _reduce_588(val, _values, result); end

  def _reduce_589(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_594(val, _values, result); end

  def _reduce_595(val, _values, result); end

  def _reduce_599(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_603(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_73(val, _values, result); end

  def _reduce_75(val, _values, result); end

  def _reduce_76(val, _values, result); end

  def _reduce_77(val, _values, result); end

  def _reduce_78(val, _values, result); end

  def _reduce_79(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_80(val, _values, result); end

  def _reduce_81(val, _values, result); end

  def _reduce_82(val, _values, result); end

  def _reduce_83(val, _values, result); end

  def _reduce_85(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_87(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_89(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_91(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_93(val, _values, result); end

  def _reduce_94(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_99(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def default_encoding(); end

  def version(); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Parser::Ruby24
end

module Parser::Source
end

class Parser::Source::Buffer
  def column_for_position(position); end

  def decompose_position(position); end

  def first_line(); end

  def initialize(name, first_line=T.unsafe(nil)); end

  def last_line(); end

  def line_for_position(position); end

  def line_range(lineno); end

  def name(); end

  def raw_source=(input); end

  def read(); end

  def slice(range); end

  def source(); end

  def source=(input); end

  def source_line(lineno); end

  def source_lines(); end

  def source_range(); end
  ENCODING_RE = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Buffer
  def self.recognize_encoding(string); end

  def self.reencode_string(input); end
end

class Parser::Source::Comment
  def ==(other); end

  def document?(); end

  def initialize(range); end

  def inline?(); end

  def loc(); end

  def location(); end

  def text(); end

  def type(); end
end

class Parser::Source::Comment::Associator
  def associate(); end

  def associate_locations(); end

  def initialize(ast, comments); end

  def skip_directives(); end

  def skip_directives=(skip_directives); end
  MAGIC_COMMENT_RE = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Comment::Associator
end

class Parser::Source::Comment
  def self.associate(ast, comments); end

  def self.associate_locations(ast, comments); end
end

class Parser::Source::Map
  def ==(other); end

  def column(); end

  def expression(); end

  def first_line(); end

  def initialize(expression); end

  def last_column(); end

  def last_line(); end

  def line(); end

  def node(); end

  def node=(node); end

  def to_hash(); end

  def update_expression(expression_l); end

  def with(&block); end

  def with_expression(expression_l); end
end

class Parser::Source::Map::Collection
  def begin(); end

  def end(); end

  def initialize(begin_l, end_l, expression_l); end
end

class Parser::Source::Map::Collection
end

class Parser::Source::Map::Condition
  def begin(); end

  def else(); end

  def end(); end

  def initialize(keyword_l, begin_l, else_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::Condition
end

class Parser::Source::Map::Constant
  def double_colon(); end

  def initialize(double_colon, name, expression); end

  def name(); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Constant
end

class Parser::Source::Map::Definition
  def end(); end

  def initialize(keyword_l, operator_l, name_l, end_l); end

  def keyword(); end

  def name(); end

  def operator(); end
end

class Parser::Source::Map::Definition
end

class Parser::Source::Map::For
  def begin(); end

  def end(); end

  def in(); end

  def initialize(keyword_l, in_l, begin_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::For
end

class Parser::Source::Map::Heredoc
  def heredoc_body(); end

  def heredoc_end(); end

  def initialize(begin_l, body_l, end_l); end
end

class Parser::Source::Map::Heredoc
end

class Parser::Source::Map::Index
  def begin(); end

  def end(); end

  def initialize(begin_l, end_l, expression_l); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Index
end

class Parser::Source::Map::Keyword
  def begin(); end

  def end(); end

  def initialize(keyword_l, begin_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::Keyword
end

class Parser::Source::Map::ObjcKwarg
  def argument(); end

  def initialize(keyword_l, operator_l, argument_l, expression_l); end

  def keyword(); end

  def operator(); end
end

class Parser::Source::Map::ObjcKwarg
end

class Parser::Source::Map::Operator
  def initialize(operator, expression); end

  def operator(); end
end

class Parser::Source::Map::Operator
end

class Parser::Source::Map::RescueBody
  def assoc(); end

  def begin(); end

  def initialize(keyword_l, assoc_l, begin_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::RescueBody
end

class Parser::Source::Map::Send
  def begin(); end

  def dot(); end

  def end(); end

  def initialize(dot_l, selector_l, begin_l, end_l, expression_l); end

  def operator(); end

  def selector(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Send
end

class Parser::Source::Map::Ternary
  def colon(); end

  def initialize(question_l, colon_l, expression_l); end

  def question(); end
end

class Parser::Source::Map::Ternary
end

class Parser::Source::Map::Variable
  def initialize(name_l, expression_l=T.unsafe(nil)); end

  def name(); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Variable
end

class Parser::Source::Map
end

class Parser::Source::Range
  include ::Comparable
  def adjust(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end

  def begin(); end

  def begin_pos(); end

  def column(); end

  def column_range(); end

  def contained?(other); end

  def contains?(other); end

  def crossing?(other); end

  def disjoint?(other); end

  def empty?(); end

  def end(); end

  def end_pos(); end

  def first_line(); end

  def initialize(source_buffer, begin_pos, end_pos); end

  def intersect(other); end

  def is?(*what); end

  def join(other); end

  def last_column(); end

  def last_line(); end

  def length(); end

  def line(); end

  def overlaps?(other); end

  def resize(new_size); end

  def size(); end

  def source(); end

  def source_buffer(); end

  def source_line(); end

  def to_a(); end

  def with(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end
end

class Parser::Source::Range
end

class Parser::Source::Rewriter
  def diagnostics(); end

  def initialize(source_buffer); end

  def insert_after(range, content); end

  def insert_after_multi(range, content); end

  def insert_before(range, content); end

  def insert_before_multi(range, content); end

  def process(); end

  def remove(range); end

  def replace(range, content); end

  def source_buffer(); end

  def transaction(); end

  def wrap(range, before, after); end
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Rewriter::Action
  include ::Comparable
  def allow_multiple_insertions(); end

  def allow_multiple_insertions?(); end

  def initialize(range, replacement=T.unsafe(nil), allow_multiple_insertions=T.unsafe(nil), order=T.unsafe(nil)); end

  def order(); end

  def range(); end

  def replacement(); end
end

class Parser::Source::Rewriter::Action
end

class Parser::Source::Rewriter
  extend ::Parser::Deprecation
end

class Parser::Source::TreeRewriter
  def action_root(); end

  def diagnostics(); end

  def empty?(); end

  def in_transaction?(); end

  def initialize(source_buffer, crossing_deletions: T.unsafe(nil), different_replacements: T.unsafe(nil), swallowed_insertions: T.unsafe(nil)); end

  def insert_after(range, content); end

  def insert_after_multi(range, text); end

  def insert_before(range, content); end

  def insert_before_multi(range, text); end

  def merge(with); end

  def merge!(with); end

  def process(); end

  def remove(range); end

  def replace(range, content); end

  def source_buffer(); end

  def transaction(); end

  def wrap(range, insert_before, insert_after); end
  ACTIONS = ::T.let(nil, ::T.untyped)
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
  POLICY_TO_LEVEL = ::T.let(nil, ::T.untyped)
end

class Parser::Source::TreeRewriter::Action
  def call_enforcer_for_merge(action); end

  def children(); end

  def combine(action); end

  def combine_children(more_children); end

  def do_combine(action); end

  def empty?(); end

  def fuse_deletions(action, fusible, other_sibblings); end

  def initialize(range, enforcer, insert_before: T.unsafe(nil), replacement: T.unsafe(nil), insert_after: T.unsafe(nil), children: T.unsafe(nil)); end

  def insert_after(); end

  def insert_before(); end

  def insertion?(); end

  def merge(action); end

  def ordered_replacements(); end

  def place_in_hierarchy(action); end

  def range(); end

  def relationship_with(action); end

  def replacement(); end

  def swallow(children); end

  def with(range: T.unsafe(nil), enforcer: T.unsafe(nil), children: T.unsafe(nil), insert_before: T.unsafe(nil), replacement: T.unsafe(nil), insert_after: T.unsafe(nil)); end
end

class Parser::Source::TreeRewriter::Action
end

class Parser::Source::TreeRewriter
  extend ::Parser::Deprecation
end

module Parser::Source
end

class Parser::StaticEnvironment
  def declare(name); end

  def declare_forward_args(); end

  def declared?(name); end

  def declared_forward_args?(); end

  def extend_dynamic(); end

  def extend_static(); end

  def reset(); end

  def unextend(); end
  FORWARD_ARGS = ::T.let(nil, ::T.untyped)
end

class Parser::StaticEnvironment
end

class Parser::SyntaxError
  def diagnostic(); end

  def initialize(diagnostic); end
end

class Parser::SyntaxError
end

class Parser::TreeRewriter
  def assignment?(node); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def replace(range, content); end

  def rewrite(source_buffer, ast, **policy); end

  def wrap(range, before, after); end
end

class Parser::TreeRewriter
end

class Parser::VariablesStack
  def declare(name); end

  def declared?(name); end

  def pop(); end

  def push(); end

  def reset(); end
end

class Parser::VariablesStack
end

module Parser
end

class Pathname
  def empty?(); end

  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end
end

class Proc
  def <<(_); end

  def ===(*_); end

  def >>(_); end

  def clone(); end

  def yield(*_); end
end

module Process
  CLOCK_MONOTONIC_RAW_APPROX = ::T.let(nil, ::T.untyped)
  CLOCK_UPTIME_RAW = ::T.let(nil, ::T.untyped)
  CLOCK_UPTIME_RAW_APPROX = ::T.let(nil, ::T.untyped)
end

module Process::Sys
  def self.getegid(); end
end

class Process::Tms
  def cstime(); end

  def cstime=(_); end

  def cutime(); end

  def cutime=(_); end

  def stime(); end

  def stime=(_); end

  def utime(); end

  def utime=(_); end
end

class Process::Tms
  def self.[](*_); end

  def self.members(); end
end

module Process
  def self.last_status(); end

  def self.setpgrp(); end
end

class ProgressBar
end

class ProgressBar::Base
  def autofinish(); end

  def autofinish=(autofinish); end

  def autostart(); end

  def autostart=(autostart); end

  def bar(); end

  def bar=(bar); end

  def clear(*args, &block); end

  def decrement(); end

  def finish(); end

  def finished(); end

  def finished=(finished); end

  def finished?(); end

  def format(other); end

  def format=(other); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def log(*args, &block); end

  def output(); end

  def output=(output); end

  def pause(); end

  def paused?(); end

  def percentage(); end

  def percentage=(percentage); end

  def progress(*args, &block); end

  def progress=(new_progress); end

  def progress_mark=(mark); end

  def progressable(); end

  def progressable=(progressable); end

  def rate(); end

  def rate=(rate); end

  def refresh(*args, &block); end

  def remainder_mark=(mark); end

  def reset(); end

  def resume(); end

  def start(options=T.unsafe(nil)); end

  def started?(); end

  def stop(); end

  def stopped?(); end

  def time(); end

  def time=(time); end

  def timer(); end

  def timer=(timer); end

  def title(); end

  def title=(title); end

  def title_comp(); end

  def title_comp=(title_comp); end

  def to_h(); end

  def to_s(new_format=T.unsafe(nil)); end

  def total(*args, &block); end

  def total=(new_total); end

  def update_progress(*args); end
end

class ProgressBar::Base
  extend ::Forwardable
end

module ProgressBar::Calculators
end

class ProgressBar::Calculators::Length
  def calculate_length(); end

  def current_length(); end

  def current_length=(current_length); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length_changed?(); end

  def length_override(); end

  def length_override=(other); end

  def output(); end

  def output=(output); end

  def reset_length(); end
end

class ProgressBar::Calculators::Length
end

class ProgressBar::Calculators::RunningAverage
end

class ProgressBar::Calculators::RunningAverage
  def self.calculate(current_average, new_value_to_average, smoothing_factor); end
end

module ProgressBar::Calculators
end

module ProgressBar::Components
end

class ProgressBar::Components::Bar
  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length=(length); end

  def progress(); end

  def progress=(progress); end

  def progress_mark(); end

  def progress_mark=(progress_mark); end

  def remainder_mark(); end

  def remainder_mark=(remainder_mark); end

  def to_s(options=T.unsafe(nil)); end

  def upa_steps(); end

  def upa_steps=(upa_steps); end
  DEFAULT_PROGRESS_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_REMAINDER_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_UPA_STEPS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Bar
end

class ProgressBar::Components::Percentage
  def initialize(options=T.unsafe(nil)); end

  def progress(); end

  def progress=(progress); end
end

class ProgressBar::Components::Percentage
end

class ProgressBar::Components::Rate
  def initialize(options=T.unsafe(nil)); end

  def progress(); end

  def progress=(progress); end

  def rate_scale(); end

  def rate_scale=(rate_scale); end

  def started_at(); end

  def started_at=(started_at); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def timer(); end

  def timer=(timer); end
end

class ProgressBar::Components::Rate
end

class ProgressBar::Components::Time
  def elapsed_with_label(); end

  def estimated_with_friendly_oob(); end

  def estimated_with_label(); end

  def estimated_with_no_oob(); end

  def estimated_with_unknown_oob(); end

  def initialize(options=T.unsafe(nil)); end

  def out_of_bounds_time_format(); end

  def out_of_bounds_time_format=(format); end

  def progress(); end

  def progress=(progress); end

  def timer(); end

  def timer=(timer); end
  ELAPSED_LABEL = ::T.let(nil, ::T.untyped)
  ESTIMATED_LABEL = ::T.let(nil, ::T.untyped)
  NO_TIME_ELAPSED_TEXT = ::T.let(nil, ::T.untyped)
  OOB_FRIENDLY_TIME_TEXT = ::T.let(nil, ::T.untyped)
  OOB_LIMIT_IN_HOURS = ::T.let(nil, ::T.untyped)
  OOB_TIME_FORMATS = ::T.let(nil, ::T.untyped)
  OOB_UNKNOWN_TIME_TEXT = ::T.let(nil, ::T.untyped)
  TIME_FORMAT = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Time
end

class ProgressBar::Components::Title
  def initialize(options=T.unsafe(nil)); end

  def title(); end

  def title=(title); end
  DEFAULT_TITLE = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Title
end

module ProgressBar::Components
end

module ProgressBar::Format
end

class ProgressBar::Format::Formatter
end

class ProgressBar::Format::Formatter
  def self.process(format_string, max_length, bar); end
end

class ProgressBar::Format::Molecule
  def bar_molecule?(); end

  def full_key(); end

  def initialize(letter); end

  def key(); end

  def key=(key); end

  def lookup_value(environment, length=T.unsafe(nil)); end

  def method_name(); end

  def method_name=(method_name); end

  def non_bar_molecule?(); end
  BAR_MOLECULES = ::T.let(nil, ::T.untyped)
  MOLECULES = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::Molecule
end

class ProgressBar::Format::String
  def bar_molecule_placeholder_length(); end

  def bar_molecules(); end

  def displayable_length(); end

  def molecules(); end

  def non_bar_molecules(); end
  ANSI_SGR_PATTERN = ::T.let(nil, ::T.untyped)
  MOLECULE_PATTERN = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::String
end

module ProgressBar::Format
end

class ProgressBar::InvalidProgressError
end

class ProgressBar::InvalidProgressError
end

class ProgressBar::Output
  def bar(); end

  def bar=(bar); end

  def clear_string(); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length_calculator(); end

  def length_calculator=(length_calculator); end

  def log(string); end

  def refresh(options=T.unsafe(nil)); end

  def stream(); end

  def stream=(stream); end

  def throttle(); end

  def throttle=(throttle); end

  def with_refresh(); end
  DEFAULT_OUTPUT_STREAM = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Output
  def self.detect(options=T.unsafe(nil)); end
end

module ProgressBar::Outputs
end

class ProgressBar::Outputs::NonTty
  def bar_update_string(); end

  def clear(); end

  def default_format(); end

  def eol(); end

  def last_update_length(); end

  def last_update_length=(last_update_length); end

  def refresh_with_format_change(*_); end

  def resolve_format(*_); end
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::NonTty
end

class ProgressBar::Outputs::Tty
  def bar_update_string(); end

  def clear(); end

  def default_format(); end

  def eol(); end

  def refresh_with_format_change(); end

  def resolve_format(other_format); end
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::Tty
end

module ProgressBar::Outputs
end

class ProgressBar::Progress
  def absolute(); end

  def decrement(); end

  def finish(); end

  def finished?(); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def none?(); end

  def percentage_completed(); end

  def percentage_completed_with_precision(); end

  def progress(); end

  def progress=(new_progress); end

  def reset(); end

  def running_average(); end

  def running_average=(running_average); end

  def smoothing(); end

  def smoothing=(smoothing); end

  def start(options=T.unsafe(nil)); end

  def starting_position(); end

  def starting_position=(starting_position); end

  def total(); end

  def total=(new_total); end

  def total_with_unknown_indicator(); end

  def unknown?(); end
  DEFAULT_BEGINNING_POSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_SMOOTHING = ::T.let(nil, ::T.untyped)
  DEFAULT_TOTAL = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Progress
end

module ProgressBar::Refinements
end

module ProgressBar::Refinements::Enumerator
end

module ProgressBar::Refinements::Enumerator
end

module ProgressBar::Refinements
end

class ProgressBar::Throttle
  def choke(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def rate(); end

  def rate=(rate); end

  def started_at(); end

  def started_at=(started_at); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def timer(); end

  def timer=(timer); end
end

class ProgressBar::Throttle
end

class ProgressBar::Time
  def initialize(time=T.unsafe(nil)); end

  def now(); end

  def time(); end

  def time=(time); end

  def unmocked_time_method(); end
  TIME_MOCKING_LIBRARY_METHODS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Time
end

class ProgressBar::Timer
  def divide_seconds(seconds); end

  def elapsed_seconds(); end

  def elapsed_whole_seconds(); end

  def initialize(options=T.unsafe(nil)); end

  def pause(); end

  def reset(); end

  def reset?(); end

  def restart(); end

  def resume(); end

  def start(); end

  def started?(); end

  def started_at(); end

  def started_at=(started_at); end

  def stop(); end

  def stopped?(); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def time(); end

  def time=(time); end
end

class ProgressBar::Timer
end

class ProgressBar
  def self.create(*args); end
end

module Psych
  LIBYAML_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Psych::BadAlias
end

class Psych::BadAlias
end

class Psych::ClassLoader
  def big_decimal(); end

  def complex(); end

  def date(); end

  def date_time(); end

  def exception(); end

  def load(klassname); end

  def object(); end

  def psych_omap(); end

  def psych_set(); end

  def range(); end

  def rational(); end

  def regexp(); end

  def struct(); end

  def symbol(); end

  def symbolize(sym); end
  BIG_DECIMAL = ::T.let(nil, ::T.untyped)
  CACHE = ::T.let(nil, ::T.untyped)
  COMPLEX = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  DATE_TIME = ::T.let(nil, ::T.untyped)
  EXCEPTION = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  PSYCH_OMAP = ::T.let(nil, ::T.untyped)
  PSYCH_SET = ::T.let(nil, ::T.untyped)
  RANGE = ::T.let(nil, ::T.untyped)
  RATIONAL = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
end

class Psych::ClassLoader::Restricted
  def initialize(classes, symbols); end
end

class Psych::ClassLoader::Restricted
end

class Psych::ClassLoader
end

class Psych::Coder
  def [](k); end

  def []=(k, v); end

  def add(k, v); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(tag); end

  def map(tag=T.unsafe(nil), style=T.unsafe(nil)); end

  def map=(map); end

  def object(); end

  def object=(object); end

  def represent_map(tag, map); end

  def represent_object(tag, obj); end

  def represent_scalar(tag, value); end

  def represent_seq(tag, list); end

  def scalar(*args); end

  def scalar=(value); end

  def seq(); end

  def seq=(list); end

  def style(); end

  def style=(style); end

  def tag(); end

  def tag=(tag); end

  def type(); end
end

class Psych::Coder
end

class Psych::DisallowedClass
  def initialize(klass_name); end
end

class Psych::DisallowedClass
end

class Psych::Emitter
  def alias(_); end

  def canonical(); end

  def canonical=(canonical); end

  def end_document(_); end

  def indentation(); end

  def indentation=(indentation); end

  def initialize(*_); end

  def line_width(); end

  def line_width=(line_width); end

  def scalar(_, _1, _2, _3, _4, _5); end

  def start_document(_, _1, _2); end

  def start_mapping(_, _1, _2, _3); end

  def start_sequence(_, _1, _2, _3); end

  def start_stream(_); end
end

class Psych::Emitter
end

class Psych::Exception
end

class Psych::Exception
end

class Psych::Handler
  def alias(anchor); end

  def empty(); end

  def end_document(implicit); end

  def end_mapping(); end

  def end_sequence(); end

  def end_stream(); end

  def event_location(start_line, start_column, end_line, end_column); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end

  def start_stream(encoding); end

  def streaming?(); end
  EVENTS = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Psych::Handler::DumperOptions
  def canonical(); end

  def canonical=(canonical); end

  def indentation(); end

  def indentation=(indentation); end

  def line_width(); end

  def line_width=(line_width); end
end

class Psych::Handler::DumperOptions
end

class Psych::Handler
end

module Psych::Handlers
end

class Psych::Handlers::DocumentStream
  def initialize(&block); end
end

class Psych::Handlers::DocumentStream
end

module Psych::Handlers
end

module Psych::JSON
end

module Psych::JSON::RubyEvents
  def visit_DateTime(o); end

  def visit_String(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end
end

module Psych::JSON::RubyEvents
end

class Psych::JSON::Stream
  include ::Psych::Streaming
end

class Psych::JSON::Stream::Emitter
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::Stream::Emitter
end

class Psych::JSON::Stream
  extend ::Psych::Streaming::ClassMethods
end

class Psych::JSON::TreeBuilder
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::TreeBuilder
end

module Psych::JSON::YAMLEvents
  def end_document(implicit_end=T.unsafe(nil)); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end
end

module Psych::JSON::YAMLEvents
end

module Psych::JSON
end

module Psych::Nodes
end

class Psych::Nodes::Alias
  def anchor(); end

  def anchor=(anchor); end

  def initialize(anchor); end
end

class Psych::Nodes::Alias
end

class Psych::Nodes::Document
  def implicit(); end

  def implicit=(implicit); end

  def implicit_end(); end

  def implicit_end=(implicit_end); end

  def initialize(version=T.unsafe(nil), tag_directives=T.unsafe(nil), implicit=T.unsafe(nil)); end

  def root(); end

  def tag_directives(); end

  def tag_directives=(tag_directives); end

  def version(); end

  def version=(version); end
end

class Psych::Nodes::Document
end

class Psych::Nodes::Mapping
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Mapping
end

class Psych::Nodes::Node
  include ::Enumerable
  def alias?(); end

  def children(); end

  def document?(); end

  def each(&block); end

  def end_column(); end

  def end_column=(end_column); end

  def end_line(); end

  def end_line=(end_line); end

  def mapping?(); end

  def scalar?(); end

  def sequence?(); end

  def start_column(); end

  def start_column=(start_column); end

  def start_line(); end

  def start_line=(start_line); end

  def stream?(); end

  def tag(); end

  def to_ruby(); end

  def to_yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end

  def transform(); end

  def yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Psych::Nodes::Node
end

class Psych::Nodes::Scalar
  def anchor(); end

  def anchor=(anchor); end

  def initialize(value, anchor=T.unsafe(nil), tag=T.unsafe(nil), plain=T.unsafe(nil), quoted=T.unsafe(nil), style=T.unsafe(nil)); end

  def plain(); end

  def plain=(plain); end

  def quoted(); end

  def quoted=(quoted); end

  def style(); end

  def style=(style); end

  def tag=(tag); end

  def value(); end

  def value=(value); end
  ANY = ::T.let(nil, ::T.untyped)
  DOUBLE_QUOTED = ::T.let(nil, ::T.untyped)
  FOLDED = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
  PLAIN = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTED = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Scalar
end

class Psych::Nodes::Sequence
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Sequence
end

class Psych::Nodes::Stream
  def encoding(); end

  def encoding=(encoding); end

  def initialize(encoding=T.unsafe(nil)); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Stream
end

module Psych::Nodes
end

class Psych::Omap
end

class Psych::Omap
end

class Psych::Parser
  def external_encoding=(external_encoding); end

  def handler(); end

  def handler=(handler); end

  def initialize(handler=T.unsafe(nil)); end

  def mark(); end

  def parse(*_); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Parser::Mark
end

class Psych::Parser::Mark
end

class Psych::Parser
end

class Psych::ScalarScanner
  def class_loader(); end

  def initialize(class_loader); end

  def parse_int(string); end

  def parse_time(string); end

  def tokenize(string); end
  FLOAT = ::T.let(nil, ::T.untyped)
  INTEGER = ::T.let(nil, ::T.untyped)
  TIME = ::T.let(nil, ::T.untyped)
end

class Psych::ScalarScanner
end

class Psych::Set
end

class Psych::Set
end

class Psych::Stream
  include ::Psych::Streaming
end

class Psych::Stream::Emitter
  def end_document(implicit_end=T.unsafe(nil)); end
end

class Psych::Stream::Emitter
end

class Psych::Stream
  extend ::Psych::Streaming::ClassMethods
end

module Psych::Streaming
  def start(encoding=T.unsafe(nil)); end
end

module Psych::Streaming::ClassMethods
  def new(io); end
end

module Psych::Streaming::ClassMethods
end

module Psych::Streaming
end

class Psych::SyntaxError
  def column(); end

  def context(); end

  def file(); end

  def initialize(file, line, col, offset, problem, context); end

  def line(); end

  def offset(); end

  def problem(); end
end

class Psych::SyntaxError
end

class Psych::TreeBuilder
  def end_document(implicit_end=T.unsafe(nil)); end

  def root(); end
end

class Psych::TreeBuilder
end

module Psych::Visitors
end

class Psych::Visitors::DepthFirst
  def initialize(block); end
end

class Psych::Visitors::DepthFirst
end

class Psych::Visitors::Emitter
  def initialize(io, options=T.unsafe(nil)); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
end

class Psych::Visitors::Emitter
end

class Psych::Visitors::JSONTree
  include ::Psych::JSON::RubyEvents
end

class Psych::Visitors::JSONTree
  def self.create(options=T.unsafe(nil)); end
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::ToRuby
  def class_loader(); end

  def initialize(ss, class_loader); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
  SHOVEL = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::ToRuby
  def self.create(); end
end

class Psych::Visitors::Visitor
  def accept(target); end
  DISPATCH = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::Visitor
end

class Psych::Visitors::YAMLTree
  def <<(object); end

  def finish(); end

  def finished(); end

  def finished?(); end

  def initialize(emitter, ss, options); end

  def push(object); end

  def start(encoding=T.unsafe(nil)); end

  def started(); end

  def started?(); end

  def tree(); end

  def visit_Array(o); end

  def visit_BasicObject(o); end

  def visit_BigDecimal(o); end

  def visit_Class(o); end

  def visit_Complex(o); end

  def visit_Date(o); end

  def visit_DateTime(o); end

  def visit_Delegator(o); end

  def visit_Encoding(o); end

  def visit_Enumerator(o); end

  def visit_Exception(o); end

  def visit_FalseClass(o); end

  def visit_Float(o); end

  def visit_Hash(o); end

  def visit_Integer(o); end

  def visit_Module(o); end

  def visit_NameError(o); end

  def visit_NilClass(o); end

  def visit_Object(o); end

  def visit_Psych_Omap(o); end

  def visit_Psych_Set(o); end

  def visit_Range(o); end

  def visit_Rational(o); end

  def visit_Regexp(o); end

  def visit_String(o); end

  def visit_Struct(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end

  def visit_TrueClass(o); end
end

class Psych::Visitors::YAMLTree
  def self.create(options=T.unsafe(nil), emitter=T.unsafe(nil)); end
end

module Psych::Visitors
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump(o, io=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.dump_stream(*objects); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.load_file(path); end

  def self.load_stream(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil)); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.parse(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil)); end

  def self.parse_file(filename, fallback: T.unsafe(nil)); end

  def self.parse_stream(yaml, legacy_filename=T.unsafe(nil), filename: T.unsafe(nil), &block); end

  def self.parser(); end

  def self.remove_type(type_tag); end

  def self.safe_load(yaml, legacy_permitted_classes=T.unsafe(nil), legacy_permitted_symbols=T.unsafe(nil), legacy_aliases=T.unsafe(nil), legacy_filename=T.unsafe(nil), permitted_classes: T.unsafe(nil), permitted_symbols: T.unsafe(nil), aliases: T.unsafe(nil), filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.to_json(object); end
end

module PublicSuffix
  BANG = ::T.let(nil, ::T.untyped)
  DOT = ::T.let(nil, ::T.untyped)
  STAR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class PublicSuffix::List
  DEFAULT_LIST_PATH = ::T.let(nil, ::T.untyped)
end

module Puma
  HTTP_STATUS_CODES = ::T.let(nil, ::T.untyped)
  IS_JRUBY = ::T.let(nil, ::T.untyped)
  IS_WINDOWS = ::T.let(nil, ::T.untyped)
  Plugins = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
end

class Puma::Binder
  RACK_VERSION = ::T.let(nil, ::T.untyped)
end

class Puma::Client
  EmptyBody = ::T.let(nil, ::T.untyped)
end

module Puma::ConfigDefault
  DefaultRackup = ::T.let(nil, ::T.untyped)
  DefaultTCPHost = ::T.let(nil, ::T.untyped)
  DefaultTCPPort = ::T.let(nil, ::T.untyped)
  DefaultWorkerShutdownTimeout = ::T.let(nil, ::T.untyped)
  DefaultWorkerTimeout = ::T.let(nil, ::T.untyped)
end

module Puma::Const
  CGI_VER = ::T.let(nil, ::T.untyped)
  CHUNKED = ::T.let(nil, ::T.untyped)
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
  CLOSE = ::T.let(nil, ::T.untyped)
  CLOSE_CHUNKED = ::T.let(nil, ::T.untyped)
  CODE_NAME = ::T.let(nil, ::T.untyped)
  COLON = ::T.let(nil, ::T.untyped)
  CONNECTION_CLOSE = ::T.let(nil, ::T.untyped)
  CONNECTION_KEEP_ALIVE = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH2 = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH_S = ::T.let(nil, ::T.untyped)
  CONTINUE = ::T.let(nil, ::T.untyped)
  EARLY_HINTS = ::T.let(nil, ::T.untyped)
  ERROR_RESPONSE = ::T.let(nil, ::T.untyped)
  FAST_TRACK_KA_TIMEOUT = ::T.let(nil, ::T.untyped)
  FIRST_DATA_TIMEOUT = ::T.let(nil, ::T.untyped)
  GATEWAY_INTERFACE = ::T.let(nil, ::T.untyped)
  HALT_COMMAND = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  HIJACK = ::T.let(nil, ::T.untyped)
  HIJACK_IO = ::T.let(nil, ::T.untyped)
  HIJACK_P = ::T.let(nil, ::T.untyped)
  HTTP = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTPS_KEY = ::T.let(nil, ::T.untyped)
  HTTP_10_200 = ::T.let(nil, ::T.untyped)
  HTTP_11 = ::T.let(nil, ::T.untyped)
  HTTP_11_100 = ::T.let(nil, ::T.untyped)
  HTTP_11_200 = ::T.let(nil, ::T.untyped)
  HTTP_CONNECTION = ::T.let(nil, ::T.untyped)
  HTTP_EXPECT = ::T.let(nil, ::T.untyped)
  HTTP_HOST = ::T.let(nil, ::T.untyped)
  HTTP_INJECTION_REGEX = ::T.let(nil, ::T.untyped)
  HTTP_VERSION = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_FOR = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PROTO = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SCHEME = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SSL = ::T.let(nil, ::T.untyped)
  KEEP_ALIVE = ::T.let(nil, ::T.untyped)
  LINE_END = ::T.let(nil, ::T.untyped)
  LOCALHOST = ::T.let(nil, ::T.untyped)
  LOCALHOST_ADDR = ::T.let(nil, ::T.untyped)
  LOCALHOST_IP = ::T.let(nil, ::T.untyped)
  MAX_BODY = ::T.let(nil, ::T.untyped)
  MAX_FAST_INLINE = ::T.let(nil, ::T.untyped)
  MAX_HEADER = ::T.let(nil, ::T.untyped)
  NEWLINE = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  PERSISTENT_TIMEOUT = ::T.let(nil, ::T.untyped)
  PORT_443 = ::T.let(nil, ::T.untyped)
  PORT_80 = ::T.let(nil, ::T.untyped)
  PUMA_CONFIG = ::T.let(nil, ::T.untyped)
  PUMA_PEERCERT = ::T.let(nil, ::T.untyped)
  PUMA_SERVER_STRING = ::T.let(nil, ::T.untyped)
  PUMA_SOCKET = ::T.let(nil, ::T.untyped)
  PUMA_TMP_BASE = ::T.let(nil, ::T.untyped)
  PUMA_VERSION = ::T.let(nil, ::T.untyped)
  QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_AFTER_REPLY = ::T.let(nil, ::T.untyped)
  RACK_INPUT = ::T.let(nil, ::T.untyped)
  RACK_URL_SCHEME = ::T.let(nil, ::T.untyped)
  REMOTE_ADDR = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_PATH = ::T.let(nil, ::T.untyped)
  REQUEST_URI = ::T.let(nil, ::T.untyped)
  RESTART_COMMAND = ::T.let(nil, ::T.untyped)
  SERVER_NAME = ::T.let(nil, ::T.untyped)
  SERVER_PORT = ::T.let(nil, ::T.untyped)
  SERVER_PROTOCOL = ::T.let(nil, ::T.untyped)
  SERVER_SOFTWARE = ::T.let(nil, ::T.untyped)
  STOP_COMMAND = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING2 = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING_CHUNKED = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  WORKER_CHECK_INTERVAL = ::T.let(nil, ::T.untyped)
  WRITE_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Puma::Events
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puma::HttpParserError
end

class Puma::HttpParserError
end

class Puma::Launcher
  KEYS_NOT_TO_PERSIST_IN_STATE = ::T.let(nil, ::T.untyped)
end

module Puma::MiniSSL
  OPENSSL_LIBRARY_VERSION = ::T.let(nil, ::T.untyped)
  OPENSSL_NO_SSL3 = ::T.let(nil, ::T.untyped)
  OPENSSL_NO_TLS1 = ::T.let(nil, ::T.untyped)
  OPENSSL_NO_TLS1_1 = ::T.let(nil, ::T.untyped)
  OPENSSL_VERSION = ::T.let(nil, ::T.untyped)
  VERIFY_FAIL_IF_NO_PEER_CERT = ::T.let(nil, ::T.untyped)
  VERIFY_NONE = ::T.let(nil, ::T.untyped)
  VERIFY_PEER = ::T.let(nil, ::T.untyped)
end

class Puma::MiniSSL::SSLError
end

class Puma::MiniSSL::SSLError
end

class Puma::Plugin
  CALLER_FILE = ::T.let(nil, ::T.untyped)
end

class Puma::Reactor
  DefaultSleepFor = ::T.let(nil, ::T.untyped)
end

class Puma::Server
  ThreadLocalKey = ::T.let(nil, ::T.untyped)
end

class Puma::ThreadPool
  SHUTDOWN_GRACE_TIME = ::T.let(nil, ::T.untyped)
end

module Puma::Util
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
end

module RDoc::Text
  def expand_tabs(text); end

  def flush_left(text); end

  def markup(text); end

  def normalize_comment(text); end

  def parse(text, format=T.unsafe(nil)); end

  def snippet(text, limit=T.unsafe(nil)); end

  def strip_hashes(text); end

  def strip_newlines(text); end

  def strip_stars(text); end

  def to_html(text); end

  def wrap(txt, line_len=T.unsafe(nil)); end
  MARKUP_FORMAT = ::T.let(nil, ::T.untyped)
  TO_HTML_CHARACTERS = ::T.let(nil, ::T.untyped)
end

module RDoc::Text
  def self.encode_fallback(character, encoding, fallback); end
end

module REXML
  COPYRIGHT = ::T.let(nil, ::T.untyped)
  Copyright = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  REVISION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class REXML::AttlistDecl
  include ::Enumerable
  def [](key); end

  def each(&block); end

  def element_name(); end

  def include?(key); end

  def initialize(source); end

  def node_type(); end

  def write(out, indent=T.unsafe(nil)); end
end

class REXML::AttlistDecl
end

class REXML::Attribute
  include ::REXML::Node
  include ::REXML::Namespace
  include ::REXML::XMLTokens
  def ==(other); end

  def clone(); end

  def doctype(); end

  def element(); end

  def element=(element); end

  def initialize(first, second=T.unsafe(nil), parent=T.unsafe(nil)); end

  def namespace(arg=T.unsafe(nil)); end

  def node_type(); end

  def normalized=(normalized); end

  def remove(); end

  def to_s(); end

  def to_string(); end

  def value(); end

  def write(output, indent=T.unsafe(nil)); end

  def xpath(); end
  NEEDS_A_SECOND_CHECK = ::T.let(nil, ::T.untyped)
  PATTERN = ::T.let(nil, ::T.untyped)
end

class REXML::Attribute
end

class REXML::Attributes
  def <<(attribute); end

  def [](name); end

  def []=(name, value); end

  def add(attribute); end

  def delete(attribute); end

  def delete_all(name); end

  def each_attribute(); end

  def get_attribute(name); end

  def get_attribute_ns(namespace, name); end

  def initialize(element); end

  def namespaces(); end

  def prefixes(); end
end

class REXML::Attributes
end

class REXML::CData
  def initialize(first, whitespace=T.unsafe(nil), parent=T.unsafe(nil)); end

  def write(output=T.unsafe(nil), indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  ILLEGAL = ::T.let(nil, ::T.untyped)
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::CData
end

class REXML::Child
  include ::REXML::Node
  def bytes(); end

  def document(); end

  def initialize(parent=T.unsafe(nil)); end

  def next_sibling(); end

  def next_sibling=(other); end

  def parent(); end

  def parent=(other); end

  def previous_sibling(); end

  def previous_sibling=(other); end

  def remove(); end

  def replace_with(child); end
end

class REXML::Child
end

class REXML::Comment
  include ::Comparable
  def ==(other); end

  def clone(); end

  def initialize(first, second=T.unsafe(nil)); end

  def node_type(); end

  def string(); end

  def string=(string); end

  def to_s(); end

  def write(output, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::Comment
end

class REXML::Declaration
  def initialize(src); end

  def to_s(); end

  def write(output, indent); end
end

class REXML::Declaration
end

class REXML::DocType
  include ::REXML::XMLTokens
  def add(child); end

  def attribute_of(element, attribute); end

  def attributes_of(element); end

  def clone(); end

  def context(); end

  def entities(); end

  def entity(name); end

  def external_id(); end

  def initialize(first, parent=T.unsafe(nil)); end

  def name(); end

  def namespaces(); end

  def node_type(); end

  def notation(name); end

  def notations(); end

  def public(); end

  def system(); end

  def write(output, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  DEFAULT_ENTITIES = ::T.let(nil, ::T.untyped)
  PUBLIC = ::T.let(nil, ::T.untyped)
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
  SYSTEM = ::T.let(nil, ::T.untyped)
end

class REXML::DocType
end

class REXML::Document
  def <<(child); end

  def add(child); end

  def add_element(arg=T.unsafe(nil), arg2=T.unsafe(nil)); end

  def doctype(); end

  def encoding(); end

  def entity_expansion_count(); end

  def initialize(source=T.unsafe(nil), context=T.unsafe(nil)); end

  def record_entity_expansion(); end

  def stand_alone?(); end

  def version(); end

  def write(*arguments); end

  def xml_decl(); end
  DECLARATION = ::T.let(nil, ::T.untyped)
end

class REXML::Document
  def self.entity_expansion_limit(); end

  def self.entity_expansion_limit=(val); end

  def self.entity_expansion_text_limit(); end

  def self.entity_expansion_text_limit=(val); end

  def self.parse_stream(source, listener); end
end

class REXML::Element
  include ::REXML::Namespace
  include ::REXML::XMLTokens
  def [](name_or_index); end

  def add_attribute(key, value=T.unsafe(nil)); end

  def add_attributes(hash); end

  def add_element(element, attrs=T.unsafe(nil)); end

  def add_namespace(prefix, uri=T.unsafe(nil)); end

  def add_text(text); end

  def attribute(name, namespace=T.unsafe(nil)); end

  def attributes(); end

  def cdatas(); end

  def clone(); end

  def comments(); end

  def context(); end

  def context=(context); end

  def delete_attribute(key); end

  def delete_element(element); end

  def delete_namespace(namespace=T.unsafe(nil)); end

  def each_element(xpath=T.unsafe(nil), &block); end

  def each_element_with_attribute(key, value=T.unsafe(nil), max=T.unsafe(nil), name=T.unsafe(nil), &block); end

  def each_element_with_text(text=T.unsafe(nil), max=T.unsafe(nil), name=T.unsafe(nil), &block); end

  def elements(); end

  def get_elements(xpath); end

  def get_text(path=T.unsafe(nil)); end

  def has_attributes?(); end

  def has_elements?(); end

  def has_text?(); end

  def ignore_whitespace_nodes(); end

  def initialize(arg=T.unsafe(nil), parent=T.unsafe(nil), context=T.unsafe(nil)); end

  def instructions(); end

  def namespace(prefix=T.unsafe(nil)); end

  def namespaces(); end

  def next_element(); end

  def node_type(); end

  def prefixes(); end

  def previous_element(); end

  def raw(); end

  def root(); end

  def root_node(); end

  def text(path=T.unsafe(nil)); end

  def text=(text); end

  def texts(); end

  def whitespace(); end

  def write(output=T.unsafe(nil), indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def xpath(); end
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

class REXML::Element
end

class REXML::ElementDecl
end

class REXML::ElementDecl
end

class REXML::Elements
  include ::Enumerable
  def <<(element=T.unsafe(nil)); end

  def [](index, name=T.unsafe(nil)); end

  def []=(index, element); end

  def add(element=T.unsafe(nil)); end

  def collect(xpath=T.unsafe(nil)); end

  def delete(element); end

  def delete_all(xpath); end

  def each(xpath=T.unsafe(nil), &blk); end

  def empty?(); end

  def index(element); end

  def initialize(parent); end

  def inject(xpath=T.unsafe(nil), initial=T.unsafe(nil)); end

  def size(); end

  def to_a(xpath=T.unsafe(nil)); end
end

class REXML::Elements
end

module REXML::Encoding
  def decode(string); end

  def encode(string); end

  def encoding(); end

  def encoding=(encoding); end
end

module REXML::Encoding
end

class REXML::Entity
  include ::REXML::XMLTokens
  def external(); end

  def initialize(stream, value=T.unsafe(nil), parent=T.unsafe(nil), reference=T.unsafe(nil)); end

  def name(); end

  def ndata(); end

  def normalized(); end

  def pubid(); end

  def ref(); end

  def to_s(); end

  def unnormalized(); end

  def value(); end

  def write(out, indent=T.unsafe(nil)); end
  ENTITYDECL = ::T.let(nil, ::T.untyped)
  ENTITYDEF = ::T.let(nil, ::T.untyped)
  ENTITYVALUE = ::T.let(nil, ::T.untyped)
  EXTERNALID = ::T.let(nil, ::T.untyped)
  GEDECL = ::T.let(nil, ::T.untyped)
  NDATADECL = ::T.let(nil, ::T.untyped)
  PEDECL = ::T.let(nil, ::T.untyped)
  PEDEF = ::T.let(nil, ::T.untyped)
  PEREFERENCE = ::T.let(nil, ::T.untyped)
  PEREFERENCE_RE = ::T.let(nil, ::T.untyped)
  PUBIDCHAR = ::T.let(nil, ::T.untyped)
  PUBIDLITERAL = ::T.let(nil, ::T.untyped)
  SYSTEMLITERAL = ::T.let(nil, ::T.untyped)
end

class REXML::Entity
  def self.matches?(string); end
end

module REXML::EntityConst
  AMP = ::T.let(nil, ::T.untyped)
  APOS = ::T.let(nil, ::T.untyped)
  GT = ::T.let(nil, ::T.untyped)
  LT = ::T.let(nil, ::T.untyped)
  QUOT = ::T.let(nil, ::T.untyped)
end

module REXML::EntityConst
end

class REXML::ExternalEntity
  def initialize(src); end

  def to_s(); end

  def write(output, indent); end
end

class REXML::ExternalEntity
end

module REXML::Formatters
end

class REXML::Formatters::Default
  def initialize(ie_hack=T.unsafe(nil)); end

  def write(node, output); end

  def write_cdata(node, output); end

  def write_comment(node, output); end

  def write_document(node, output); end

  def write_element(node, output); end

  def write_instruction(node, output); end

  def write_text(node, output); end
end

class REXML::Formatters::Default
end

class REXML::Formatters::Pretty
  def compact(); end

  def compact=(compact); end

  def initialize(indentation=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def width(); end

  def width=(width); end
end

class REXML::Formatters::Pretty
end

module REXML::Formatters
end

module REXML::Functions
  INTERNAL_METHODS = ::T.let(nil, ::T.untyped)
end

module REXML::Functions
  def self.boolean(object=T.unsafe(nil)); end

  def self.ceiling(number); end

  def self.compare_language(lang1, lang2); end

  def self.concat(*objects); end

  def self.contains(string, test); end

  def self.context=(value); end

  def self.count(node_set); end

  def self.false(); end

  def self.floor(number); end

  def self.get_namespace(node_set=T.unsafe(nil)); end

  def self.id(object); end

  def self.lang(language); end

  def self.last(); end

  def self.local_name(node_set=T.unsafe(nil)); end

  def self.name(node_set=T.unsafe(nil)); end

  def self.namespace_context(); end

  def self.namespace_context=(x); end

  def self.namespace_uri(node_set=T.unsafe(nil)); end

  def self.normalize_space(string=T.unsafe(nil)); end

  def self.not(object); end

  def self.number(object=T.unsafe(nil)); end

  def self.position(); end

  def self.processing_instruction(node); end

  def self.round(number); end

  def self.send(name, *args); end

  def self.singleton_method_added(name); end

  def self.starts_with(string, test); end

  def self.string(object=T.unsafe(nil)); end

  def self.string_length(string); end

  def self.string_value(o); end

  def self.substring(string, start, length=T.unsafe(nil)); end

  def self.substring_after(string, test); end

  def self.substring_before(string, test); end

  def self.sum(nodes); end

  def self.text(); end

  def self.translate(string, tr1, tr2); end

  def self.true(); end

  def self.variables(); end

  def self.variables=(x); end
end

class REXML::IOSource
  def initialize(arg, block_size=T.unsafe(nil), encoding=T.unsafe(nil)); end
end

class REXML::IOSource
end

class REXML::Instruction
  def ==(other); end

  def clone(); end

  def content(); end

  def content=(content); end

  def initialize(target, content=T.unsafe(nil)); end

  def node_type(); end

  def target(); end

  def target=(target); end

  def write(writer, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::Instruction
end

module REXML::Namespace
  include ::REXML::XMLTokens
  def expanded_name(); end

  def fully_expanded_name(); end

  def has_name?(other, ns=T.unsafe(nil)); end

  def local_name(); end

  def name(); end

  def name=(name); end

  def prefix(); end

  def prefix=(prefix); end
  NAMESPLIT = ::T.let(nil, ::T.untyped)
end

module REXML::Namespace
end

module REXML::Node
  def each_recursive(&block); end

  def find_first_recursive(&block); end

  def indent(to, ind); end

  def index_in_parent(); end

  def next_sibling_node(); end

  def parent?(); end

  def previous_sibling_node(); end

  def to_s(indent=T.unsafe(nil)); end
end

module REXML::Node
end

class REXML::NotationDecl
  def initialize(name, middle, pub, sys); end

  def name(); end

  def public(); end

  def public=(public); end

  def system(); end

  def system=(system); end

  def to_s(); end

  def write(output, indent=T.unsafe(nil)); end
end

class REXML::NotationDecl
end

class REXML::Output
  include ::REXML::Encoding
  def <<(content); end

  def initialize(real_IO, encd=T.unsafe(nil)); end
end

class REXML::Output
end

class REXML::Parent
  include ::Enumerable
  def <<(object); end

  def [](index); end

  def []=(*args); end

  def add(object); end

  def children(); end

  def deep_clone(); end

  def delete(object); end

  def delete_at(index); end

  def delete_if(&block); end

  def each(&block); end

  def each_child(&block); end

  def each_index(&block); end

  def index(child); end

  def insert_after(child1, child2); end

  def insert_before(child1, child2); end

  def length(); end

  def push(object); end

  def replace_child(to_replace, replacement); end

  def size(); end

  def to_a(); end

  def unshift(object); end
end

class REXML::Parent
end

class REXML::ParseException
  def context(); end

  def continued_exception(); end

  def continued_exception=(continued_exception); end

  def initialize(message, source=T.unsafe(nil), parser=T.unsafe(nil), exception=T.unsafe(nil)); end

  def line(); end

  def parser(); end

  def parser=(parser); end

  def position(); end

  def source(); end

  def source=(source); end
end

class REXML::ParseException
end

module REXML::Parsers
end

class REXML::Parsers::BaseParser
  def add_listener(listener); end

  def empty?(); end

  def entity(reference, entities); end

  def has_next?(); end

  def initialize(source); end

  def normalize(input, entities=T.unsafe(nil), entity_filter=T.unsafe(nil)); end

  def peek(depth=T.unsafe(nil)); end

  def position(); end

  def pull(); end

  def source(); end

  def stream=(source); end

  def unnormalize(string, entities=T.unsafe(nil), filter=T.unsafe(nil)); end

  def unshift(token); end
  ATTDEF = ::T.let(nil, ::T.untyped)
  ATTDEF_RE = ::T.let(nil, ::T.untyped)
  ATTLISTDECL_PATTERN = ::T.let(nil, ::T.untyped)
  ATTLISTDECL_START = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_PATTERN = ::T.let(nil, ::T.untyped)
  ATTTYPE = ::T.let(nil, ::T.untyped)
  ATTVALUE = ::T.let(nil, ::T.untyped)
  CDATA_END = ::T.let(nil, ::T.untyped)
  CDATA_PATTERN = ::T.let(nil, ::T.untyped)
  CDATA_START = ::T.let(nil, ::T.untyped)
  CLOSE_MATCH = ::T.let(nil, ::T.untyped)
  COMBININGCHAR = ::T.let(nil, ::T.untyped)
  COMMENT_PATTERN = ::T.let(nil, ::T.untyped)
  COMMENT_START = ::T.let(nil, ::T.untyped)
  DEFAULTDECL = ::T.let(nil, ::T.untyped)
  DEFAULT_ENTITIES = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  DOCTYPE_END = ::T.let(nil, ::T.untyped)
  DOCTYPE_PATTERN = ::T.let(nil, ::T.untyped)
  DOCTYPE_START = ::T.let(nil, ::T.untyped)
  ELEMENTDECL_PATTERN = ::T.let(nil, ::T.untyped)
  ELEMENTDECL_START = ::T.let(nil, ::T.untyped)
  ENCODING = ::T.let(nil, ::T.untyped)
  ENTITYDECL = ::T.let(nil, ::T.untyped)
  ENTITYDEF = ::T.let(nil, ::T.untyped)
  ENTITYVALUE = ::T.let(nil, ::T.untyped)
  ENTITY_START = ::T.let(nil, ::T.untyped)
  ENUMERATEDTYPE = ::T.let(nil, ::T.untyped)
  ENUMERATION = ::T.let(nil, ::T.untyped)
  EREFERENCE = ::T.let(nil, ::T.untyped)
  EXTENDER = ::T.let(nil, ::T.untyped)
  EXTERNALID = ::T.let(nil, ::T.untyped)
  GEDECL = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  INSTRUCTION_PATTERN = ::T.let(nil, ::T.untyped)
  INSTRUCTION_START = ::T.let(nil, ::T.untyped)
  LETTER = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  NAMECHAR = ::T.let(nil, ::T.untyped)
  NCNAME_STR = ::T.let(nil, ::T.untyped)
  NDATADECL = ::T.let(nil, ::T.untyped)
  NMTOKEN = ::T.let(nil, ::T.untyped)
  NMTOKENS = ::T.let(nil, ::T.untyped)
  NOTATIONDECL_START = ::T.let(nil, ::T.untyped)
  NOTATIONTYPE = ::T.let(nil, ::T.untyped)
  PEDECL = ::T.let(nil, ::T.untyped)
  PEDEF = ::T.let(nil, ::T.untyped)
  PEREFERENCE = ::T.let(nil, ::T.untyped)
  PUBIDCHAR = ::T.let(nil, ::T.untyped)
  PUBIDLITERAL = ::T.let(nil, ::T.untyped)
  PUBLIC = ::T.let(nil, ::T.untyped)
  QNAME = ::T.let(nil, ::T.untyped)
  QNAME_STR = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
  REFERENCE_RE = ::T.let(nil, ::T.untyped)
  STANDALONE = ::T.let(nil, ::T.untyped)
  SYSTEM = ::T.let(nil, ::T.untyped)
  SYSTEMENTITY = ::T.let(nil, ::T.untyped)
  SYSTEMLITERAL = ::T.let(nil, ::T.untyped)
  TAG_MATCH = ::T.let(nil, ::T.untyped)
  TEXT_PATTERN = ::T.let(nil, ::T.untyped)
  UNAME_STR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  XMLDECL_PATTERN = ::T.let(nil, ::T.untyped)
  XMLDECL_START = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::BaseParser
end

class REXML::Parsers::StreamParser
  def add_listener(listener); end

  def initialize(source, listener); end

  def parse(); end
end

class REXML::Parsers::StreamParser
end

class REXML::Parsers::TreeParser
  def add_listener(listener); end

  def initialize(source, build_context=T.unsafe(nil)); end

  def parse(); end
end

class REXML::Parsers::TreeParser
end

class REXML::Parsers::XPathParser
  include ::REXML::XMLTokens
  def abbreviate(path); end

  def expand(path); end

  def namespaces=(namespaces); end

  def parse(path); end

  def predicate(path); end

  def predicate_to_string(path, &block); end
  AXIS = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
  LOCAL_NAME_WILDCARD = ::T.let(nil, ::T.untyped)
  NODE_TYPE = ::T.let(nil, ::T.untyped)
  NT = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  PI = ::T.let(nil, ::T.untyped)
  PREFIX_WILDCARD = ::T.let(nil, ::T.untyped)
  QNAME = ::T.let(nil, ::T.untyped)
  VARIABLE_REFERENCE = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::XPathParser
end

module REXML::Parsers
end

module REXML::Security
end

module REXML::Security
  def self.entity_expansion_limit(); end

  def self.entity_expansion_limit=(val); end

  def self.entity_expansion_text_limit(); end

  def self.entity_expansion_text_limit=(val); end
end

class REXML::Source
  include ::REXML::Encoding
  def buffer(); end

  def consume(pattern); end

  def current_line(); end

  def empty?(); end

  def encoding=(enc); end

  def initialize(arg, encoding=T.unsafe(nil)); end

  def line(); end

  def match(pattern, cons=T.unsafe(nil)); end

  def match_to(char, pattern); end

  def match_to_consume(char, pattern); end

  def position(); end

  def read(); end

  def scan(pattern, cons=T.unsafe(nil)); end
end

class REXML::Source
end

class REXML::SourceFactory
end

class REXML::SourceFactory
  def self.create_from(arg); end
end

module REXML::StreamListener
  def attlistdecl(element_name, attributes, raw_content); end

  def cdata(content); end

  def comment(comment); end

  def doctype(name, pub_sys, long_name, uri); end

  def doctype_end(); end

  def elementdecl(content); end

  def entity(content); end

  def entitydecl(content); end

  def instruction(name, instruction); end

  def notationdecl(content); end

  def tag_end(name); end

  def tag_start(name, attrs); end

  def text(text); end

  def xmldecl(version, encoding, standalone); end
end

module REXML::StreamListener
end

class REXML::Text
  include ::Comparable
  def <<(to_append); end

  def clone(); end

  def doctype(); end

  def empty?(); end

  def indent_text(string, level=T.unsafe(nil), style=T.unsafe(nil), indentfirstline=T.unsafe(nil)); end

  def initialize(arg, respect_whitespace=T.unsafe(nil), parent=T.unsafe(nil), raw=T.unsafe(nil), entity_filter=T.unsafe(nil), illegal=T.unsafe(nil)); end

  def node_type(); end

  def parent=(parent); end

  def raw(); end

  def raw=(raw); end

  def to_s(); end

  def value(); end

  def value=(val); end

  def wrap(string, width, addnewline=T.unsafe(nil)); end

  def write(writer, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def write_with_substitution(out, input); end

  def xpath(); end
  EREFERENCE = ::T.let(nil, ::T.untyped)
  NEEDS_A_SECOND_CHECK = ::T.let(nil, ::T.untyped)
  NUMERICENTITY = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
  SETUTITSBUS = ::T.let(nil, ::T.untyped)
  SLAICEPS = ::T.let(nil, ::T.untyped)
  SPECIALS = ::T.let(nil, ::T.untyped)
  SUBSTITUTES = ::T.let(nil, ::T.untyped)
  VALID_CHAR = ::T.let(nil, ::T.untyped)
  VALID_XML_CHARS = ::T.let(nil, ::T.untyped)
end

class REXML::Text
  def self.check(string, pattern, doctype); end

  def self.expand(ref, doctype, filter); end

  def self.normalize(input, doctype=T.unsafe(nil), entity_filter=T.unsafe(nil)); end

  def self.read_with_substitution(input, illegal=T.unsafe(nil)); end

  def self.unnormalize(string, doctype=T.unsafe(nil), filter=T.unsafe(nil), illegal=T.unsafe(nil)); end
end

class REXML::UndefinedNamespaceException
  def initialize(prefix, source, parser); end
end

class REXML::UndefinedNamespaceException
end

module REXML::Validation
end

class REXML::Validation::ValidationException
  def initialize(msg); end
end

class REXML::Validation::ValidationException
end

module REXML::Validation
end

class REXML::XMLDecl
  include ::REXML::Encoding
  def ==(other); end

  def clone(); end

  def dowrite(); end

  def encoding=(enc); end

  def initialize(version=T.unsafe(nil), encoding=T.unsafe(nil), standalone=T.unsafe(nil)); end

  def node_type(); end

  def nowrite(); end

  def old_enc=(encoding); end

  def stand_alone?(); end

  def standalone(); end

  def standalone=(standalone); end

  def version(); end

  def version=(version); end

  def write(writer, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def writeencoding(); end

  def writethis(); end

  def xmldecl(version, encoding, standalone); end
  DEFAULT_ENCODING = ::T.let(nil, ::T.untyped)
  DEFAULT_STANDALONE = ::T.let(nil, ::T.untyped)
  DEFAULT_VERSION = ::T.let(nil, ::T.untyped)
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::XMLDecl
  def self.default(); end
end

module REXML::XMLTokens
  NAME = ::T.let(nil, ::T.untyped)
  NAMECHAR = ::T.let(nil, ::T.untyped)
  NAME_CHAR = ::T.let(nil, ::T.untyped)
  NAME_START_CHAR = ::T.let(nil, ::T.untyped)
  NAME_STR = ::T.let(nil, ::T.untyped)
  NCNAME_STR = ::T.let(nil, ::T.untyped)
  NMTOKEN = ::T.let(nil, ::T.untyped)
  NMTOKENS = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
end

module REXML::XMLTokens
end

class REXML::XPath
  include ::REXML::Functions
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
end

class REXML::XPath
  def self.each(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.first(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.match(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil), options=T.unsafe(nil)); end
end

class REXML::XPathNode
  def context(); end

  def initialize(node, context=T.unsafe(nil)); end

  def position(); end

  def raw_node(); end
end

class REXML::XPathNode
end

class REXML::XPathParser
  include ::REXML::XMLTokens
  def []=(variable_name, value); end

  def first(path_stack, node); end

  def get_first(path, nodeset); end

  def initialize(strict: T.unsafe(nil)); end

  def match(path_stack, nodeset); end

  def namespaces=(namespaces=T.unsafe(nil)); end

  def parse(path, nodeset); end

  def predicate(path, nodeset); end

  def variables=(vars=T.unsafe(nil)); end
  DEBUG = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
end

class REXML::XPathParser
end

module REXML
end

module Racc
  Racc_No_Extensions = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

module Rack
  CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  ETAG = ::T.let(nil, ::T.untyped)
  EXPIRES = ::T.let(nil, ::T.untyped)
  GET = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTP_COOKIE = ::T.let(nil, ::T.untyped)
  HTTP_HOST = ::T.let(nil, ::T.untyped)
  HTTP_PORT = ::T.let(nil, ::T.untyped)
  HTTP_VERSION = ::T.let(nil, ::T.untyped)
  LINK = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  POST = ::T.let(nil, ::T.untyped)
  PUT = ::T.let(nil, ::T.untyped)
  QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_ERRORS = ::T.let(nil, ::T.untyped)
  RACK_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_HIJACK_IO = ::T.let(nil, ::T.untyped)
  RACK_INPUT = ::T.let(nil, ::T.untyped)
  RACK_IS_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_LOGGER = ::T.let(nil, ::T.untyped)
  RACK_METHODOVERRIDE_ORIGINAL_METHOD = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  RACK_MULTIPROCESS = ::T.let(nil, ::T.untyped)
  RACK_MULTITHREAD = ::T.let(nil, ::T.untyped)
  RACK_RECURSIVE_INCLUDE = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_STRING = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_INPUT = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_VARS = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_RUNONCE = ::T.let(nil, ::T.untyped)
  RACK_SESSION = ::T.let(nil, ::T.untyped)
  RACK_SESSION_OPTIONS = ::T.let(nil, ::T.untyped)
  RACK_SESSION_UNPACKED_COOKIE_DATA = ::T.let(nil, ::T.untyped)
  RACK_SHOWSTATUS_DETAIL = ::T.let(nil, ::T.untyped)
  RACK_TEMPFILES = ::T.let(nil, ::T.untyped)
  RACK_URL_SCHEME = ::T.let(nil, ::T.untyped)
  RACK_VERSION = ::T.let(nil, ::T.untyped)
  RELEASE = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_PATH = ::T.let(nil, ::T.untyped)
  SCRIPT_NAME = ::T.let(nil, ::T.untyped)
  SERVER_NAME = ::T.let(nil, ::T.untyped)
  SERVER_PORT = ::T.let(nil, ::T.untyped)
  SERVER_PROTOCOL = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
  TRACE = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  UNLINK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::AbstractRequest
  AUTHORIZATION_KEYS = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::MD5
  QOP = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::Params
  UNQUOTED = ::T.let(nil, ::T.untyped)
end

class Rack::Builder
  def call(env); end

  def freeze_app(); end

  def initialize(default_app=T.unsafe(nil), &block); end

  def map(path, &block); end

  def run(app); end

  def to_app(); end

  def use(middleware, *args, &block); end

  def warmup(prc=T.unsafe(nil), &block); end
  UTF_8_BOM = ::T.let(nil, ::T.untyped)
end

class Rack::Builder
  def self.app(default_app=T.unsafe(nil), &block); end

  def self.load_file(path, opts=T.unsafe(nil)); end

  def self.new_from_string(builder_script, file=T.unsafe(nil)); end

  def self.parse_file(config, opts=T.unsafe(nil)); end
end

class Rack::Cascade
  NotFound = ::T.let(nil, ::T.untyped)
end

class Rack::Chunked::Body
  TAIL = ::T.let(nil, ::T.untyped)
  TERM = ::T.let(nil, ::T.untyped)
end

class Rack::CommonLogger
  FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::Directory
  DIR_FILE = ::T.let(nil, ::T.untyped)
  DIR_PAGE_FOOTER = ::T.let(nil, ::T.untyped)
  DIR_PAGE_HEADER = ::T.let(nil, ::T.untyped)
  FILESIZE_FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::ETag
  DEFAULT_CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  ETAG_STRING = ::T.let(nil, ::T.untyped)
end

Rack::File = Rack::Files

class Rack::Files
  ALLOWED_VERBS = ::T.let(nil, ::T.untyped)
  ALLOW_HEADER = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
end

class Rack::Handler::CGI
end

class Rack::Handler::CGI
  def self.run(app, **options); end

  def self.send_body(body); end

  def self.send_headers(status, headers); end

  def self.serve(app); end
end

class Rack::Handler::WEBrick
  def initialize(server, app); end
end

class Rack::Handler::WEBrick
  def self.run(app, **options); end

  def self.shutdown(); end

  def self.valid_options(); end
end

class Rack::Lint::HijackWrapper
  REQUIRED_METHODS = ::T.let(nil, ::T.untyped)
end

class Rack::MediaType
  SPLIT_PATTERN = ::T.let(nil, ::T.untyped)
end

class Rack::MethodOverride
  ALLOWED_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_OVERRIDE_HEADER = ::T.let(nil, ::T.untyped)
  METHOD_OVERRIDE_PARAM_KEY = ::T.let(nil, ::T.untyped)
end

module Rack::Mime
  MIME_TYPES = ::T.let(nil, ::T.untyped)
end

class Rack::MockRequest
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

module Rack::Multipart
  ATTRIBUTE = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_CHAR = ::T.let(nil, ::T.untyped)
  BROKEN_QUOTED = ::T.let(nil, ::T.untyped)
  BROKEN_UNQUOTED = ::T.let(nil, ::T.untyped)
  CONDISP = ::T.let(nil, ::T.untyped)
  DISPPARM = ::T.let(nil, ::T.untyped)
  EOL = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_PARAMETER = ::T.let(nil, ::T.untyped)
  MULTIPART = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_DISPOSITION = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_ID = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER_NAME = ::T.let(nil, ::T.untyped)
  RFC2183 = ::T.let(nil, ::T.untyped)
  SECTION = ::T.let(nil, ::T.untyped)
  TOKEN = ::T.let(nil, ::T.untyped)
  VALUE = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Generator
  def dump(); end

  def initialize(params, first=T.unsafe(nil)); end
end

class Rack::Multipart::Generator
end

class Rack::Multipart::Parser
  BOUNDARY_REGEX = ::T.let(nil, ::T.untyped)
  BUFSIZE = ::T.let(nil, ::T.untyped)
  CHARSET = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  TEXT_PLAIN = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::UploadedFile
  def content_type(); end

  def content_type=(content_type); end

  def initialize(filepath=T.unsafe(nil), ct=T.unsafe(nil), bin=T.unsafe(nil), path: T.unsafe(nil), content_type: T.unsafe(nil), binary: T.unsafe(nil), filename: T.unsafe(nil), io: T.unsafe(nil)); end

  def local_path(); end

  def method_missing(method_name, *args, &block); end

  def original_filename(); end

  def path(); end

  def respond_to?(*args); end
end

class Rack::Multipart::UploadedFile
end

class Rack::Proxy
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::QueryParser
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
end

class Rack::Request
  def query(); end

  def version_supplied(); end

  def version_supplied=(version_supplied); end
  ALLOWED_SCHEMES = ::T.let(nil, ::T.untyped)
  SCHEME_WHITELIST = ::T.let(nil, ::T.untyped)
end

module Rack::Request::Helpers
  DEFAULT_PORTS = ::T.let(nil, ::T.untyped)
  FORM_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_FOR = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_HOST = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PORT = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PROTO = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SCHEME = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SSL = ::T.let(nil, ::T.untyped)
  PARSEABLE_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
end

class Rack::Response
  CHUNKED = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
end

class Rack::Runtime
  FORMAT_STRING = ::T.let(nil, ::T.untyped)
  HEADER_NAME = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::Persisted
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::SessionHash
  Unspecified = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Pool
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::SessionId
  ID_VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::ShowExceptions
  CONTEXT = ::T.let(nil, ::T.untyped)
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowStatus
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

module Rack::Test
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Test::CookieJar
  DELIMITER = ::T.let(nil, ::T.untyped)
end

module Rack::Test::Methods
  METHODS = ::T.let(nil, ::T.untyped)
end

module Rack::Utils
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML_PATTERN = ::T.let(nil, ::T.untyped)
  HTTP_STATUS_CODES = ::T.let(nil, ::T.untyped)
  NULL_BYTE = ::T.let(nil, ::T.untyped)
  PATH_SEPS = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
  SYMBOL_TO_STATUS_CODE = ::T.let(nil, ::T.untyped)
end

Rack::Utils::InvalidParameterError = Rack::QueryParser::InvalidParameterError

Rack::Utils::KeySpaceConstrainedParams = Rack::QueryParser::Params

Rack::Utils::ParameterTypeError = Rack::QueryParser::ParameterTypeError

class Rails::Application
  INITIAL_VARIABLES = ::T.let(nil, ::T.untyped)
end

class Rails::ApplicationController
end

class Rails::ApplicationController
end

module Rails::Autoloaders
  extend ::Enumerable
end

class Rails::BacktraceCleaner
  APP_DIRS_PATTERN = ::T.let(nil, ::T.untyped)
  DOT_SLASH = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  RENDER_TEMPLATE_PATTERN = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
end

module Rails::Command
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
end

module Rails::Command::Actions
  def load_generators(); end

  def load_tasks(); end

  def require_application!(); end

  def require_application_and_environment!(); end

  def require_environment!(); end

  def set_application_directory!(); end
end

module Rails::Command::Actions
end

class Rails::Command::Base
  include ::Rails::Command::Actions
  def help(); end
end

class Rails::Command::Base::Error
end

class Rails::Command::Base::Error
end

class Rails::Command::Base
  def self.banner(*_); end

  def self.base_name(); end

  def self.command_name(); end

  def self.default_command_root(); end

  def self.desc(usage=T.unsafe(nil), description=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.engine?(); end

  def self.executable(); end

  def self.hide_command!(); end

  def self.inherited(base); end

  def self.perform(command, args, config); end

  def self.printing_commands(); end

  def self.usage_path(); end
end

module Rails::Command::Spellchecker
end

module Rails::Command::Spellchecker
  def self.suggest(word, from:); end
end

module Rails::Conductor
end

module Rails::Conductor::ActionMailbox
end

class Rails::Conductor::ActionMailbox::InboundEmailsController
  def create(); end

  def index(); end

  def new(); end

  def show(); end
end

class Rails::Conductor::ActionMailbox::InboundEmailsController
end

class Rails::Conductor::ActionMailbox::ReroutesController
  def create(); end
end

class Rails::Conductor::ActionMailbox::ReroutesController
end

module Rails::Conductor::ActionMailbox
end

class Rails::Conductor::BaseController
end

class Rails::Conductor::BaseController
end

module Rails::Conductor
end

module Rails::Generators
  DEFAULT_ALIASES = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

module Rails::Generators::Actions
  def add_source(source, options=T.unsafe(nil), &block); end

  def application(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def environment(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def gem(*args); end

  def gem_group(*names, &block); end

  def generate(what, *args); end

  def git(commands=T.unsafe(nil)); end

  def github(repo, options=T.unsafe(nil), &block); end

  def initialize(*_); end

  def initializer(filename, data=T.unsafe(nil)); end

  def lib(filename, data=T.unsafe(nil)); end

  def rails_command(command, options=T.unsafe(nil)); end

  def rake(command, options=T.unsafe(nil)); end

  def rakefile(filename, data=T.unsafe(nil)); end

  def readme(path); end

  def route(routing_code); end

  def vendor(filename, data=T.unsafe(nil)); end
end

class Rails::Generators::Actions::CreateMigration
  def existing_migration(); end

  def migration_dir(); end

  def migration_file_name(); end

  def relative_existing_migration(); end
end

class Rails::Generators::Actions::CreateMigration
end

module Rails::Generators::Actions
end

class Rails::Generators::ActiveModel
  def destroy(); end

  def errors(); end

  def initialize(name); end

  def name(); end

  def save(); end

  def update(params=T.unsafe(nil)); end
end

class Rails::Generators::ActiveModel
  def self.all(klass); end

  def self.build(klass, params=T.unsafe(nil)); end

  def self.find(klass, params=T.unsafe(nil)); end
end

module Rails::Generators::AppName
  RESERVED_NAMES = ::T.let(nil, ::T.untyped)
end

module Rails::Generators::AppName
end

class Rails::Generators::Base
  include ::Thor::Actions
  include ::Rails::Generators::Actions
end

class Rails::Generators::Base
  def self.add_shebang_option!(); end

  def self.base_name(); end

  def self.base_root(); end

  def self.default_aliases_for_option(name, options); end

  def self.default_for_option(config, name, options, default); end

  def self.default_generator_root(); end

  def self.default_source_root(); end

  def self.default_value_for_option(name, options); end

  def self.generator_name(); end

  def self.hide!(); end

  def self.hook_for(*names, &block); end

  def self.hooks(); end

  def self.inherited(base); end

  def self.prepare_for_invocation(name, value); end

  def self.remove_hook_for(*names); end

  def self.usage_path(); end
end

module Rails::Generators::Database
  def convert_database_option_for_jruby(); end

  def gem_for_database(database=T.unsafe(nil)); end

  def initialize(*_); end
  DATABASES = ::T.let(nil, ::T.untyped)
  JDBC_DATABASES = ::T.let(nil, ::T.untyped)
end

module Rails::Generators::Database
end

module Rails::Generators::Migration
  def create_migration(destination, data, config=T.unsafe(nil), &block); end

  def migration_class_name(); end

  def migration_file_name(); end

  def migration_number(); end

  def migration_template(source, destination, config=T.unsafe(nil)); end

  def set_migration_assigns!(destination); end
end

module Rails::Generators::Migration::ClassMethods
  def current_migration_number(dirname); end

  def migration_exists?(dirname, file_name); end

  def migration_lookup_at(dirname); end

  def next_migration_number(dirname); end
end

module Rails::Generators::Migration::ClassMethods
end

module Rails::Generators::Migration
  extend ::ActiveSupport::Concern
end

class Rails::Generators::NamedBase
  def file_name(); end

  def initialize(args, *options); end

  def js_template(source, destination); end

  def name(); end

  def name=(name); end
end

class Rails::Generators::NamedBase
  def self.check_class_collision(options=T.unsafe(nil)); end
end

module Rails::Generators::ResourceHelpers
  def initialize(*args); end
end

module Rails::Generators::ResourceHelpers
  def self.included(base); end
end

class Rails::Generators::TestCase
  include ::FileUtils::StreamUtils_
end

module Rails::Html
  XPATHS_TO_REMOVE = ::T.let(nil, ::T.untyped)
end

class Rails::Html::Sanitizer
  VERSION = ::T.let(nil, ::T.untyped)
end

Rails::Html::WhiteListSanitizer = Rails::Html::SafeListSanitizer

module Rails::Info
  def properties(); end

  def properties=(obj); end
end

module Rails::Info
  def self.properties(); end

  def self.properties=(obj); end

  def self.property(name, value=T.unsafe(nil)); end

  def self.to_html(); end
end

class Rails::InfoController
  def _layout_from_proc(); end

  def index(); end

  def properties(); end

  def routes(); end
end

class Rails::InfoController
end

class Rails::MailersController
  def index(); end

  def preview(); end
end

class Rails::MailersController
end

class Rails::Rack::Logger
  def call(env); end

  def initialize(app, taggers=T.unsafe(nil)); end
end

class Rails::Railtie
  ABSTRACT_RAILTIES = ::T.let(nil, ::T.untyped)
end

module Rails::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class Rails::WelcomeController
  def index(); end
end

class Rails::WelcomeController
end

module Rake
  EARLY = ::T.let(nil, ::T.untyped)
  EMPTY_TASK_ARGS = ::T.let(nil, ::T.untyped)
  LATE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rake::Application
  include ::Rake::TaskManager
  include ::Rake::TraceOutput
  def add_import(fn); end

  def add_loader(ext, loader); end

  def collect_command_line_tasks(args); end

  def default_task_name(); end

  def deprecate(old_usage, new_usage, call_site); end

  def display_cause_details(ex); end

  def display_error_message(ex); end

  def display_exception_backtrace(ex); end

  def display_exception_details(ex); end

  def display_exception_details_seen(); end

  def display_exception_message_details(ex); end

  def display_prerequisites(); end

  def display_tasks_and_comments(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def exit_because_of_exception(ex); end

  def find_rakefile_location(); end

  def handle_options(argv); end

  def has_cause?(ex); end

  def have_rakefile(); end

  def init(app_name=T.unsafe(nil), argv=T.unsafe(nil)); end

  def invoke_task(task_string); end

  def load_imports(); end

  def load_rakefile(); end

  def name(); end

  def options(); end

  def original_dir(); end

  def parse_task_string(string); end

  def print_rakefile_directory(location); end

  def rake_require(file_name, paths=T.unsafe(nil), loaded=T.unsafe(nil)); end

  def rakefile(); end

  def rakefile_location(backtrace=T.unsafe(nil)); end

  def raw_load_rakefile(); end

  def run(argv=T.unsafe(nil)); end

  def run_with_threads(); end

  def set_default_options(); end

  def standard_exception_handling(); end

  def standard_rake_options(); end

  def system_dir(); end

  def terminal_columns(); end

  def terminal_columns=(terminal_columns); end

  def terminal_width(); end

  def thread_pool(); end

  def top_level(); end

  def top_level_tasks(); end

  def trace(*strings); end

  def truncate(string, width); end

  def truncate_output?(); end

  def tty_output=(tty_output); end

  def tty_output?(); end

  def unix?(); end

  def windows?(); end
  DEFAULT_RAKEFILES = ::T.let(nil, ::T.untyped)
end

class Rake::Application
end

module Rake::Backtrace
  SUPPRESSED_PATHS = ::T.let(nil, ::T.untyped)
  SUPPRESSED_PATHS_RE = ::T.let(nil, ::T.untyped)
  SUPPRESS_PATTERN = ::T.let(nil, ::T.untyped)
  SYS_KEYS = ::T.let(nil, ::T.untyped)
  SYS_PATHS = ::T.let(nil, ::T.untyped)
end

module Rake::Backtrace
  def self.collapse(backtrace); end
end

class Rake::CommandLineOptionError
end

class Rake::CommandLineOptionError
end

class Rake::CpuCounter
  def count(); end

  def count_with_default(default=T.unsafe(nil)); end
end

class Rake::CpuCounter
  def self.count(); end
end

module Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Rake::DSL
end

class Rake::DefaultLoader
  def load(fn); end
end

class Rake::DefaultLoader
end

class Rake::EarlyTime
  include ::Comparable
  include ::Singleton
end

class Rake::EarlyTime
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Rake::FileCreationTask
end

class Rake::FileCreationTask
end

class Rake::FileList
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PATTERNS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PROCS = ::T.let(nil, ::T.untyped)
  DELEGATING_METHODS = ::T.let(nil, ::T.untyped)
  GLOB_PATTERN = ::T.let(nil, ::T.untyped)
  MUST_DEFINE = ::T.let(nil, ::T.untyped)
  MUST_NOT_DEFINE = ::T.let(nil, ::T.untyped)
  SPECIAL_RETURN = ::T.let(nil, ::T.untyped)
end

class Rake::FileTask
end

class Rake::FileTask
end

module Rake::FileUtilsExt
  include ::FileUtils::StreamUtils_
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  extend ::FileUtils::StreamUtils_
end

class Rake::InvocationChain
  def append(invocation); end

  def member?(invocation); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::InvocationChain::EmptyInvocationChain
  def append(invocation); end

  def member?(obj); end
end

class Rake::InvocationChain::EmptyInvocationChain
end

class Rake::InvocationChain
  def self.append(invocation, chain); end
end

module Rake::InvocationExceptionMixin
  def chain(); end

  def chain=(value); end
end

module Rake::InvocationExceptionMixin
end

class Rake::LateTime
  include ::Comparable
  include ::Singleton
end

class Rake::LateTime
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Rake::LinkedList
  include ::Enumerable
  def ==(other); end

  def conj(item); end

  def each(&blk); end

  def empty?(); end

  def head(); end

  def initialize(head, tail=T.unsafe(nil)); end

  def tail(); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::LinkedList::EmptyLinkedList
  def initialize(); end
end

class Rake::LinkedList::EmptyLinkedList
end

class Rake::LinkedList
  def self.cons(head, tail); end

  def self.empty(); end

  def self.make(*args); end
end

class Rake::MultiTask
end

class Rake::MultiTask
end

class Rake::NameSpace
  def [](name); end

  def initialize(task_manager, scope_list); end

  def scope(); end

  def tasks(); end
end

class Rake::NameSpace
end

module Rake::PrivateReader
end

module Rake::PrivateReader::ClassMethods
  def private_reader(*names); end
end

module Rake::PrivateReader::ClassMethods
end

module Rake::PrivateReader
  def self.included(base); end
end

class Rake::Promise
  def initialize(args, &block); end

  def recorder(); end

  def recorder=(recorder); end

  def value(); end

  def work(); end
  NOT_SET = ::T.let(nil, ::T.untyped)
end

class Rake::Promise
end

class Rake::PseudoStatus
  def >>(n); end

  def exited?(); end

  def exitstatus(); end

  def initialize(code=T.unsafe(nil)); end

  def stopped?(); end

  def to_i(); end
end

class Rake::PseudoStatus
end

class Rake::RuleRecursionOverflowError
  def add_target(target); end

  def initialize(*args); end
end

class Rake::RuleRecursionOverflowError
end

class Rake::Scope
  def path(); end

  def path_with_task_name(task_name); end

  def trim(n); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::Scope::EmptyScope
  def path(); end

  def path_with_task_name(task_name); end
end

class Rake::Scope::EmptyScope
end

class Rake::Scope
end

class Rake::Task
  def actions(); end

  def add_description(description); end

  def all_prerequisite_tasks(); end

  def already_invoked(); end

  def application(); end

  def application=(application); end

  def arg_description(); end

  def arg_names(); end

  def clear(); end

  def clear_actions(); end

  def clear_args(); end

  def clear_comments(); end

  def clear_prerequisites(); end

  def collect_prerequisites(seen); end

  def comment(); end

  def comment=(comment); end

  def enhance(deps=T.unsafe(nil), &block); end

  def execute(args=T.unsafe(nil)); end

  def full_comment(); end

  def initialize(task_name, app); end

  def investigation(); end

  def invoke(*args); end

  def invoke_prerequisites(task_args, invocation_chain); end

  def invoke_prerequisites_concurrently(task_args, invocation_chain); end

  def invoke_with_call_chain(task_args, invocation_chain); end

  def locations(); end

  def name(); end

  def name_with_args(); end

  def needed?(); end

  def order_only_prerequisites(); end

  def prereqs(); end

  def prerequisite_tasks(); end

  def prerequisites(); end

  def reenable(); end

  def scope(); end

  def set_arg_names(args); end

  def source(); end

  def sources(); end

  def sources=(sources); end

  def timestamp(); end

  def |(deps); end
end

class Rake::Task
  def self.[](task_name); end

  def self.clear(); end

  def self.create_rule(*args, &block); end

  def self.define_task(*args, &block); end

  def self.format_deps(deps); end

  def self.scope_name(scope, task_name); end

  def self.task_defined?(task_name); end

  def self.tasks(); end
end

class Rake::TaskArgumentError
end

class Rake::TaskArgumentError
end

class Rake::TaskArguments
  include ::Enumerable
  def [](index); end

  def each(&block); end

  def extras(); end

  def fetch(*args, &block); end

  def has_key?(key); end

  def initialize(names, values, parent=T.unsafe(nil)); end

  def key?(key); end

  def lookup(name); end

  def method_missing(sym, *args); end

  def names(); end

  def new_scope(names); end

  def to_a(); end

  def to_hash(); end

  def values_at(*keys); end

  def with_defaults(defaults); end
end

class Rake::TaskArguments
end

class Rake::TaskLib
  include ::Rake::Cloneable
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

class Rake::TaskLib
end

module Rake::TaskManager
  def [](task_name, scopes=T.unsafe(nil)); end

  def clear(); end

  def create_rule(*args, &block); end

  def current_scope(); end

  def define_task(task_class, *args, &block); end

  def enhance_with_matching_rule(task_name, level=T.unsafe(nil)); end

  def generate_did_you_mean_suggestions(task_name); end

  def generate_message_for_undefined_task(task_name); end

  def in_namespace(name); end

  def initialize(); end

  def intern(task_class, task_name); end

  def last_description(); end

  def last_description=(last_description); end

  def lookup(task_name, initial_scope=T.unsafe(nil)); end

  def resolve_args(args); end

  def synthesize_file_task(task_name); end

  def tasks(); end

  def tasks_in_scope(scope); end
end

module Rake::TaskManager
  def self.record_task_metadata(); end

  def self.record_task_metadata=(record_task_metadata); end
end

class Rake::ThreadHistoryDisplay
  include ::Rake::PrivateReader
  def initialize(stats); end

  def show(); end
end

class Rake::ThreadHistoryDisplay
  extend ::Rake::PrivateReader::ClassMethods
end

class Rake::ThreadPool
  def future(*args, &block); end

  def gather_history(); end

  def history(); end

  def initialize(thread_count); end

  def join(); end

  def statistics(); end
end

class Rake::ThreadPool
end

module Rake::TraceOutput
  def trace_on(out, *strings); end
end

module Rake::TraceOutput
end

module Rake::Version
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  NUMBERS = ::T.let(nil, ::T.untyped)
  OTHER = ::T.let(nil, ::T.untyped)
end

module Rake::Version
end

module Rake::Win32
end

class Rake::Win32::Win32HomeError
end

class Rake::Win32::Win32HomeError
end

module Rake::Win32
  def self.normalize(path); end

  def self.win32_system_dir(); end

  def self.windows?(); end
end

module Rake
  extend ::Rake::FileUtilsExt
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  def self.add_rakelib(*files); end

  def self.application(); end

  def self.application=(app); end

  def self.load_rakefile(path); end

  def self.original_dir(); end

  def self.suggested_thread_count(); end

  def self.with_application(block_application=T.unsafe(nil)); end
end

module Random::Formatter
  def alphanumeric(n=T.unsafe(nil)); end

  ALPHANUMERIC = ::T.let(nil, ::T.untyped)
end

class Random
  def self.bytes(_); end

  def self.urandom(_); end
end

class Range
  include ::ActiveSupport::RangeWithFormat
  include ::ActiveSupport::CompareWithRange
  include ::ActiveSupport::IncludeTimeWithZone
  include ::ActiveSupport::EachTimeWithZone
  def %(_); end

  def entries(); end

  def to_a(); end
end

class Rational
  def to_d(precision); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

class React::JSX::BabelTransformer
  DEFAULT_TRANSFORM_OPTIONS = ::T.let(nil, ::T.untyped)
  DEPRECATED_OPTIONS = ::T.let(nil, ::T.untyped)
end

React::JSX::DEFAULT_TRANSFORMER = React::JSX::BabelTransformer

class React::JSX::JSXTransformer
  DEFAULT_ASSET_PATH = ::T.let(nil, ::T.untyped)
end

module React::Rails
  VERSION = ::T.let(nil, ::T.untyped)
end

class React::Rails::AssetVariant
  GEM_ROOT = ::T.let(nil, ::T.untyped)
end

module React::Rails::TestHelper
  def assert_react_component(name); end
end

module React::Rails::TestHelper
  extend ::ActiveSupport::Concern
end

class React::ServerRendering::BundleRenderer
  CONSOLE_POLYFILL = ::T.let(nil, ::T.untyped)
  CONSOLE_REPLAY = ::T.let(nil, ::T.untyped)
  CONSOLE_RESET = ::T.let(nil, ::T.untyped)
  TIMEOUT_POLYFILL = ::T.let(nil, ::T.untyped)
end

class React::ServerRendering::ExecJSRenderer
  GLOBAL_WRAPPER = ::T.let(nil, ::T.untyped)
end

class React::ServerRendering::WebpackerManifestContainer
  CLIENT_REQUIRE = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
end

module Readline
  FILENAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  HISTORY = ::T.let(nil, ::T.untyped)
  USERNAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Readline
  def self.basic_quote_characters(); end

  def self.basic_quote_characters=(basic_quote_characters); end

  def self.basic_word_break_characters(); end

  def self.basic_word_break_characters=(basic_word_break_characters); end

  def self.completer_quote_characters(); end

  def self.completer_quote_characters=(completer_quote_characters); end

  def self.completer_word_break_characters(); end

  def self.completer_word_break_characters=(completer_word_break_characters); end

  def self.completion_append_character(); end

  def self.completion_append_character=(completion_append_character); end

  def self.completion_case_fold(); end

  def self.completion_case_fold=(completion_case_fold); end

  def self.completion_proc(); end

  def self.completion_proc=(completion_proc); end

  def self.completion_quote_character(); end

  def self.delete_text(*_); end

  def self.emacs_editing_mode(); end

  def self.emacs_editing_mode?(); end

  def self.filename_quote_characters(); end

  def self.filename_quote_characters=(filename_quote_characters); end

  def self.get_screen_size(); end

  def self.input=(input); end

  def self.insert_text(_); end

  def self.line_buffer(); end

  def self.output=(output); end

  def self.point(); end

  def self.point=(point); end

  def self.pre_input_hook(); end

  def self.pre_input_hook=(pre_input_hook); end

  def self.quoting_detection_proc(); end

  def self.quoting_detection_proc=(quoting_detection_proc); end

  def self.redisplay(); end

  def self.refresh_line(); end

  def self.set_screen_size(_, _1); end

  def self.special_prefixes(); end

  def self.special_prefixes=(special_prefixes); end

  def self.vi_editing_mode(); end

  def self.vi_editing_mode?(); end
end

class Regexp
  TOKEN_KEYS = ::T.let(nil, ::T.untyped)
end

Regexp::Expression::Alternation::OPERAND = Regexp::Expression::Alternative

Regexp::Expression::Anchor::BOL = Regexp::Expression::Anchor::BeginningOfLine

Regexp::Expression::Anchor::BOS = Regexp::Expression::Anchor::BeginningOfString

Regexp::Expression::Anchor::EOL = Regexp::Expression::Anchor::EndOfLine

Regexp::Expression::Anchor::EOS = Regexp::Expression::Anchor::EndOfString

Regexp::Expression::Anchor::EOSobEOL = Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine

Regexp::Expression::CharacterSet::Intersection::OPERAND = Regexp::Expression::CharacterSet::IntersectedSequence

Regexp::Expression::MatchLength = Regexp::MatchLength

class Regexp::Expression::Quantifier
  MODES = ::T.let(nil, ::T.untyped)
end

class Regexp::Lexer
  CLOSING_TOKENS = ::T.let(nil, ::T.untyped)
  OPENING_TOKENS = ::T.let(nil, ::T.untyped)
end

class Regexp::Parser
  ENC_FLAGS = ::T.let(nil, ::T.untyped)
  MOD_FLAGS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Regexp::Scanner
  PROP_MAPS_DIR = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax
  VERSION_CONST_REGEXP = ::T.let(nil, ::T.untyped)
  VERSION_FORMAT = ::T.let(nil, ::T.untyped)
  VERSION_REGEXP = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token
  All = ::T.let(nil, ::T.untyped)
  Map = ::T.let(nil, ::T.untyped)
  Types = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Anchor
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  MatchStart = ::T.let(nil, ::T.untyped)
  String = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Assertion
  All = ::T.let(nil, ::T.untyped)
  Lookahead = ::T.let(nil, ::T.untyped)
  Lookbehind = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Backreference
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  RecursionLevel = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterSet
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterType
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Clustered = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Conditional
  All = ::T.let(nil, ::T.untyped)
  Condition = ::T.let(nil, ::T.untyped)
  Delimiters = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Escape
  ASCII = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Control = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Meta = ::T.let(nil, ::T.untyped)
  Octal = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  Unicode = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::FreeSpace
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Group
  All = ::T.let(nil, ::T.untyped)
  Atomic = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Comment = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Named = ::T.let(nil, ::T.untyped)
  Passive = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  V1_8_6 = ::T.let(nil, ::T.untyped)
  V2_4_1 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Keep
  All = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Literal
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Meta
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::PosixClass
  All = ::T.let(nil, ::T.untyped)
  Extensions = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  Standard = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Quantifier
  All = ::T.let(nil, ::T.untyped)
  Greedy = ::T.let(nil, ::T.untyped)
  Interval = ::T.let(nil, ::T.untyped)
  IntervalAll = ::T.let(nil, ::T.untyped)
  IntervalPossessive = ::T.let(nil, ::T.untyped)
  IntervalReluctant = ::T.let(nil, ::T.untyped)
  Possessive = ::T.let(nil, ::T.untyped)
  Reluctant = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::SubexpressionCall
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty
  Age = ::T.let(nil, ::T.untyped)
  Age_V1_9_3 = ::T.let(nil, ::T.untyped)
  Age_V2_0_0 = ::T.let(nil, ::T.untyped)
  Age_V2_2_0 = ::T.let(nil, ::T.untyped)
  Age_V2_3_0 = ::T.let(nil, ::T.untyped)
  Age_V2_4_0 = ::T.let(nil, ::T.untyped)
  Age_V2_5_0 = ::T.let(nil, ::T.untyped)
  Age_V2_6_0 = ::T.let(nil, ::T.untyped)
  Age_V2_6_2 = ::T.let(nil, ::T.untyped)
  Age_V2_6_3 = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  CharType_V1_9_0 = ::T.let(nil, ::T.untyped)
  CharType_V2_5_0 = ::T.let(nil, ::T.untyped)
  Derived = ::T.let(nil, ::T.untyped)
  Derived_V1_9_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_0_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_4_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_5_0 = ::T.let(nil, ::T.untyped)
  Emoji = ::T.let(nil, ::T.untyped)
  Emoji_V2_5_0 = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  POSIX = ::T.let(nil, ::T.untyped)
  Script = ::T.let(nil, ::T.untyped)
  Script_V1_9_0 = ::T.let(nil, ::T.untyped)
  Script_V1_9_3 = ::T.let(nil, ::T.untyped)
  Script_V2_0_0 = ::T.let(nil, ::T.untyped)
  Script_V2_2_0 = ::T.let(nil, ::T.untyped)
  Script_V2_3_0 = ::T.let(nil, ::T.untyped)
  Script_V2_4_0 = ::T.let(nil, ::T.untyped)
  Script_V2_5_0 = ::T.let(nil, ::T.untyped)
  Script_V2_6_0 = ::T.let(nil, ::T.untyped)
  Script_V2_6_2 = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  UnicodeBlock = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V1_9_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_0_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_2_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_3_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_4_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_5_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_6_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_6_2 = ::T.let(nil, ::T.untyped)
  V1_9_0 = ::T.let(nil, ::T.untyped)
  V1_9_3 = ::T.let(nil, ::T.untyped)
  V2_0_0 = ::T.let(nil, ::T.untyped)
  V2_2_0 = ::T.let(nil, ::T.untyped)
  V2_3_0 = ::T.let(nil, ::T.untyped)
  V2_4_0 = ::T.let(nil, ::T.untyped)
  V2_5_0 = ::T.let(nil, ::T.untyped)
  V2_6_0 = ::T.let(nil, ::T.untyped)
  V2_6_2 = ::T.let(nil, ::T.untyped)
  V2_6_3 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty::Category
  All = ::T.let(nil, ::T.untyped)
  Codepoint = ::T.let(nil, ::T.untyped)
  Letter = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  Punctuation = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Symbol = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS
  def extract_resources(msg, name, typeclass); end

  def fetch_resource(name, typeclass); end

  def lazy_initialize(); end

  def make_tcp_requester(host, port); end

  def make_udp_requester(); end
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config
  def generate_candidates(name); end

  def generate_timeouts(); end

  def initialize(config_info=T.unsafe(nil)); end

  def lazy_initialize(); end

  def nameserver_port(); end

  def resolv(name); end

  def single?(); end

  def timeouts=(values); end
  InitialTimeout = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config::NXDomain
end

class Resolv::DNS::Config::NXDomain
end

class Resolv::DNS::Config::OtherResolvError
end

class Resolv::DNS::Config::OtherResolvError
end

class Resolv::DNS::Config
  def self.default_config_hash(filename=T.unsafe(nil)); end

  def self.parse_resolv_conf(filename); end
end

module Resolv::DNS::Label
end

class Resolv::DNS::Label::Str
  def ==(other); end

  def downcase(); end

  def eql?(other); end

  def initialize(string); end

  def string(); end
end

class Resolv::DNS::Label::Str
end

module Resolv::DNS::Label
  def self.split(arg); end
end

class Resolv::DNS::Message
  def ==(other); end

  def aa(); end

  def aa=(aa); end

  def add_additional(name, ttl, data); end

  def add_answer(name, ttl, data); end

  def add_authority(name, ttl, data); end

  def add_question(name, typeclass); end

  def additional(); end

  def answer(); end

  def authority(); end

  def each_additional(); end

  def each_answer(); end

  def each_authority(); end

  def each_question(); end

  def each_resource(); end

  def encode(); end

  def id(); end

  def id=(id); end

  def initialize(id=T.unsafe(nil)); end

  def opcode(); end

  def opcode=(opcode); end

  def qr(); end

  def qr=(qr); end

  def question(); end

  def ra(); end

  def ra=(ra); end

  def rcode(); end

  def rcode=(rcode); end

  def rd(); end

  def rd=(rd); end

  def tc(); end

  def tc=(tc); end
end

class Resolv::DNS::Message::MessageDecoder
  def get_bytes(len=T.unsafe(nil)); end

  def get_label(); end

  def get_labels(); end

  def get_length16(); end

  def get_name(); end

  def get_question(); end

  def get_rr(); end

  def get_string(); end

  def get_string_list(); end

  def get_unpack(template); end

  def initialize(data); end
end

class Resolv::DNS::Message::MessageDecoder
end

class Resolv::DNS::Message::MessageEncoder
  def put_bytes(d); end

  def put_label(d); end

  def put_labels(d); end

  def put_length16(); end

  def put_name(d); end

  def put_pack(template, *d); end

  def put_string(d); end

  def put_string_list(ds); end
end

class Resolv::DNS::Message::MessageEncoder
end

class Resolv::DNS::Message
  def self.decode(m); end
end

class Resolv::DNS::Name
  def ==(other); end

  def [](i); end

  def eql?(other); end

  def length(); end

  def to_a(); end
end

module Resolv::DNS::OpCode
  IQuery = ::T.let(nil, ::T.untyped)
  Notify = ::T.let(nil, ::T.untyped)
  Query = ::T.let(nil, ::T.untyped)
  Status = ::T.let(nil, ::T.untyped)
  Update = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::OpCode
end

class Resolv::DNS::Query
  def encode_rdata(msg); end
end

class Resolv::DNS::Query
  def self.decode_rdata(msg); end
end

module Resolv::DNS::RCode
  BADALG = ::T.let(nil, ::T.untyped)
  BADKEY = ::T.let(nil, ::T.untyped)
  BADMODE = ::T.let(nil, ::T.untyped)
  BADNAME = ::T.let(nil, ::T.untyped)
  BADSIG = ::T.let(nil, ::T.untyped)
  BADTIME = ::T.let(nil, ::T.untyped)
  BADVERS = ::T.let(nil, ::T.untyped)
  FormErr = ::T.let(nil, ::T.untyped)
  NXDomain = ::T.let(nil, ::T.untyped)
  NXRRSet = ::T.let(nil, ::T.untyped)
  NoError = ::T.let(nil, ::T.untyped)
  NotAuth = ::T.let(nil, ::T.untyped)
  NotImp = ::T.let(nil, ::T.untyped)
  NotZone = ::T.let(nil, ::T.untyped)
  Refused = ::T.let(nil, ::T.untyped)
  ServFail = ::T.let(nil, ::T.untyped)
  YXDomain = ::T.let(nil, ::T.untyped)
  YXRRSet = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::RCode
end

class Resolv::DNS::Requester
  def close(); end

  def request(sender, tout); end

  def sender_for(addr, msg); end
end

class Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def lazy_initialize(); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::ConnectedUDP::Sender
  def data(); end

  def send(); end
end

class Resolv::DNS::Requester::ConnectedUDP::Sender
end

class Resolv::DNS::Requester::ConnectedUDP
end

class Resolv::DNS::Requester::MDNSOneShot
end

class Resolv::DNS::Requester::MDNSOneShot
end

class Resolv::DNS::Requester::RequestError
end

class Resolv::DNS::Requester::RequestError
end

class Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Resolv::DNS::Requester::Sender
end

class Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::TCP::Sender
  def data(); end

  def send(); end
end

class Resolv::DNS::Requester::TCP::Sender
end

class Resolv::DNS::Requester::TCP
end

class Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def lazy_initialize(); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host, port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
  def data(); end

  def initialize(msg, data, sock, host, port); end

  def send(); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
end

class Resolv::DNS::Requester::UnconnectedUDP
end

class Resolv::DNS::Requester
end

class Resolv::DNS::Resource
  def ==(other); end

  def eql?(other); end
  ClassHash = ::T.let(nil, ::T.untyped)
  ClassInsensitiveTypes = ::T.let(nil, ::T.untyped)
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::ANY
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::CNAME
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::Generic
  def self.create(type_value, class_value); end
end

class Resolv::DNS::Resource::HINFO
  TypeValue = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::Resource::IN
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::A
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::AAAA
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::ANY
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::ANY
end

class Resolv::DNS::Resource::IN::CNAME
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::CNAME
end

class Resolv::DNS::Resource::IN::HINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::HINFO
end

class Resolv::DNS::Resource::IN::LOC
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::LOC
end

class Resolv::DNS::Resource::IN::MINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::MINFO
end

class Resolv::DNS::Resource::IN::MX
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::MX
end

class Resolv::DNS::Resource::IN::NS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::NS
end

class Resolv::DNS::Resource::IN::PTR
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::PTR
end

class Resolv::DNS::Resource::IN::SOA
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::SOA
end

class Resolv::DNS::Resource::IN::SRV
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::TXT
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::TXT
end

class Resolv::DNS::Resource::IN::WKS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::LOC
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::MINFO
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::MX
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::NS
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::PTR
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::SOA
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::TXT
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource
  def self.get_class(type_value, class_value); end
end

class Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.random(arg); end
end

class Resolv::Hosts
  def lazy_initialize(); end
end

class Resolv::IPv4
  def ==(other); end

  def eql?(other); end
end

class Resolv::IPv6
  def ==(other); end

  def eql?(other); end
end

class Resolv::LOC::Alt
  def ==(other); end

  def eql?(other); end
end

class Resolv::LOC::Coord
  def ==(other); end

  def eql?(other); end
end

class Resolv::LOC::Size
  def ==(other); end

  def eql?(other); end
end

module ReverseMarkdown
  VERSION = ::T.let(nil, ::T.untyped)
end

class ReverseMarkdown::Cleaner
  def clean_punctuation_characters(string); end

  def clean_tag_borders(string); end

  def force_encoding(string); end

  def remove_inner_whitespaces(string); end

  def remove_leading_newlines(string); end

  def remove_newlines(string); end

  def tidy(string); end
end

class ReverseMarkdown::Cleaner
end

class ReverseMarkdown::Config
  def force_encoding(); end

  def force_encoding=(force_encoding); end

  def github_flavored(); end

  def github_flavored=(github_flavored); end

  def tag_border(); end

  def tag_border=(tag_border); end

  def unknown_tags(); end

  def unknown_tags=(unknown_tags); end

  def with(options=T.unsafe(nil)); end
end

class ReverseMarkdown::Config
end

module ReverseMarkdown::Converters
end

class ReverseMarkdown::Converters::A
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::A
end

class ReverseMarkdown::Converters::Base
  def escape_keychars(string); end

  def extract_title(node); end

  def treat(node, state); end

  def treat_children(node, state); end
end

class ReverseMarkdown::Converters::Base
end

class ReverseMarkdown::Converters::Blockquote
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Blockquote
end

class ReverseMarkdown::Converters::Br
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Br
end

class ReverseMarkdown::Converters::Bypass
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Bypass
end

class ReverseMarkdown::Converters::Code
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Code
end

class ReverseMarkdown::Converters::Del
  def convert(node, state=T.unsafe(nil)); end

  def disabled?(); end

  def enabled?(); end
end

class ReverseMarkdown::Converters::Del
end

class ReverseMarkdown::Converters::Div
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Div
end

class ReverseMarkdown::Converters::Drop
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Drop
end

class ReverseMarkdown::Converters::Em
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Em
end

class ReverseMarkdown::Converters::H
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::H
end

class ReverseMarkdown::Converters::Hr
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Hr
end

class ReverseMarkdown::Converters::Ignore
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Ignore
end

class ReverseMarkdown::Converters::Img
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Img
end

class ReverseMarkdown::Converters::Li
  def convert(node, state=T.unsafe(nil)); end

  def indentation_from(state); end

  def prefix_for(node); end
end

class ReverseMarkdown::Converters::Li
end

class ReverseMarkdown::Converters::Ol
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Ol
end

class ReverseMarkdown::Converters::P
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::P
end

class ReverseMarkdown::Converters::PassThrough
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::PassThrough
end

class ReverseMarkdown::Converters::Pre
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Pre
end

class ReverseMarkdown::Converters::Strong
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Strong
end

class ReverseMarkdown::Converters::Table
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Table
end

class ReverseMarkdown::Converters::Td
  def convert(node, state=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Td
end

class ReverseMarkdown::Converters::Text
  def convert(node, options=T.unsafe(nil)); end
end

class ReverseMarkdown::Converters::Text
end

class ReverseMarkdown::Converters::Tr
  def convert(node, state=T.unsafe(nil)); end

  def table_header_row?(node); end

  def underline_for(node); end
end

class ReverseMarkdown::Converters::Tr
end

module ReverseMarkdown::Converters
  def self.default_converter(tag_name); end

  def self.lookup(tag_name); end

  def self.register(tag_name, converter); end

  def self.unregister(tag_name); end
end

class ReverseMarkdown::Error
end

class ReverseMarkdown::Error
end

class ReverseMarkdown::InvalidConfigurationError
end

class ReverseMarkdown::InvalidConfigurationError
end

class ReverseMarkdown::UnknownTagError
end

class ReverseMarkdown::UnknownTagError
end

module ReverseMarkdown
  def self.cleaner(); end

  def self.config(); end

  def self.convert(input, options=T.unsafe(nil)); end
end

class Ripper
  def column(); end

  def encoding(); end

  def end_seen?(); end

  def error?(); end

  def filename(); end

  def initialize(*_); end

  def lineno(); end

  def parse(); end

  def state(); end

  def yydebug(); end

  def yydebug=(yydebug); end
  EVENTS = ::T.let(nil, ::T.untyped)
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_NONE = ::T.let(nil, ::T.untyped)
  EXPR_VALUE = ::T.let(nil, ::T.untyped)
  PARSER_EVENTS = ::T.let(nil, ::T.untyped)
  PARSER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  SCANNER_EVENTS = ::T.let(nil, ::T.untyped)
  SCANNER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Ripper::Filter
  def column(); end

  def filename(); end

  def initialize(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end

  def lineno(); end

  def parse(init=T.unsafe(nil)); end

  def state(); end
end

class Ripper::Filter
end

class Ripper::Lexer
  def lex(); end

  def tokenize(); end
end

class Ripper::Lexer::Elem
  def event(); end

  def event=(_); end

  def initialize(pos, event, tok, state); end

  def pos(); end

  def pos=(_); end

  def state(); end

  def state=(_); end

  def tok(); end

  def tok=(_); end
end

class Ripper::Lexer::Elem
  def self.[](*_); end

  def self.members(); end
end

class Ripper::Lexer::State
  def &(i); end

  def ==(i); end

  def allbits?(i); end

  def anybits?(i); end

  def initialize(i); end

  def nobits?(i); end

  def to_i(); end

  def to_int(); end

  def to_int=(_); end

  def to_s=(_); end

  def |(i); end
end

class Ripper::Lexer::State
  def self.[](*_); end

  def self.members(); end
end

class Ripper::Lexer
end

class Ripper::SexpBuilder
  def on_BEGIN(*args); end

  def on_CHAR(tok); end

  def on_END(*args); end

  def on___end__(tok); end

  def on_alias(*args); end

  def on_alias_error(*args); end

  def on_aref(*args); end

  def on_aref_field(*args); end

  def on_arg_ambiguous(*args); end

  def on_arg_paren(*args); end

  def on_args_add(*args); end

  def on_args_add_block(*args); end

  def on_args_add_star(*args); end

  def on_args_new(*args); end

  def on_array(*args); end

  def on_assign(*args); end

  def on_assign_error(*args); end

  def on_assoc_new(*args); end

  def on_assoc_splat(*args); end

  def on_assoclist_from_args(*args); end

  def on_backref(tok); end

  def on_backtick(tok); end

  def on_bare_assoc_hash(*args); end

  def on_begin(*args); end

  def on_binary(*args); end

  def on_block_var(*args); end

  def on_blockarg(*args); end

  def on_bodystmt(*args); end

  def on_brace_block(*args); end

  def on_break(*args); end

  def on_call(*args); end

  def on_case(*args); end

  def on_class(*args); end

  def on_class_name_error(*args); end

  def on_comma(tok); end

  def on_command(*args); end

  def on_command_call(*args); end

  def on_comment(tok); end

  def on_const(tok); end

  def on_const_path_field(*args); end

  def on_const_path_ref(*args); end

  def on_const_ref(*args); end

  def on_cvar(tok); end

  def on_def(*args); end

  def on_defined(*args); end

  def on_defs(*args); end

  def on_do_block(*args); end

  def on_dot2(*args); end

  def on_dot3(*args); end

  def on_dyna_symbol(*args); end

  def on_else(*args); end

  def on_elsif(*args); end

  def on_embdoc(tok); end

  def on_embdoc_beg(tok); end

  def on_embdoc_end(tok); end

  def on_embexpr_beg(tok); end

  def on_embexpr_end(tok); end

  def on_embvar(tok); end

  def on_ensure(*args); end

  def on_excessed_comma(*args); end

  def on_fcall(*args); end

  def on_field(*args); end

  def on_float(tok); end

  def on_for(*args); end

  def on_gvar(tok); end

  def on_hash(*args); end

  def on_heredoc_beg(tok); end

  def on_heredoc_end(tok); end

  def on_ident(tok); end

  def on_if(*args); end

  def on_if_mod(*args); end

  def on_ifop(*args); end

  def on_ignored_nl(tok); end

  def on_ignored_sp(tok); end

  def on_imaginary(tok); end

  def on_int(tok); end

  def on_ivar(tok); end

  def on_kw(tok); end

  def on_kwrest_param(*args); end

  def on_label(tok); end

  def on_label_end(tok); end

  def on_lambda(*args); end

  def on_lbrace(tok); end

  def on_lbracket(tok); end

  def on_lparen(tok); end

  def on_magic_comment(*args); end

  def on_massign(*args); end

  def on_method_add_arg(*args); end

  def on_method_add_block(*args); end

  def on_mlhs_add(*args); end

  def on_mlhs_add_post(*args); end

  def on_mlhs_add_star(*args); end

  def on_mlhs_new(*args); end

  def on_mlhs_paren(*args); end

  def on_module(*args); end

  def on_mrhs_add(*args); end

  def on_mrhs_add_star(*args); end

  def on_mrhs_new(*args); end

  def on_mrhs_new_from_args(*args); end

  def on_next(*args); end

  def on_nl(tok); end

  def on_op(tok); end

  def on_opassign(*args); end

  def on_operator_ambiguous(*args); end

  def on_param_error(*args); end

  def on_params(*args); end

  def on_paren(*args); end

  def on_parse_error(*args); end

  def on_period(tok); end

  def on_program(*args); end

  def on_qsymbols_add(*args); end

  def on_qsymbols_beg(tok); end

  def on_qsymbols_new(*args); end

  def on_qwords_add(*args); end

  def on_qwords_beg(tok); end

  def on_qwords_new(*args); end

  def on_rational(tok); end

  def on_rbrace(tok); end

  def on_rbracket(tok); end

  def on_redo(*args); end

  def on_regexp_add(*args); end

  def on_regexp_beg(tok); end

  def on_regexp_end(tok); end

  def on_regexp_literal(*args); end

  def on_regexp_new(*args); end

  def on_rescue(*args); end

  def on_rescue_mod(*args); end

  def on_rest_param(*args); end

  def on_retry(*args); end

  def on_return(*args); end

  def on_return0(*args); end

  def on_rparen(tok); end

  def on_sclass(*args); end

  def on_semicolon(tok); end

  def on_sp(tok); end

  def on_stmts_add(*args); end

  def on_stmts_new(*args); end

  def on_string_add(*args); end

  def on_string_concat(*args); end

  def on_string_content(*args); end

  def on_string_dvar(*args); end

  def on_string_embexpr(*args); end

  def on_string_literal(*args); end

  def on_super(*args); end

  def on_symbeg(tok); end

  def on_symbol(*args); end

  def on_symbol_literal(*args); end

  def on_symbols_add(*args); end

  def on_symbols_beg(tok); end

  def on_symbols_new(*args); end

  def on_tlambda(tok); end

  def on_tlambeg(tok); end

  def on_top_const_field(*args); end

  def on_top_const_ref(*args); end

  def on_tstring_beg(tok); end

  def on_tstring_content(tok); end

  def on_tstring_end(tok); end

  def on_unary(*args); end

  def on_undef(*args); end

  def on_unless(*args); end

  def on_unless_mod(*args); end

  def on_until(*args); end

  def on_until_mod(*args); end

  def on_var_alias(*args); end

  def on_var_field(*args); end

  def on_var_ref(*args); end

  def on_vcall(*args); end

  def on_void_stmt(*args); end

  def on_when(*args); end

  def on_while(*args); end

  def on_while_mod(*args); end

  def on_word_add(*args); end

  def on_word_new(*args); end

  def on_words_add(*args); end

  def on_words_beg(tok); end

  def on_words_new(*args); end

  def on_words_sep(tok); end

  def on_xstring_add(*args); end

  def on_xstring_literal(*args); end

  def on_xstring_new(*args); end

  def on_yield(*args); end

  def on_yield0(*args); end

  def on_zsuper(*args); end
end

class Ripper::SexpBuilder
end

class Ripper::SexpBuilderPP
end

class Ripper::SexpBuilderPP
end

class Ripper::TokenPattern
  def initialize(pattern); end

  def match(str); end

  def match_list(tokens); end
  MAP = ::T.let(nil, ::T.untyped)
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::MatchData
  def initialize(tokens, match); end

  def string(n=T.unsafe(nil)); end
end

class Ripper::TokenPattern::MatchData
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern
  def self.compile(*_); end
end

class Ripper
  def self.dedent_string(_, _1); end

  def self.lex(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end

  def self.lex_state_name(_); end

  def self.parse(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end

  def self.token_match(src, pattern); end
end

module RuboCop
end

module RuboCop::AST
end

class RuboCop::AST::AliasNode
  def new_identifier(); end

  def old_identifier(); end
end

class RuboCop::AST::AliasNode
end

class RuboCop::AST::AndNode
  include ::RuboCop::AST::BinaryOperatorNode
  include ::RuboCop::AST::PredicateOperatorNode
  def alternate_operator(); end

  def inverse_operator(); end
end

class RuboCop::AST::AndNode
end

class RuboCop::AST::ArgsNode
  include ::RuboCop::AST::CollectionNode
  def empty_and_without_delimiters?(); end
end

class RuboCop::AST::ArgsNode
end

class RuboCop::AST::ArrayNode
  def bracketed?(); end

  def each_value(&block); end

  def percent_literal?(type=T.unsafe(nil)); end

  def square_brackets?(); end

  def values(); end
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::ArrayNode
end

module RuboCop::AST::BasicLiteralNode
  def value(); end
end

module RuboCop::AST::BasicLiteralNode
end

module RuboCop::AST::BinaryOperatorNode
  def conditions(); end

  def lhs(); end

  def rhs(); end
end

module RuboCop::AST::BinaryOperatorNode
end

class RuboCop::AST::BlockNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def arguments(); end

  def arguments?(); end

  def body(); end

  def braces?(); end

  def closing_delimiter(); end

  def delimiters(); end

  def keywords?(); end

  def lambda?(); end

  def method_name(); end

  def opening_delimiter(); end

  def send_node(); end

  def void_context?(); end
  VOID_CONTEXT_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::BlockNode
end

class RuboCop::AST::BreakNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  include ::RuboCop::AST::ParameterizedNode
end

class RuboCop::AST::BreakNode
end

class RuboCop::AST::Builder
  NODE_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Builder
end

class RuboCop::AST::CaseMatchNode
  include ::RuboCop::AST::ConditionalNode
  def each_in_pattern(); end

  def else?(); end

  def else_branch(); end

  def in_pattern_branches(); end

  def keyword(); end
end

class RuboCop::AST::CaseMatchNode
end

class RuboCop::AST::CaseNode
  include ::RuboCop::AST::ConditionalNode
  def each_when(); end

  def else?(); end

  def else_branch(); end

  def keyword(); end

  def when_branches(); end
end

class RuboCop::AST::CaseNode
end

class RuboCop::AST::ClassNode
  def body(); end

  def identifier(); end

  def parent_class(); end
end

class RuboCop::AST::ClassNode
end

module RuboCop::AST::CollectionNode
  def &(*args, &block); end

  def *(*args, &block); end

  def +(*args, &block); end

  def -(*args, &block); end

  def <<(*args, &block); end

  def [](*args, &block); end

  def []=(*args, &block); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def append(*args, &block); end

  def assoc(*args, &block); end

  def at(*args, &block); end

  def bsearch(*args, &block); end

  def bsearch_index(*args, &block); end

  def chain(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def collect(*args, &block); end

  def collect!(*args, &block); end

  def collect_concat(*args, &block); end

  def combination(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def concat(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def delete(*args, &block); end

  def delete_at(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def difference(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_index(*args, &block); end

  def each_slice(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def exclude?(*args, &block); end

  def excluding(*args, &block); end

  def extract!(*args, &block); end

  def extract_options!(*args, &block); end

  def fetch(*args, &block); end

  def fifth(*args, &block); end

  def fill(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def flatten!(*args, &block); end

  def forty_two(*args, &block); end

  def fourth(*args, &block); end

  def from(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def include?(*args, &block); end

  def including(*args, &block); end

  def index(*args, &block); end

  def index_by(*args, &block); end

  def index_with(*args, &block); end

  def inject(*args, &block); end

  def insert(*args, &block); end

  def join(*args, &block); end

  def keep_if(*args, &block); end

  def last(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def many?(*args, &block); end

  def map(*args, &block); end

  def map!(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def pack(*args, &block); end

  def partition(*args, &block); end

  def permutation(*args, &block); end

  def pluck(*args, &block); end

  def pop(*args, &block); end

  def prepend(*args, &block); end

  def product(*args, &block); end

  def push(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def repeated_combination(*args, &block); end

  def repeated_permutation(*args, &block); end

  def replace(*args, &block); end

  def reverse(*args, &block); end

  def reverse!(*args, &block); end

  def reverse_each(*args, &block); end

  def rindex(*args, &block); end

  def rotate(*args, &block); end

  def rotate!(*args, &block); end

  def sample(*args, &block); end

  def second(*args, &block); end

  def second_to_last(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shelljoin(*args, &block); end

  def shift(*args, &block); end

  def shuffle(*args, &block); end

  def shuffle!(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort!(*args, &block); end

  def sort_by(*args, &block); end

  def sort_by!(*args, &block); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def third(*args, &block); end

  def third_to_last(*args, &block); end

  def to(*args, &block); end

  def to_ary(*args, &block); end

  def to_default_s(*args, &block); end

  def to_formatted_s(*args, &block); end

  def to_h(*args, &block); end

  def to_msgpack(*args, &block); end

  def to_sentence(*args, &block); end

  def to_set(*args, &block); end

  def to_xml(*args, &block); end

  def transpose(*args, &block); end

  def union(*args, &block); end

  def uniq(*args, &block); end

  def uniq!(*args, &block); end

  def unshift(*args, &block); end

  def values_at(*args, &block); end

  def without(*args, &block); end

  def zip(*args, &block); end

  def |(*args, &block); end
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::CollectionNode
  extend ::Forwardable
end

module RuboCop::AST::ConditionalNode
  def body(); end

  def condition(); end

  def multiline_condition?(); end

  def single_line_condition?(); end
end

module RuboCop::AST::ConditionalNode
end

class RuboCop::AST::DefNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def argument_forwarding?(); end

  def arguments(); end

  def body(); end

  def method_name(); end

  def receiver(); end

  def void_context?(); end
end

class RuboCop::AST::DefNode
end

class RuboCop::AST::DefinedNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
end

class RuboCop::AST::DefinedNode
end

class RuboCop::AST::EnsureNode
  def body(); end
end

class RuboCop::AST::EnsureNode
end

class RuboCop::AST::FloatNode
  include ::RuboCop::AST::NumericNode
end

class RuboCop::AST::FloatNode
end

class RuboCop::AST::ForNode
  def body(); end

  def collection(); end

  def do?(); end

  def keyword(); end

  def variable(); end

  def void_context?(); end
end

class RuboCop::AST::ForNode
end

class RuboCop::AST::ForwardArgsNode
  include ::RuboCop::AST::CollectionNode
end

class RuboCop::AST::ForwardArgsNode
end

module RuboCop::AST::HashElementNode
  def delimiter_delta(other); end

  def key(); end

  def key_delta(other, alignment=T.unsafe(nil)); end

  def same_line?(other); end

  def value(); end

  def value_delta(other); end
end

module RuboCop::AST::HashElementNode
end

class RuboCop::AST::HashNode
  def braces?(); end

  def each_key(); end

  def each_pair(); end

  def each_value(); end

  def empty?(); end

  def keys(); end

  def mixed_delimiters?(); end

  def pairs(); end

  def pairs_on_same_line?(); end

  def values(); end
end

class RuboCop::AST::HashNode
end

class RuboCop::AST::IfNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def branches(); end

  def each_branch(); end

  def else?(); end

  def else_branch(); end

  def elsif?(); end

  def elsif_conditional?(); end

  def if?(); end

  def if_branch(); end

  def inverse_keyword(); end

  def keyword(); end

  def nested_conditional?(); end

  def ternary?(); end

  def unless?(); end
end

class RuboCop::AST::IfNode
end

class RuboCop::AST::IntNode
  include ::RuboCop::AST::NumericNode
end

class RuboCop::AST::IntNode
end

class RuboCop::AST::KeywordSplatNode
  include ::RuboCop::AST::HashElementNode
  def colon?(); end

  def hash_rocket?(); end

  def operator(); end
  DOUBLE_SPLAT = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::KeywordSplatNode
end

module RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def access_modifier?(); end

  def adjacent_def_modifier?(node=T.unsafe(nil)); end

  def arguments(); end

  def arithmetic_operation?(); end

  def assignment?(); end

  def bare_access_modifier?(); end

  def bare_access_modifier_declaration?(node=T.unsafe(nil)); end

  def binary_operation?(); end

  def block_literal?(); end

  def block_node(); end

  def command?(name); end

  def const_receiver?(); end

  def def_modifier?(); end

  def dot?(); end

  def double_colon?(); end

  def implicit_call?(); end

  def lambda?(); end

  def lambda_literal?(); end

  def macro?(); end

  def macro_scope?(node=T.unsafe(nil)); end

  def method_name(); end

  def non_bare_access_modifier?(); end

  def non_bare_access_modifier_declaration?(node=T.unsafe(nil)); end

  def receiver(); end

  def safe_navigation?(); end

  def self_receiver?(); end

  def setter_method?(); end

  def special_modifier?(); end

  def unary_operation?(); end
  ARITHMETIC_OPERATORS = ::T.let(nil, ::T.untyped)
  SPECIAL_MODIFIERS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::MethodDispatchNode
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::AST::MethodIdentifierPredicates
  def assignment_method?(); end

  def bang_method?(); end

  def camel_case_method?(); end

  def comparison_method?(); end

  def const_receiver?(); end

  def enumerator_method?(); end

  def method?(name); end

  def negation_method?(); end

  def operator_method?(); end

  def predicate_method?(); end

  def prefix_bang?(); end

  def prefix_not?(); end

  def self_receiver?(); end
  ENUMERATOR_METHODS = ::T.let(nil, ::T.untyped)
  OPERATOR_METHODS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::MethodIdentifierPredicates
end

module RuboCop::AST::ModifierNode
  def modifier_form?(); end
end

module RuboCop::AST::ModifierNode
end

class RuboCop::AST::ModuleNode
  def body(); end

  def identifier(); end
end

class RuboCop::AST::ModuleNode
end

class RuboCop::AST::Node
  include ::RuboCop::AST::Sexp
  def __ENCODING___type?(); end

  def __FILE___type?(); end

  def __LINE___type?(); end

  def alias_type?(); end

  def ancestors(); end

  def and_asgn_type?(); end

  def and_type?(); end

  def arg_expr_type?(); end

  def arg_type?(); end

  def args_type?(); end

  def argument?(); end

  def array_pattern_type?(); end

  def array_pattern_with_tail_type?(); end

  def array_type?(); end

  def assignment?(); end

  def assignment_or_similar?(node=T.unsafe(nil)); end

  def back_ref_type?(); end

  def basic_conditional?(); end

  def basic_literal?(); end

  def begin_type?(); end

  def block_pass_type?(); end

  def block_type?(); end

  def blockarg_expr_type?(); end

  def blockarg_type?(); end

  def boolean_type?(); end

  def break_type?(); end

  def call_type?(); end

  def case_match_type?(); end

  def case_type?(); end

  def casgn_type?(); end

  def cbase_type?(); end

  def chained?(); end

  def child_nodes(); end

  def class_constructor?(node=T.unsafe(nil)); end

  def class_type?(); end

  def complete!(); end

  def complete?(); end

  def complex_type?(); end

  def conditional?(); end

  def const_name(); end

  def const_pattern_type?(); end

  def const_type?(); end

  def csend_type?(); end

  def cvar_type?(); end

  def cvasgn_type?(); end

  def def_type?(); end

  def defined_module(); end

  def defined_module_name(); end

  def defined_type?(); end

  def defs_type?(); end

  def descendants(); end

  def dstr_type?(); end

  def dsym_type?(); end

  def each_ancestor(*types, &block); end

  def each_child_node(*types); end

  def each_descendant(*types, &block); end

  def each_node(*types, &block); end

  def eflipflop_type?(); end

  def empty_else_type?(); end

  def empty_source?(); end

  def ensure_type?(); end

  def equals_asgn?(); end

  def erange_type?(); end

  def false_type?(); end

  def falsey_literal?(); end

  def first_line(); end

  def float_type?(); end

  def for_type?(); end

  def forward_args_type?(); end

  def forwarded_args_type?(); end

  def guard_clause?(); end

  def gvar_type?(); end

  def gvasgn_type?(); end

  def hash_pattern_type?(); end

  def hash_type?(); end

  def ident_type?(); end

  def if_guard_type?(); end

  def if_type?(); end

  def iflipflop_type?(); end

  def immutable_literal?(); end

  def in_match_type?(); end

  def in_pattern_type?(); end

  def index_type?(); end

  def indexasgn_type?(); end

  def int_type?(); end

  def irange_type?(); end

  def ivar_type?(); end

  def ivasgn_type?(); end

  def keyword?(); end

  def kwarg_type?(); end

  def kwbegin_type?(); end

  def kwnilarg_type?(); end

  def kwoptarg_type?(); end

  def kwrestarg_type?(); end

  def kwsplat_type?(); end

  def lambda?(node=T.unsafe(nil)); end

  def lambda_or_proc?(node=T.unsafe(nil)); end

  def lambda_type?(); end

  def last_line(); end

  def line_count(); end

  def literal?(); end

  def lvar_type?(); end

  def lvasgn_type?(); end

  def masgn_type?(); end

  def match_alt_type?(); end

  def match_as_type?(); end

  def match_current_line_type?(); end

  def match_guard_clause?(node=T.unsafe(nil)); end

  def match_nil_pattern_type?(); end

  def match_rest_type?(); end

  def match_var_type?(); end

  def match_with_lvasgn_type?(); end

  def match_with_trailing_comma_type?(); end

  def mlhs_type?(); end

  def module_type?(); end

  def multiline?(); end

  def mutable_literal?(); end

  def new_class_or_module_block?(node=T.unsafe(nil)); end

  def next_type?(); end

  def nil_type?(); end

  def node_parts(); end

  def nonempty_line_count(); end

  def not_type?(); end

  def nth_ref_type?(); end

  def numargs_type?(); end

  def numblock_type?(); end

  def numeric_type?(); end

  def objc_kwarg_type?(); end

  def objc_restarg_type?(); end

  def objc_varargs_type?(); end

  def op_asgn_type?(); end

  def operator_keyword?(); end

  def optarg_type?(); end

  def or_asgn_type?(); end

  def or_type?(); end

  def pair_type?(); end

  def parent(); end

  def parent=(node); end

  def parent_module_name(); end

  def parenthesized_call?(); end

  def pin_type?(); end

  def postexe_type?(); end

  def preexe_type?(); end

  def proc?(node=T.unsafe(nil)); end

  def procarg0_type?(); end

  def pure?(); end

  def range_type?(); end

  def rational_type?(); end

  def receiver(node=T.unsafe(nil)); end

  def recursive_basic_literal?(); end

  def recursive_literal?(); end

  def redo_type?(); end

  def reference?(); end

  def regexp_type?(); end

  def regopt_type?(); end

  def resbody_type?(); end

  def rescue_type?(); end

  def restarg_expr_type?(); end

  def restarg_type?(); end

  def retry_type?(); end

  def return_type?(); end

  def root_type?(); end

  def sclass_type?(); end

  def self_type?(); end

  def send_type?(); end

  def shadowarg_type?(); end

  def shorthand_asgn?(); end

  def sibling_index(); end

  def single_line?(); end

  def source(); end

  def source_length(); end

  def source_range(); end

  def special_keyword?(); end

  def splat_type?(); end

  def str_content(node=T.unsafe(nil)); end

  def str_type?(); end

  def super_type?(); end

  def sym_type?(); end

  def true_type?(); end

  def truthy_literal?(); end

  def undef_type?(); end

  def unless_guard_type?(); end

  def until_post_type?(); end

  def until_type?(); end

  def value_used?(); end

  def variable?(); end

  def visit_descendants(types, &block); end

  def when_type?(); end

  def while_post_type?(); end

  def while_type?(); end

  def xstr_type?(); end

  def yield_type?(); end

  def zsuper_type?(); end
  ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  BASIC_CONDITIONALS = ::T.let(nil, ::T.untyped)
  BASIC_LITERALS = ::T.let(nil, ::T.untyped)
  COMPARISON_OPERATORS = ::T.let(nil, ::T.untyped)
  COMPOSITE_LITERALS = ::T.let(nil, ::T.untyped)
  CONDITIONALS = ::T.let(nil, ::T.untyped)
  EQUALS_ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  FALSEY_LITERALS = ::T.let(nil, ::T.untyped)
  IMMUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  LITERALS = ::T.let(nil, ::T.untyped)
  MUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  OPERATOR_KEYWORDS = ::T.let(nil, ::T.untyped)
  REFERENCES = ::T.let(nil, ::T.untyped)
  SHORTHAND_ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  SPECIAL_KEYWORDS = ::T.let(nil, ::T.untyped)
  TRUTHY_LITERALS = ::T.let(nil, ::T.untyped)
  VARIABLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Node
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::AST::NumericNode
  def sign?(); end
  SIGN_REGEX = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::NumericNode
end

class RuboCop::AST::OrNode
  include ::RuboCop::AST::BinaryOperatorNode
  include ::RuboCop::AST::PredicateOperatorNode
  def alternate_operator(); end

  def inverse_operator(); end
end

class RuboCop::AST::OrNode
end

class RuboCop::AST::PairNode
  include ::RuboCop::AST::HashElementNode
  def colon?(); end

  def delimiter(with_spacing=T.unsafe(nil)); end

  def hash_rocket?(); end

  def inverse_delimiter(with_spacing=T.unsafe(nil)); end

  def value_on_new_line?(); end
  COLON = ::T.let(nil, ::T.untyped)
  HASH_ROCKET = ::T.let(nil, ::T.untyped)
  SPACED_COLON = ::T.let(nil, ::T.untyped)
  SPACED_HASH_ROCKET = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::PairNode
end

module RuboCop::AST::ParameterizedNode
  def arguments?(); end

  def block_argument?(); end

  def first_argument(); end

  def last_argument(); end

  def parenthesized?(); end

  def rest_argument?(); end

  def splat_argument?(); end
end

module RuboCop::AST::ParameterizedNode
end

module RuboCop::AST::PredicateOperatorNode
  def logical_operator?(); end

  def operator(); end

  def semantic_operator?(); end
  LOGICAL_AND = ::T.let(nil, ::T.untyped)
  LOGICAL_OR = ::T.let(nil, ::T.untyped)
  SEMANTIC_AND = ::T.let(nil, ::T.untyped)
  SEMANTIC_OR = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::PredicateOperatorNode
end

class RuboCop::AST::RangeNode
  def begin(); end

  def end(); end
end

class RuboCop::AST::RangeNode
end

class RuboCop::AST::RegexpNode
  def content(); end

  def regopt(); end

  def to_regexp(); end
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::RegexpNode
end

class RuboCop::AST::ResbodyNode
  def body(); end

  def exception_variable(); end
end

class RuboCop::AST::ResbodyNode
end

class RuboCop::AST::RetryNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  include ::RuboCop::AST::ParameterizedNode
end

class RuboCop::AST::RetryNode
end

class RuboCop::AST::ReturnNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  include ::RuboCop::AST::ParameterizedNode
end

class RuboCop::AST::ReturnNode
end

class RuboCop::AST::SelfClassNode
  def body(); end

  def identifier(); end
end

class RuboCop::AST::SelfClassNode
end

class RuboCop::AST::SendNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
end

class RuboCop::AST::SendNode
end

module RuboCop::AST::Sexp
  def s(type, *children); end
end

module RuboCop::AST::Sexp
end

class RuboCop::AST::StrNode
  include ::RuboCop::AST::BasicLiteralNode
  def heredoc?(); end
end

class RuboCop::AST::StrNode
end

class RuboCop::AST::SuperNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
end

class RuboCop::AST::SuperNode
end

class RuboCop::AST::SymbolNode
  include ::RuboCop::AST::BasicLiteralNode
end

class RuboCop::AST::SymbolNode
end

module RuboCop::AST::Traversal
  def on_alias(node); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_arg(node); end

  def on_arg_expr(node); end

  def on_args(node); end

  def on_array(node); end

  def on_array_pattern(node); end

  def on_array_pattern_with_tail(node); end

  def on_back_ref(node); end

  def on_begin(node); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_blockarg(node); end

  def on_break(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_casgn(node); end

  def on_cbase(node); end

  def on_class(node); end

  def on_complex(node); end

  def on_const(node); end

  def on_const_pattern(node); end

  def on_csend(node); end

  def on_cvar(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_defined?(node); end

  def on_defs(node); end

  def on_dstr(node); end

  def on_dsym(node); end

  def on_eflipflop(node); end

  def on_empty_else(node); end

  def on_ensure(node); end

  def on_erange(node); end

  def on_false(node); end

  def on_float(node); end

  def on_for(node); end

  def on_forward_args(node); end

  def on_forwarded_args(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def on_hash(node); end

  def on_hash_pattern(node); end

  def on_if(node); end

  def on_if_guard(node); end

  def on_iflipflop(node); end

  def on_in_match(node); end

  def on_in_pattern(node); end

  def on_int(node); end

  def on_irange(node); end

  def on_ivar(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwbegin(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_kwsplat(node); end

  def on_lambda(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_alt(node); end

  def on_match_as(node); end

  def on_match_current_line(node); end

  def on_match_nil_pattern(node); end

  def on_match_rest(node); end

  def on_match_var(node); end

  def on_match_with_lvasgn(node); end

  def on_match_with_trailing_comma(node); end

  def on_mlhs(node); end

  def on_module(node); end

  def on_next(node); end

  def on_nil(node); end

  def on_not(node); end

  def on_nth_ref(node); end

  def on_numblock(node); end

  def on_op_asgn(node); end

  def on_optarg(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_pin(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_rational(node); end

  def on_redo(node); end

  def on_regexp(node); end

  def on_regopt(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_restarg(node); end

  def on_retry(node); end

  def on_return(node); end

  def on_sclass(node); end

  def on_self(node); end

  def on_send(node); end

  def on_shadowarg(node); end

  def on_splat(node); end

  def on_str(node); end

  def on_super(node); end

  def on_sym(node); end

  def on_true(node); end

  def on_undef(node); end

  def on_unless_guard(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_when(node); end

  def on_while(node); end

  def on_while_post(node); end

  def on_xstr(node); end

  def on_yield(node); end

  def on_zsuper(node); end

  def walk(node); end
  MANY_CHILD_NODES = ::T.let(nil, ::T.untyped)
  NO_CHILD_NODES = ::T.let(nil, ::T.untyped)
  ONE_CHILD_NODE = ::T.let(nil, ::T.untyped)
  SECOND_CHILD_ONLY = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::Traversal
end

class RuboCop::AST::UntilNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def do?(); end

  def inverse_keyword(); end

  def keyword(); end
end

class RuboCop::AST::UntilNode
end

class RuboCop::AST::WhenNode
  def body(); end

  def branch_index(); end

  def conditions(); end

  def each_condition(); end

  def then?(); end
end

class RuboCop::AST::WhenNode
end

class RuboCop::AST::WhileNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def do?(); end

  def inverse_keyword(); end

  def keyword(); end
end

class RuboCop::AST::WhileNode
end

class RuboCop::AST::YieldNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
end

class RuboCop::AST::YieldNode
end

module RuboCop::AST
end

class RuboCop::CLI
  def config_store(); end

  def options(); end

  def run(args=T.unsafe(nil)); end
  STATUS_ERROR = ::T.let(nil, ::T.untyped)
  STATUS_INTERRUPTED = ::T.let(nil, ::T.untyped)
  STATUS_OFFENSES = ::T.let(nil, ::T.untyped)
  STATUS_SUCCESS = ::T.let(nil, ::T.untyped)
end

module RuboCop::CLI::Command
end

class RuboCop::CLI::Command::AutoGenerateConfig
  def run(); end
  PHASE_1 = ::T.let(nil, ::T.untyped)
  PHASE_1_DISABLED = ::T.let(nil, ::T.untyped)
  PHASE_1_OVERRIDDEN = ::T.let(nil, ::T.untyped)
  PHASE_2 = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::AutoGenerateConfig
end

class RuboCop::CLI::Command::Base
  def env(); end

  def initialize(env); end
end

class RuboCop::CLI::Command::Base
  def self.by_command_name(name); end

  def self.command_name(); end

  def self.command_name=(command_name); end

  def self.inherited(subclass); end
end

class RuboCop::CLI::Command::ExecuteRunner
  include ::RuboCop::Formatter::TextUtil
  def run(); end
end

class RuboCop::CLI::Command::ExecuteRunner
end

class RuboCop::CLI::Command::InitDotfile
  def run(); end
  DOTFILE = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::InitDotfile
end

class RuboCop::CLI::Command::ShowCops
  def run(); end
end

class RuboCop::CLI::Command::ShowCops
end

class RuboCop::CLI::Command::Version
  def run(); end
end

class RuboCop::CLI::Command::Version
end

module RuboCop::CLI::Command
  def self.run(env, name); end
end

class RuboCop::CLI::Environment
  def config_store(); end

  def initialize(options, config_store, paths); end

  def options(); end

  def paths(); end

  def run(name); end
end

class RuboCop::CLI::Environment
end

class RuboCop::CLI::Finished
end

class RuboCop::CLI::Finished
end

class RuboCop::CLI
end

class RuboCop::CachedData
  def from_json(text); end

  def initialize(filename); end

  def to_json(offenses); end
end

class RuboCop::CachedData
end

class RuboCop::CommentConfig
  def cop_disabled_line_ranges(); end

  def cop_enabled_at_line?(cop, line_number); end

  def extra_enabled_comments(); end

  def initialize(processed_source); end

  def processed_source(); end
  COMMENT_DIRECTIVE_REGEXP = ::T.let(nil, ::T.untyped)
  COPS_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAMES_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  REDUNDANT_DISABLE = ::T.let(nil, ::T.untyped)
end

class RuboCop::CommentConfig::CopAnalysis
  def line_ranges(); end

  def line_ranges=(_); end

  def start_line_number(); end

  def start_line_number=(_); end
end

class RuboCop::CommentConfig::CopAnalysis
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::CommentConfig
end

class RuboCop::Config
  include ::RuboCop::PathUtil
  include ::RuboCop::FileFinder
  def [](*args, &block); end

  def []=(*args, &block); end

  def add_excludes_from_higher_level(highest_config); end

  def allowed_camel_case_file?(file); end

  def base_dir_for_path_parameters(); end

  def bundler_lock_file_path(); end

  def check(); end

  def delete(*args, &block); end

  def deprecation_check(); end

  def disabled_new_cops?(); end

  def each(*args, &block); end

  def each_key(*args, &block); end

  def enabled_new_cops?(); end

  def file_to_exclude?(file); end

  def file_to_include?(file); end

  def for_all_cops(); end

  def for_cop(cop); end

  def for_department(department_name); end

  def initialize(hash=T.unsafe(nil), loaded_path=T.unsafe(nil)); end

  def internal?(); end

  def key?(*args, &block); end

  def keys(*args, &block); end

  def loaded_path(); end

  def make_excludes_absolute(); end

  def map(*args, &block); end

  def merge(*args, &block); end

  def path_relative_to_config(path); end

  def patterns_to_exclude(); end

  def patterns_to_include(); end

  def pending_cops(); end

  def possibly_include_hidden?(); end

  def signature(); end

  def smart_loaded_path(); end

  def target_rails_version(); end

  def target_ruby_version(*args, &block); end

  def to_h(*args, &block); end

  def to_hash(*args, &block); end

  def transform_values(*args, &block); end

  def validate(*args, &block); end
  DEFAULT_RAILS_VERSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Config::CopConfig
  def metadata(); end

  def metadata=(_); end

  def name(); end

  def name=(_); end
end

class RuboCop::Config::CopConfig
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Config
  extend ::Forwardable
  def self.create(hash, path); end
end

class RuboCop::ConfigLoader
  AUTO_GENERATED_FILE = ::T.let(nil, ::T.untyped)
  DEFAULT_FILE = ::T.let(nil, ::T.untyped)
  DOTFILE = ::T.let(nil, ::T.untyped)
  RUBOCOP_HOME = ::T.let(nil, ::T.untyped)
  XDG_CONFIG = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigLoader
  extend ::RuboCop::FileFinder
  def self.add_excludes_from_files(config, config_file); end

  def self.add_inheritance_from_auto_generated_file(); end

  def self.add_missing_namespaces(path, hash); end

  def self.auto_gen_config(); end

  def self.auto_gen_config=(auto_gen_config); end

  def self.auto_gen_config?(); end

  def self.clear_options(); end

  def self.configuration_file_for(target_dir); end

  def self.configuration_from_file(config_file); end

  def self.debug(); end

  def self.debug=(debug); end

  def self.debug?(); end

  def self.default_configuration(); end

  def self.default_configuration=(default_configuration); end

  def self.disable_pending_cops(); end

  def self.disable_pending_cops=(disable_pending_cops); end

  def self.enable_pending_cops(); end

  def self.enable_pending_cops=(enable_pending_cops); end

  def self.ignore_parent_exclusion(); end

  def self.ignore_parent_exclusion=(ignore_parent_exclusion); end

  def self.ignore_parent_exclusion?(); end

  def self.load_file(file); end

  def self.merge(base_hash, derived_hash); end

  def self.merge_with_default(config, config_file, unset_nil: T.unsafe(nil)); end

  def self.options_config(); end

  def self.options_config=(options_config); end

  def self.possible_new_cops?(config); end

  def self.warn_on_pending_cops(pending_cops); end
end

class RuboCop::ConfigLoaderResolver
  def merge(base_hash, derived_hash, **opts); end

  def merge_with_default(config, config_file, unset_nil:); end

  def resolve_inheritance(path, hash, file, debug); end

  def resolve_inheritance_from_gems(hash); end

  def resolve_requires(path, hash); end
end

class RuboCop::ConfigLoaderResolver
end

class RuboCop::ConfigNotFoundError
end

class RuboCop::ConfigNotFoundError
end

class RuboCop::ConfigObsoletion
  def initialize(config); end

  def reject_obsolete_cops_and_parameters(); end
  MOVED_COPS = ::T.let(nil, ::T.untyped)
  OBSOLETE_COPS = ::T.let(nil, ::T.untyped)
  OBSOLETE_ENFORCED_STYLES = ::T.let(nil, ::T.untyped)
  OBSOLETE_PARAMETERS = ::T.let(nil, ::T.untyped)
  REMOVED_COPS = ::T.let(nil, ::T.untyped)
  REMOVED_COPS_WITH_REASON = ::T.let(nil, ::T.untyped)
  RENAMED_COPS = ::T.let(nil, ::T.untyped)
  SPLIT_COPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion
end

class RuboCop::ConfigStore
  def for(file_or_dir); end

  def force_default_config!(); end

  def options_config=(options_config); end
end

class RuboCop::ConfigStore
end

class RuboCop::ConfigValidator
  def for_all_cops(*args, &block); end

  def initialize(config); end

  def smart_loaded_path(*args, &block); end

  def target_ruby_version(); end

  def validate(); end

  def validate_section_presence(name); end
  COMMON_PARAMS = ::T.let(nil, ::T.untyped)
  INTERNAL_PARAMS = ::T.let(nil, ::T.untyped)
  NEW_COPS_VALUES = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigValidator
  extend ::Forwardable
end

module RuboCop::Cop
end

module RuboCop::Cop::Alignment
  SPACE = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Alignment
end

class RuboCop::Cop::AlignmentCorrector
end

class RuboCop::Cop::AlignmentCorrector
  extend ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::Alignment
  def self.align_end(processed_source, node, align_to); end

  def self.correct(processed_source, node, column_delta); end

  def self.processed_source(); end
end

class RuboCop::Cop::AmbiguousCopName
  def initialize(name, origin, badges); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::AmbiguousCopName
end

module RuboCop::Cop::ArrayMinSize
end

module RuboCop::Cop::ArrayMinSize
end

module RuboCop::Cop::ArraySyntax
end

module RuboCop::Cop::ArraySyntax
end

module RuboCop::Cop::AutocorrectLogic
  def autocorrect?(); end

  def autocorrect_enabled?(); end

  def autocorrect_requested?(); end

  def correctable?(); end

  def disable_offense(node); end

  def disable_uncorrectable?(); end

  def safe_autocorrect?(); end

  def support_autocorrect?(); end
end

module RuboCop::Cop::AutocorrectLogic
end

class RuboCop::Cop::Badge
  def ==(other); end

  def cop_name(); end

  def department(); end

  def eql?(other); end

  def initialize(department, cop_name); end

  def match?(other); end

  def qualified?(); end

  def with_department(department); end
end

class RuboCop::Cop::Badge::InvalidBadge
  def initialize(token); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Badge::InvalidBadge
end

class RuboCop::Cop::Badge
  def self.for(class_name); end

  def self.parse(identifier); end
end

module RuboCop::Cop::Bundler
end

class RuboCop::Cop::Bundler::DuplicatedGem
  include ::RuboCop::Cop::RangeHelp
  def gem_declarations(node0); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::DuplicatedGem
end

class RuboCop::Cop::Bundler::GemComment
  include ::RuboCop::Cop::DefNode
  def gem_declaration?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::GemComment
end

class RuboCop::Cop::Bundler::InsecureProtocolSource
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def insecure_protocol_source?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::InsecureProtocolSource
end

class RuboCop::Cop::Bundler::OrderedGems
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::OrderedGemNode
  def autocorrect(node); end

  def gem_declarations(node0); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::OrderedGems
end

module RuboCop::Cop::Bundler
end

module RuboCop::Cop::CheckAssignment
  def on_and_asgn(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
end

module RuboCop::Cop::CheckAssignment
  def self.extract_rhs(node); end
end

module RuboCop::Cop::CheckLineBreakable
  def extract_breakable_node(node, max); end
end

module RuboCop::Cop::CheckLineBreakable
end

module RuboCop::Cop::ClassishLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::ClassishLength
end

module RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::CodeLength
end

class RuboCop::Cop::Commissioner
  include ::RuboCop::AST::Traversal
  def errors(); end

  def initialize(cops, forces=T.unsafe(nil), options=T.unsafe(nil)); end

  def investigate(processed_source); end
end

class RuboCop::Cop::Commissioner
end

class RuboCop::Cop::ConditionCorrector
end

class RuboCop::Cop::ConditionCorrector
  def self.correct_negative_condition(node); end
end

module RuboCop::Cop::ConfigurableEnforcedStyle
  def alternative_style(); end

  def alternative_styles(); end

  def ambiguous_style_detected(*possibilities); end

  def conflicting_styles_detected(); end

  def correct_style_detected(); end

  def detected_style(); end

  def detected_style=(style); end

  def no_acceptable_style!(); end

  def no_acceptable_style?(); end

  def opposite_style_detected(); end

  def style(); end

  def style_configured?(); end

  def style_detected(detected); end

  def style_parameter_name(); end

  def supported_styles(); end

  def unexpected_style_detected(unexpected); end

  def unrecognized_style_detected(); end
end

module RuboCop::Cop::ConfigurableEnforcedStyle
end

module RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def check_name(node, name, name_range); end

  def class_emitter_method?(node, name); end

  def report_opposing_styles(node, name); end

  def valid_name?(node, name, given_style=T.unsafe(nil)); end
end

module RuboCop::Cop::ConfigurableFormatting
end

module RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  FORMATS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ConfigurableNaming
end

module RuboCop::Cop::ConfigurableNumbering
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  FORMATS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ConfigurableNumbering
end

class RuboCop::Cop::Cop
  include ::RuboCop::AST::Sexp
  include ::RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  include ::RuboCop::Cop::IgnoredNode
  include ::RuboCop::Cop::AutocorrectLogic
  def add_offense(node, location: T.unsafe(nil), message: T.unsafe(nil), severity: T.unsafe(nil)); end

  def config(); end

  def config_to_allow_offenses(); end

  def config_to_allow_offenses=(hash); end

  def cop_config(); end

  def cop_name(); end

  def correct(node); end

  def corrections(); end

  def disable_uncorrectable(node); end

  def duplicate_location?(location); end

  def excluded_file?(file); end

  def external_dependency_checksum(); end

  def find_location(node, loc); end

  def initialize(config=T.unsafe(nil), options=T.unsafe(nil)); end

  def join_force?(_force_class); end

  def message(_node=T.unsafe(nil)); end

  def name(); end

  def offenses(); end

  def parse(source, path=T.unsafe(nil)); end

  def processed_source(); end

  def processed_source=(processed_source); end

  def reason_to_not_correct(node); end

  def relevant_file?(file); end

  def target_rails_version(); end

  def target_ruby_version(); end
end

class RuboCop::Cop::Cop::Correction
  def call(corrector); end

  def cop(); end

  def cop=(_); end

  def lambda=(_); end

  def node(); end

  def node=(_); end
end

class RuboCop::Cop::Cop::Correction
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::Cop
  extend ::RuboCop::AST::Sexp
  extend ::RuboCop::NodePattern::Macros
  def self.all(); end

  def self.autocorrect_incompatible_with(); end

  def self.badge(); end

  def self.cop_name(); end

  def self.department(); end

  def self.inherited(subclass); end

  def self.lint?(); end

  def self.match?(given_names); end

  def self.qualified_cop_name(name, origin); end

  def self.registry(); end
end

class RuboCop::Cop::Corrector
  def corrections(); end

  def diagnostics(); end

  def initialize(source_buffer, corrections=T.unsafe(nil)); end

  def insert_after(node_or_range, content); end

  def insert_before(node_or_range, content); end

  def remove(node_or_range); end

  def remove_leading(node_or_range, size); end

  def remove_preceding(node_or_range, size); end

  def remove_trailing(node_or_range, size); end

  def replace(node_or_range, content); end

  def rewrite(); end

  def wrap(node_or_range, before, after); end
end

class RuboCop::Cop::Corrector
end

module RuboCop::Cop::DefNode
  def non_public_modifier?(node=T.unsafe(nil)); end
  NON_PUBLIC_MODIFIERS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::DefNode
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::Style::AnnotationComment
end

module RuboCop::Cop::DocumentationComment
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::Duplication
end

module RuboCop::Cop::Duplication
end

class RuboCop::Cop::EachToForCorrector
  def call(corrector); end

  def initialize(block_node); end
  CORRECTION_WITHOUT_ARGUMENTS = ::T.let(nil, ::T.untyped)
  CORRECTION_WITH_ARGUMENTS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::EachToForCorrector
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::EmptyLineCorrector
end

class RuboCop::Cop::EmptyLineCorrector
  def self.correct(node); end

  def self.insert_before(node); end
end

module RuboCop::Cop::EmptyParameter
  def empty_arguments?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::EmptyParameter
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::EndKeywordAlignment
end

module RuboCop::Cop::EnforceSuperclass
  def on_class(node); end

  def on_send(node); end
end

module RuboCop::Cop::EnforceSuperclass
  def self.included(base); end
end

module RuboCop::Cop::FirstElementLineBreak
end

module RuboCop::Cop::FirstElementLineBreak
end

class RuboCop::Cop::ForToEachCorrector
  def call(corrector); end

  def initialize(for_node); end
  CORRECTION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::ForToEachCorrector
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::Force
  def cops(); end

  def initialize(cops); end

  def investigate(_processed_source); end

  def name(); end

  def run_hook(method_name, *args); end
end

class RuboCop::Cop::Force
  def self.all(); end

  def self.force_name(); end

  def self.inherited(subclass); end
end

module RuboCop::Cop::FrozenStringLiteral
  FROZEN_STRING_LITERAL = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LITERAL_ENABLED = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::FrozenStringLiteral
  def self.frozen_string_literal_comment_exists?(); end
end

module RuboCop::Cop::Gemspec
end

class RuboCop::Cop::Gemspec::DuplicatedAssignment
  include ::RuboCop::Cop::RangeHelp
  def assignment_method_declarations(node0); end

  def gem_specification(node0); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::DuplicatedAssignment
end

class RuboCop::Cop::Gemspec::OrderedDependencies
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::OrderedGemNode
  def autocorrect(node); end

  def dependency_declarations(node0); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::OrderedDependencies
end

class RuboCop::Cop::Gemspec::RequiredRubyVersion
  def investigate(processed_source); end

  def required_ruby_version(node0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RequiredRubyVersion
end

class RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage
  def gem_specification?(node0); end

  def on_const(node); end

  def ruby_version?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage
end

module RuboCop::Cop::Gemspec
end

class RuboCop::Cop::Generator
  def initialize(name, github_user, output: T.unsafe(nil)); end

  def inject_config(config_file_path: T.unsafe(nil)); end

  def inject_require(root_file_path: T.unsafe(nil)); end

  def todo(); end

  def write_source(); end

  def write_spec(); end
  CONFIGURATION_ADDED_MESSAGE = ::T.let(nil, ::T.untyped)
  SOURCE_TEMPLATE = ::T.let(nil, ::T.untyped)
  SPEC_TEMPLATE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::ConfigurationInjector
  def initialize(configuration_file_path:, badge:, version_added:); end

  def inject(); end
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::ConfigurationInjector
end

class RuboCop::Cop::Generator::RequireFileInjector
  def initialize(source_path:, root_file_path:, output: T.unsafe(nil)); end

  def inject(); end
  REQUIRE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::RequireFileInjector
end

class RuboCop::Cop::Generator
end

module RuboCop::Cop::HashAlignmentStyles
end

class RuboCop::Cop::HashAlignmentStyles::KeyAlignment
  def checkable_layout?(_node); end

  def deltas(first_pair, current_pair); end

  def deltas_for_first_pair(first_pair, _node); end
end

class RuboCop::Cop::HashAlignmentStyles::KeyAlignment
end

class RuboCop::Cop::HashAlignmentStyles::SeparatorAlignment
  include ::RuboCop::Cop::HashAlignmentStyles::ValueAlignment
  def deltas_for_first_pair(*_nodes); end
end

class RuboCop::Cop::HashAlignmentStyles::SeparatorAlignment
end

class RuboCop::Cop::HashAlignmentStyles::TableAlignment
  include ::RuboCop::Cop::HashAlignmentStyles::ValueAlignment
  def deltas_for_first_pair(first_pair, node); end
end

class RuboCop::Cop::HashAlignmentStyles::TableAlignment
end

module RuboCop::Cop::HashAlignmentStyles::ValueAlignment
  def checkable_layout?(node); end

  def deltas(first_pair, current_pair); end
end

module RuboCop::Cop::HashAlignmentStyles::ValueAlignment
end

module RuboCop::Cop::HashAlignmentStyles
end

module RuboCop::Cop::HashTransformMethod
  def autocorrect(node); end

  def on_block(node); end

  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::HashTransformMethod::Autocorrection
  def block_node(); end

  def block_node=(_); end

  def leading(); end

  def leading=(_); end

  def match(); end

  def match=(_); end

  def set_new_arg_name(transformed_argname, corrector); end

  def set_new_body_expression(transforming_body_expr, corrector); end

  def set_new_method_name(new_method_name, corrector); end

  def strip_prefix_and_suffix(node, corrector); end

  def trailing(); end

  def trailing=(_); end
end

class RuboCop::Cop::HashTransformMethod::Autocorrection
  def self.[](*_); end

  def self.from_each_with_object(node, match); end

  def self.from_hash_brackets_map(node, match); end

  def self.from_map_to_h(node, match); end

  def self.members(); end
end

class RuboCop::Cop::HashTransformMethod::Captures
  def noop_transformation?(); end

  def transformation_uses_both_args?(); end

  def transformed_argname(); end

  def transformed_argname=(_); end

  def transforming_body_expr(); end

  def transforming_body_expr=(_); end

  def unchanged_body_expr(); end

  def unchanged_body_expr=(_); end
end

class RuboCop::Cop::HashTransformMethod::Captures
  def self.[](*_); end

  def self.members(); end
end

module RuboCop::Cop::HashTransformMethod
end

module RuboCop::Cop::Heredoc
  def on_dstr(node); end

  def on_heredoc(_node); end

  def on_str(node); end

  def on_xstr(node); end
  OPENING_DELIMITER = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Heredoc
end

module RuboCop::Cop::IgnoredMethods
end

module RuboCop::Cop::IgnoredMethods
end

module RuboCop::Cop::IgnoredNode
  def ignore_node(node); end

  def ignored_node?(node); end

  def part_of_ignored_node?(node); end
end

module RuboCop::Cop::IgnoredNode
end

module RuboCop::Cop::IgnoredPattern
end

module RuboCop::Cop::IgnoredPattern
end

module RuboCop::Cop::IntegerNode
end

module RuboCop::Cop::IntegerNode
end

module RuboCop::Cop::Interpolation
  def on_dstr(node); end

  def on_dsym(node); end

  def on_node_with_interpolations(node); end

  def on_regexp(node); end

  def on_xstr(node); end
end

module RuboCop::Cop::Interpolation
end

class RuboCop::Cop::LambdaLiteralToMethodCorrector
  def call(corrector); end

  def initialize(block_node); end
end

class RuboCop::Cop::LambdaLiteralToMethodCorrector
end

module RuboCop::Cop::Layout
end

class RuboCop::Cop::Layout::AccessModifierIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AccessModifierIndentation
end

class RuboCop::Cop::Layout::ArgumentAlignment
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
  ALIGN_PARAMS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ArgumentAlignment
end

class RuboCop::Cop::Layout::ArrayAlignment
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_array(node); end
  ALIGN_ELEMENTS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ArrayAlignment
end

class RuboCop::Cop::Layout::AssignmentIndentation
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def check_assignment(node, rhs); end

  def leftmost_multiple_assignment(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AssignmentIndentation
end

class RuboCop::Cop::Layout::BlockAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def block_end_align_target?(node=T.unsafe(nil), param1); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BlockAlignment
end

class RuboCop::Cop::Layout::BlockEndNewline
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BlockEndNewline
end

class RuboCop::Cop::Layout::CaseIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_case(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::CaseIndentation
end

class RuboCop::Cop::Layout::ClassStructure
  def autocorrect(node); end

  def on_class(class_node); end

  def visibility_block?(node=T.unsafe(nil)); end
  HUMANIZED_NODE_TYPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  VISIBILITY_SCOPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClassStructure
end

class RuboCop::Cop::Layout::ClosingHeredocIndentation
  include ::RuboCop::Cop::Heredoc
  def autocorrect(node); end

  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_ARG = ::T.let(nil, ::T.untyped)
  SIMPLE_HEREDOC = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClosingHeredocIndentation
end

class RuboCop::Cop::Layout::ClosingParenthesisIndentation
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_begin(node); end

  def on_csend(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
  MSG_ALIGN = ::T.let(nil, ::T.untyped)
  MSG_INDENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClosingParenthesisIndentation
end

class RuboCop::Cop::Layout::CommentIndentation
  include ::RuboCop::Cop::Alignment
  def autocorrect(comment); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::CommentIndentation
end

class RuboCop::Cop::Layout::ConditionPosition
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ConditionPosition
end

class RuboCop::Cop::Layout::DefEndAlignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::DefEndAlignment
end

class RuboCop::Cop::Layout::DotPosition
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::DotPosition
end

class RuboCop::Cop::Layout::ElseAlignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::CheckAssignment
  def autocorrect(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_if(node, base=T.unsafe(nil)); end

  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ElseAlignment
end

class RuboCop::Cop::Layout::EmptyComment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyComment
end

class RuboCop::Cop::Layout::EmptyLineAfterGuardClause
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_if(node); end
  END_OF_HEREDOC_LINE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterGuardClause
end

class RuboCop::Cop::Layout::EmptyLineAfterMagicComment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(token); end

  def investigate(source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterMagicComment
end

class RuboCop::Cop::Layout::EmptyLineBetweenDefs
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def check_defs(nodes); end

  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineBetweenDefs
end

class RuboCop::Cop::Layout::EmptyLines
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  LINE_OFFSET = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLines
end

class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end

  def on_send(node); end
  MSG_AFTER = ::T.let(nil, ::T.untyped)
  MSG_AFTER_FOR_ONLY_BEFORE = ::T.let(nil, ::T.untyped)
  MSG_BEFORE_AND_AFTER = ::T.let(nil, ::T.untyped)
  MSG_BEFORE_FOR_ONLY_BEFORE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier
end

class RuboCop::Cop::Layout::EmptyLinesAroundArguments
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundArguments
end

class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_kwbegin(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody
end

class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody
end

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def constant_definition?(node=T.unsafe(nil)); end

  def empty_line_required?(node=T.unsafe(nil)); end
  MSG_DEFERRED = ::T.let(nil, ::T.untyped)
  MSG_EXTRA = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::Layout::EmptyLinesAroundClassBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_class(node); end

  def on_sclass(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundClassBody
end

class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords
end

class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody
end

class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_module(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody
end

class RuboCop::Cop::Layout::EndAlignment
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_case(node); end

  def on_class(node); end

  def on_if(node); end

  def on_module(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Layout::EndAlignment
end

class RuboCop::Cop::Layout::EndOfLine
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end

  def offense_message(line); end

  def unimportant_missing_cr?(index, last_line, line); end
  MSG_DETECTED = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EndOfLine
end

class RuboCop::Cop::Layout::ExtraSpacing
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG_UNALIGNED_ASGN = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ExtraSpacing
end

class RuboCop::Cop::Layout::FirstArgumentIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def eligible_method_call?(node=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArgumentIndentation
end

class RuboCop::Cop::Layout::FirstArrayElementIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  def autocorrect(node); end

  def on_array(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArrayElementIndentation
end

class RuboCop::Cop::Layout::FirstArrayElementLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def autocorrect(node); end

  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArrayElementLineBreak
end

class RuboCop::Cop::Layout::FirstHashElementIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  def autocorrect(node); end

  def on_csend(node); end

  def on_hash(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstHashElementIndentation
end

class RuboCop::Cop::Layout::FirstHashElementLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def autocorrect(node); end

  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstHashElementLineBreak
end

class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end

  def on_super(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak
end

class RuboCop::Cop::Layout::FirstMethodParameterLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstMethodParameterLineBreak
end

class RuboCop::Cop::Layout::FirstParameterIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstParameterIndentation
end

class RuboCop::Cop::Layout::HashAlignment
  include ::RuboCop::Cop::HashAlignmentStyles
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def column_deltas(); end

  def column_deltas=(column_deltas); end

  def offences_by(); end

  def offences_by=(offences_by); end

  def on_hash(node); end

  def on_send(node); end

  def on_super(node); end

  def on_yield(node); end
  MESSAGES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HashAlignment
end

class RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis
end

class RuboCop::Cop::Layout::HeredocIndentation
  include ::RuboCop::Cop::Heredoc
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_heredoc(node); end
  LIBRARY_MSG = ::T.let(nil, ::T.untyped)
  RUBY23_TYPE_MSG = ::T.let(nil, ::T.untyped)
  RUBY23_WIDTH_MSG = ::T.let(nil, ::T.untyped)
  STRIP_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HeredocIndentation
end

class RuboCop::Cop::Layout::IndentationConsistency
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_begin(node); end

  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationConsistency
end

class RuboCop::Cop::Layout::IndentationStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationStyle
end

class RuboCop::Cop::Layout::IndentationWidth
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::IgnoredPattern
  def access_modifier?(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def on_block(node); end

  def on_case(case_node); end

  def on_class(node); end

  def on_csend(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_ensure(node); end

  def on_for(node); end

  def on_if(node, base=T.unsafe(nil)); end

  def on_kwbegin(node); end

  def on_module(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_sclass(node); end

  def on_until(node, base=T.unsafe(nil)); end

  def on_while(node, base=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationWidth
end

class RuboCop::Cop::Layout::InitialIndentation
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(_processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::InitialIndentation
end

class RuboCop::Cop::Layout::LeadingCommentSpace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(comment); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LeadingCommentSpace
end

class RuboCop::Cop::Layout::LeadingEmptyLines
  def autocorrect(node); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LeadingEmptyLines
end

class RuboCop::Cop::Layout::LineLength
  include ::RuboCop::Cop::CheckLineBreakable
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredPattern
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::LineLengthHelp
  def autocorrect(range); end

  def investigate(processed_source); end

  def investigate_post_walk(processed_source); end

  def on_array(node); end

  def on_block(node); end

  def on_hash(node); end

  def on_potential_breakable_node(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LineLength
end

class RuboCop::Cop::Layout::MultilineArrayBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_array(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineArrayBraceLayout
end

class RuboCop::Cop::Layout::MultilineArrayLineBreaks
  include ::RuboCop::Cop::MultilineElementLineBreaks
  def autocorrect(node); end

  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineArrayLineBreaks
end

class RuboCop::Cop::Layout::MultilineAssignmentLayout
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def check_assignment(node, rhs); end

  def check_by_enforced_style(node, rhs); end

  def check_new_line_offense(node, rhs); end

  def check_same_line_offense(node, rhs); end
  NEW_LINE_OFFENSE = ::T.let(nil, ::T.untyped)
  SAME_LINE_OFFENSE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineAssignmentLayout
end

class RuboCop::Cop::Layout::MultilineBlockLayout
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end
  ARG_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PIPE_SIZE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineBlockLayout
end

class RuboCop::Cop::Layout::MultilineHashBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_hash(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineHashBraceLayout
end

class RuboCop::Cop::Layout::MultilineHashKeyLineBreaks
  include ::RuboCop::Cop::MultilineElementLineBreaks
  def autocorrect(node); end

  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineHashKeyLineBreaks
end

class RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks
  include ::RuboCop::Cop::MultilineElementLineBreaks
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks
end

class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout
end

class RuboCop::Cop::Layout::MultilineMethodCallIndentation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::MultilineExpressionIndentation
  def autocorrect(node); end

  def validate_config(); end
end

class RuboCop::Cop::Layout::MultilineMethodCallIndentation
end

class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout
end

class RuboCop::Cop::Layout::MultilineOperationIndentation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::MultilineExpressionIndentation
  def autocorrect(node); end

  def on_and(node); end

  def on_or(node); end

  def validate_config(); end
end

class RuboCop::Cop::Layout::MultilineOperationIndentation
end

class RuboCop::Cop::Layout::ParameterAlignment
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  ALIGN_PARAMS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ParameterAlignment
end

class RuboCop::Cop::Layout::RescueEnsureAlignment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def investigate(processed_source); end

  def on_ensure(node); end

  def on_resbody(node); end
  ALTERNATIVE_ACCESS_MODIFIERS = ::T.let(nil, ::T.untyped)
  ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
  ANCESTOR_TYPES_WITH_ACCESS_MODIFIERS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RUBY_2_5_ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::RescueEnsureAlignment
end

class RuboCop::Cop::Layout::SpaceAfterColon
  def autocorrect(range); end

  def on_kwoptarg(node); end

  def on_pair(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterColon
end

class RuboCop::Cop::Layout::SpaceAfterComma
  include ::RuboCop::Cop::SpaceAfterPunctuation
  def autocorrect(comma); end

  def kind(token); end

  def space_style_before_rcurly(); end
end

class RuboCop::Cop::Layout::SpaceAfterComma
end

class RuboCop::Cop::Layout::SpaceAfterMethodName
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(pos_before_left_paren); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterMethodName
end

class RuboCop::Cop::Layout::SpaceAfterNot
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def whitespace_after_operator?(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterNot
end

class RuboCop::Cop::Layout::SpaceAfterSemicolon
  include ::RuboCop::Cop::SpaceAfterPunctuation
  def autocorrect(semicolon); end

  def kind(token); end

  def space_style_before_rcurly(); end
end

class RuboCop::Cop::Layout::SpaceAfterSemicolon
end

class RuboCop::Cop::Layout::SpaceAroundBlockParameters
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(target); end

  def on_block(node); end
end

class RuboCop::Cop::Layout::SpaceAroundBlockParameters
end

class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(range); end

  def on_optarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault
end

class RuboCop::Cop::Layout::SpaceAroundKeyword
  def autocorrect(range); end

  def on_and(node); end

  def on_block(node); end

  def on_break(node); end

  def on_case(node); end

  def on_defined?(node); end

  def on_ensure(node); end

  def on_for(node); end

  def on_if(node); end

  def on_kwbegin(node); end

  def on_next(node); end

  def on_or(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_return(node); end

  def on_send(node); end

  def on_super(node); end

  def on_until(node); end

  def on_when(node); end

  def on_while(node); end

  def on_yield(node); end

  def on_zsuper(node); end
  ACCEPT_LEFT_PAREN = ::T.let(nil, ::T.untyped)
  ACCEPT_LEFT_SQUARE_BRACKET = ::T.let(nil, ::T.untyped)
  ACCEPT_NAMESPACE_OPERATOR = ::T.let(nil, ::T.untyped)
  DO = ::T.let(nil, ::T.untyped)
  MSG_AFTER = ::T.let(nil, ::T.untyped)
  MSG_BEFORE = ::T.let(nil, ::T.untyped)
  NAMESPACE_OPERATOR = ::T.let(nil, ::T.untyped)
  SAFE_NAVIGATION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundKeyword
end

class RuboCop::Cop::Layout::SpaceAroundMethodCallOperator
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_const(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundMethodCallOperator
end

class RuboCop::Cop::Layout::SpaceAroundOperators
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RationalLiteral
  def autocorrect(range); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_assignment(node); end

  def on_binary(node); end

  def on_casgn(node); end

  def on_class(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_resbody(node); end

  def on_send(node); end

  def on_special_asgn(node); end
  EXCESSIVE_SPACE = ::T.let(nil, ::T.untyped)
  IRREGULAR_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundOperators
end

class RuboCop::Cop::Layout::SpaceBeforeBlockBraces
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_block(node); end
  DETECTED_MSG = ::T.let(nil, ::T.untyped)
  MISSING_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeBlockBraces
end

class RuboCop::Cop::Layout::SpaceBeforeComma
  include ::RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(space); end

  def kind(token); end
end

class RuboCop::Cop::Layout::SpaceBeforeComma
end

class RuboCop::Cop::Layout::SpaceBeforeComment
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeComment
end

class RuboCop::Cop::Layout::SpaceBeforeFirstArg
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeFirstArg
end

class RuboCop::Cop::Layout::SpaceBeforeSemicolon
  include ::RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(space); end

  def kind(token); end
end

class RuboCop::Cop::Layout::SpaceBeforeSemicolon
end

class RuboCop::Cop::Layout::SpaceInLambdaLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(lambda_node); end

  def on_send(node); end
  MSG_REQUIRE_NO_SPACE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE_SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInLambdaLiteral
end

class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_array(node); end
  EMPTY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets
end

class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MULTIPLE_SPACES_BETWEEN_ITEMS_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral
end

class RuboCop::Cop::Layout::SpaceInsideBlockBraces
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_block(node); end
end

class RuboCop::Cop::Layout::SpaceInsideBlockBraces
end

class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(range); end

  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces
end

class RuboCop::Cop::Layout::SpaceInsideParens
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideParens
end

class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_array(node); end

  def on_percent_literal(node); end

  def on_xstr(node); end
  BEGIN_REGEX = ::T.let(nil, ::T.untyped)
  END_REGEX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters
end

class RuboCop::Cop::Layout::SpaceInsideRangeLiteral
  def autocorrect(node); end

  def on_erange(node); end

  def on_irange(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideRangeLiteral
end

class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
  BRACKET_METHODS = ::T.let(nil, ::T.untyped)
  EMPTY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets
end

class RuboCop::Cop::Layout::SpaceInsideStringInterpolation
  include ::RuboCop::Cop::Interpolation
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(begin_node); end

  def on_interpolation(begin_node); end
  NO_SPACE_MSG = ::T.let(nil, ::T.untyped)
  SPACE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideStringInterpolation
end

class RuboCop::Cop::Layout::TrailingEmptyLines
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
end

class RuboCop::Cop::Layout::TrailingEmptyLines
end

class RuboCop::Cop::Layout::TrailingWhitespace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::TrailingWhitespace
end

module RuboCop::Cop::Layout
end

class RuboCop::Cop::LineBreakCorrector
end

class RuboCop::Cop::LineBreakCorrector
  extend ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::TrailingBody
  extend ::RuboCop::Cop::Util
  extend ::RuboCop::PathUtil
  def self.break_line_before(range:, node:, corrector:, configured_width:, indent_steps: T.unsafe(nil)); end

  def self.correct_trailing_body(configured_width:, corrector:, node:, processed_source:); end

  def self.move_comment(eol_comment:, node:, corrector:); end

  def self.processed_source(); end
end

module RuboCop::Cop::LineLengthHelp
end

module RuboCop::Cop::LineLengthHelp
end

module RuboCop::Cop::Lint
end

class RuboCop::Cop::Lint::AmbiguousBlockAssociation
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousBlockAssociation
end

class RuboCop::Cop::Lint::AmbiguousOperator
  include ::RuboCop::Cop::ParserDiagnostic
  AMBIGUITIES = ::T.let(nil, ::T.untyped)
  MSG_FORMAT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousOperator
end

class RuboCop::Cop::Lint::AmbiguousRegexpLiteral
  include ::RuboCop::Cop::ParserDiagnostic
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousRegexpLiteral
end

class RuboCop::Cop::Lint::AssignmentInCondition
  include ::RuboCop::Cop::SafeAssignment
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
  ASGN_TYPES = ::T.let(nil, ::T.untyped)
  MSG_WITHOUT_SAFE_ASSIGNMENT_ALLOWED = ::T.let(nil, ::T.untyped)
  MSG_WITH_SAFE_ASSIGNMENT_ALLOWED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AssignmentInCondition
end

class RuboCop::Cop::Lint::BigDecimalNew
  def autocorrect(node); end

  def big_decimal_new(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BigDecimalNew
end

class RuboCop::Cop::Lint::BooleanSymbol
  def autocorrect(node); end

  def boolean_symbol?(node=T.unsafe(nil)); end

  def on_sym(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BooleanSymbol
end

class RuboCop::Cop::Lint::CircularArgumentReference
  def on_kwoptarg(node); end

  def on_optarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::CircularArgumentReference
end

class RuboCop::Cop::Lint::Debugger
  def binding_irb_call?(node=T.unsafe(nil)); end

  def debugger_call?(node=T.unsafe(nil)); end

  def kernel?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Debugger
end

class RuboCop::Cop::Lint::DeprecatedClassMethods
  def autocorrect(node); end

  def on_send(node); end
  DEPRECATED_METHODS_OBJECT = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedClassMethods::DeprecatedClassMethod
  include ::RuboCop::AST::Sexp
  def class_constant(); end

  def class_nodes(); end

  def deprecated_method(); end

  def initialize(deprecated:, replacement:, class_constant: T.unsafe(nil)); end

  def replacement_method(); end
end

class RuboCop::Cop::Lint::DeprecatedClassMethods::DeprecatedClassMethod
end

class RuboCop::Cop::Lint::DeprecatedClassMethods
end

class RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor
  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor
end

class RuboCop::Cop::Lint::DuplicateCaseCondition
  def on_case(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateCaseCondition
end

class RuboCop::Cop::Lint::DuplicateHashKey
  include ::RuboCop::Cop::Duplication
  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateHashKey
end

class RuboCop::Cop::Lint::DuplicateMethods
  def alias_method?(node=T.unsafe(nil)); end

  def attr?(node=T.unsafe(nil)); end

  def method_alias?(node=T.unsafe(nil)); end

  def on_alias(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def sym_name(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateMethods
end

class RuboCop::Cop::Lint::EachWithObjectArgument
  def each_with_object?(node=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EachWithObjectArgument
end

class RuboCop::Cop::Lint::ElseLayout
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ElseLayout
end

class RuboCop::Cop::Lint::EmptyEnsure
  def autocorrect(node); end

  def on_ensure(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyEnsure
end

class RuboCop::Cop::Lint::EmptyExpression
  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyExpression
end

class RuboCop::Cop::Lint::EmptyInterpolation
  include ::RuboCop::Cop::Interpolation
  def autocorrect(node); end

  def on_interpolation(begin_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyInterpolation
end

class RuboCop::Cop::Lint::EmptyWhen
  def on_case(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyWhen
end

class RuboCop::Cop::Lint::EnsureReturn
  def on_ensure(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EnsureReturn
end

class RuboCop::Cop::Lint::ErbNewArguments
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def erb_new_with_non_keyword_arguments(node=T.unsafe(nil)); end

  def on_send(node); end
  MESSAGES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ErbNewArguments
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Lint::FlipFlop
  def on_eflipflop(node); end

  def on_iflipflop(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FlipFlop
end

class RuboCop::Cop::Lint::FloatOutOfRange
  def on_float(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FloatOutOfRange
end

class RuboCop::Cop::Lint::FormatParameterMismatch
  def called_on_string?(node=T.unsafe(nil)); end

  def on_send(node); end
  KERNEL = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SHOVEL = ::T.let(nil, ::T.untyped)
  STRING_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FormatParameterMismatch
end

class RuboCop::Cop::Lint::HeredocMethodCallPosition
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::HeredocMethodCallPosition
end

class RuboCop::Cop::Lint::ImplicitStringConcatenation
  def on_dstr(node); end
  FOR_ARRAY = ::T.let(nil, ::T.untyped)
  FOR_METHOD = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ImplicitStringConcatenation
end

class RuboCop::Cop::Lint::IneffectiveAccessModifier
  def on_class(node); end

  def on_module(node); end

  def private_class_methods(node0); end
  ALTERNATIVE_PRIVATE = ::T.let(nil, ::T.untyped)
  ALTERNATIVE_PROTECTED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::IneffectiveAccessModifier
end

class RuboCop::Cop::Lint::InheritException
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def class_new_call?(node=T.unsafe(nil)); end

  def on_class(node); end

  def on_send(node); end
  ILLEGAL_CLASSES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PREFERRED_BASE_CLASS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InheritException
end

class RuboCop::Cop::Lint::InterpolationCheck
  def heredoc?(node); end

  def on_str(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InterpolationCheck
end

class RuboCop::Cop::Lint::LiteralAsCondition
  def message(node); end

  def on_case(case_node); end

  def on_if(node); end

  def on_send(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralAsCondition
end

class RuboCop::Cop::Lint::LiteralInInterpolation
  include ::RuboCop::Cop::Interpolation
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_interpolation(begin_node); end
  COMPOSITE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralInInterpolation
end

class RuboCop::Cop::Lint::Loop
  def on_until_post(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Loop
end

class RuboCop::Cop::Lint::MissingCopEnableDirective
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_BOUND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MissingCopEnableDirective
end

class RuboCop::Cop::Lint::MultipleComparison
  def autocorrect(node); end

  def multiple_compare?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MultipleComparison
end

class RuboCop::Cop::Lint::NestedMethodDefinition
  def class_or_module_or_struct_new_call?(node=T.unsafe(nil)); end

  def eval_call?(node=T.unsafe(nil)); end

  def exec_call?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NestedMethodDefinition
end

class RuboCop::Cop::Lint::NestedPercentLiteral
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
  REGEXES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NestedPercentLiteral
end

class RuboCop::Cop::Lint::NextWithoutAccumulator
  def on_block(node); end

  def on_body_of_reduce(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NextWithoutAccumulator
end

class RuboCop::Cop::Lint::NonDeterministicRequireOrder
  def autocorrect(node); end

  def loop_variable(node=T.unsafe(nil)); end

  def on_block(node); end

  def unsorted_dir_block?(node=T.unsafe(nil)); end

  def unsorted_dir_each?(node=T.unsafe(nil)); end

  def var_is_required?(node0, param1); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonDeterministicRequireOrder
end

class RuboCop::Cop::Lint::NonLocalExitFromIterator
  def chained_send?(node=T.unsafe(nil)); end

  def define_method?(node=T.unsafe(nil)); end

  def on_return(return_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonLocalExitFromIterator
end

class RuboCop::Cop::Lint::NumberConversion
  def autocorrect(node); end

  def datetime?(node=T.unsafe(nil)); end

  def on_send(node); end

  def to_method(node=T.unsafe(nil)); end
  CONVERSION_METHOD_CLASS_MAPPING = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NumberConversion
end

class RuboCop::Cop::Lint::OrderedMagicComments
  include ::RuboCop::Cop::FrozenStringLiteral
  def autocorrect(_node); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::OrderedMagicComments
end

class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression
end

class RuboCop::Cop::Lint::PercentStringArray
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_array(node); end

  def on_percent_literal(node); end
  LEADING_QUOTE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  QUOTES_AND_COMMAS = ::T.let(nil, ::T.untyped)
  TRAILING_QUOTE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::PercentStringArray
end

class RuboCop::Cop::Lint::PercentSymbolArray
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::PercentSymbolArray
end

class RuboCop::Cop::Lint::RaiseException
  def exception?(node=T.unsafe(nil)); end

  def exception_new_with_message?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RaiseException
end

class RuboCop::Cop::Lint::RandOne
  def on_send(node); end

  def rand_one?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RandOne
end

class RuboCop::Cop::Lint::RedundantCopDisableDirective
  include ::RuboCop::NameSimilarity
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(args); end

  def check(offenses, cop_disabled_line_ranges, comments); end
  COP_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantCopDisableDirective
end

class RuboCop::Cop::Lint::RedundantCopEnableDirective
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(comment_and_name); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantCopEnableDirective
end

class RuboCop::Cop::Lint::RedundantRequireStatement
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def unnecessary_require_statement?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantRequireStatement
end

class RuboCop::Cop::Lint::RedundantSplatExpansion
  def array_new?(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def literal_expansion(node=T.unsafe(nil)); end

  def on_splat(node); end
  ARRAY_PARAM_MSG = ::T.let(nil, ::T.untyped)
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_I = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_W = ::T.let(nil, ::T.untyped)
  PERCENT_I = ::T.let(nil, ::T.untyped)
  PERCENT_W = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantSplatExpansion
end

class RuboCop::Cop::Lint::RedundantStringCoercion
  include ::RuboCop::Cop::Interpolation
  def autocorrect(node); end

  def on_interpolation(begin_node); end

  def to_s_without_args?(node=T.unsafe(nil)); end
  MSG_DEFAULT = ::T.let(nil, ::T.untyped)
  MSG_SELF = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantStringCoercion
end

class RuboCop::Cop::Lint::RedundantWithIndex
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def redundant_with_index?(node=T.unsafe(nil)); end
  MSG_EACH_WITH_INDEX = ::T.let(nil, ::T.untyped)
  MSG_WITH_INDEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantWithIndex
end

class RuboCop::Cop::Lint::RedundantWithObject
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def redundant_with_object?(node=T.unsafe(nil)); end
  MSG_EACH_WITH_OBJECT = ::T.let(nil, ::T.untyped)
  MSG_WITH_OBJECT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantWithObject
end

class RuboCop::Cop::Lint::RegexpAsCondition
  def on_match_current_line(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RegexpAsCondition
end

class RuboCop::Cop::Lint::RequireParentheses
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RequireParentheses
end

class RuboCop::Cop::Lint::RescueException
  def on_resbody(node); end

  def targets_exception?(rescue_arg_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RescueException
end

class RuboCop::Cop::Lint::RescueType
  include ::RuboCop::Cop::RescueNode
  def autocorrect(node); end

  def on_resbody(node); end
  INVALID_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RescueType
end

class RuboCop::Cop::Lint::ReturnInVoidContext
  def on_return(return_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ReturnInVoidContext
end

class RuboCop::Cop::Lint::SafeNavigationChain
  include ::RuboCop::Cop::NilMethods
  def bad_method?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationChain
end

class RuboCop::Cop::Lint::SafeNavigationConsistency
  include ::RuboCop::Cop::NilMethods
  def autocorrect(node); end

  def check(node); end

  def on_csend(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationConsistency
end

class RuboCop::Cop::Lint::SafeNavigationWithEmpty
  def on_if(node); end

  def safe_navigation_empty_in_conditional?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationWithEmpty
end

class RuboCop::Cop::Lint::ScriptPermission
  def autocorrect(node); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ScriptPermission
end

class RuboCop::Cop::Lint::SendWithMixinArgument
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def send_with_mixin_argument?(node=T.unsafe(nil)); end
  MIXIN_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SendWithMixinArgument
end

class RuboCop::Cop::Lint::ShadowedArgument
  def after_leaving_scope(scope, _variable_table); end

  def join_force?(force_class); end

  def uses_var?(node0, param1); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowedArgument
end

class RuboCop::Cop::Lint::ShadowedException
  include ::RuboCop::Cop::RescueNode
  include ::RuboCop::Cop::RangeHelp
  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowedException
end

class RuboCop::Cop::Lint::ShadowingOuterLocalVariable
  def before_declaring_variable(variable, variable_table); end

  def join_force?(force_class); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowingOuterLocalVariable
end

class RuboCop::Cop::Lint::StructNewOverride
  def on_send(node); end

  def struct_new(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  STRUCT_MEMBER_NAME_TYPES = ::T.let(nil, ::T.untyped)
  STRUCT_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::StructNewOverride
end

class RuboCop::Cop::Lint::SuppressedException
  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SuppressedException
end

class RuboCop::Cop::Lint::Syntax
  def add_offense_from_diagnostic(diagnostic, ruby_version); end

  def add_offense_from_error(error); end
  ERROR_SOURCE_RANGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Syntax::PseudoSourceRange
  def begin_pos(); end

  def begin_pos=(_); end

  def column(); end

  def column=(_); end

  def end_pos(); end

  def end_pos=(_); end

  def line(); end

  def line=(_); end

  def source_line(); end

  def source_line=(_); end
end

class RuboCop::Cop::Lint::Syntax::PseudoSourceRange
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::Lint::Syntax
  def self.offenses_from_processed_source(processed_source, config, options); end
end

class RuboCop::Cop::Lint::ToJSON
  def autocorrect(node); end

  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ToJSON
end

class RuboCop::Cop::Lint::UnderscorePrefixedVariableName
  def after_leaving_scope(scope, _variable_table); end

  def check_variable(variable); end

  def join_force?(force_class); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnderscorePrefixedVariableName
end

class RuboCop::Cop::Lint::UnifiedInteger
  def autocorrect(node); end

  def fixnum_or_bignum_const(node=T.unsafe(nil)); end

  def on_const(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnifiedInteger
end

class RuboCop::Cop::Lint::UnreachableCode
  def flow_command?(node=T.unsafe(nil)); end

  def on_begin(node); end

  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnreachableCode
end

module RuboCop::Cop::Lint::UnusedArgument
  def after_leaving_scope(scope, _variable_table); end

  def join_force?(force_class); end
end

module RuboCop::Cop::Lint::UnusedArgument
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::Lint::UnusedBlockArgument
  include ::RuboCop::Cop::Lint::UnusedArgument
  def autocorrect(node); end
end

class RuboCop::Cop::Lint::UnusedBlockArgument
end

class RuboCop::Cop::Lint::UnusedMethodArgument
  include ::RuboCop::Cop::Lint::UnusedArgument
  def autocorrect(node); end

  def not_implemented?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::UnusedMethodArgument
end

class RuboCop::Cop::Lint::UriEscapeUnescape
  def on_send(node); end

  def uri_escape_unescape?(node=T.unsafe(nil)); end
  ALTERNATE_METHODS_OF_URI_ESCAPE = ::T.let(nil, ::T.untyped)
  ALTERNATE_METHODS_OF_URI_UNESCAPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriEscapeUnescape
end

class RuboCop::Cop::Lint::UriRegexp
  def autocorrect(node); end

  def on_send(node); end

  def uri_regexp_with_argument?(node=T.unsafe(nil)); end

  def uri_regexp_without_argument?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriRegexp
end

class RuboCop::Cop::Lint::UselessAccessModifier
  def class_or_instance_eval?(node=T.unsafe(nil)); end

  def class_or_module_or_struct_new_call?(node=T.unsafe(nil)); end

  def dynamic_method_definition?(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end

  def static_method_definition?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAccessModifier
end

class RuboCop::Cop::Lint::UselessAssignment
  include ::RuboCop::NameSimilarity
  def after_leaving_scope(scope, _variable_table); end

  def check_for_unused_assignments(variable); end

  def collect_variable_like_names(scope); end

  def join_force?(force_class); end

  def message_for_useless_assignment(assignment); end

  def message_specification(assignment, variable); end

  def multiple_assignment_message(variable_name); end

  def operator_assignment_message(scope, assignment); end

  def return_value_node_of_scope(scope); end

  def similar_name_message(variable); end

  def variable_like_method_invocation?(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAssignment
end

class RuboCop::Cop::Lint::UselessComparison
  def on_send(node); end

  def useless_comparison?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  OPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessComparison
end

class RuboCop::Cop::Lint::UselessElseWithoutRescue
  include ::RuboCop::Cop::ParserDiagnostic
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessElseWithoutRescue
end

class RuboCop::Cop::Lint::UselessSetterCall
  def on_def(node); end

  def on_defs(node); end

  def setter_call_to_local_variable?(node=T.unsafe(nil)); end
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessSetterCall::MethodVariableTracker
  def constructor?(node); end

  def contain_local_object?(variable_name); end

  def initialize(body_node); end

  def process_assignment(asgn_node, rhs_node); end

  def process_assignment_node(node); end

  def process_binary_operator_assignment(op_asgn_node); end

  def process_logical_operator_assignment(asgn_node); end

  def process_multiple_assignment(masgn_node); end

  def scan(node, &block); end
end

class RuboCop::Cop::Lint::UselessSetterCall::MethodVariableTracker
end

class RuboCop::Cop::Lint::UselessSetterCall
end

class RuboCop::Cop::Lint::Void
  def on_begin(node); end

  def on_block(node); end

  def on_kwbegin(node); end
  BINARY_OPERATORS = ::T.let(nil, ::T.untyped)
  DEFINED_MSG = ::T.let(nil, ::T.untyped)
  LIT_MSG = ::T.let(nil, ::T.untyped)
  NONMUTATING_METHODS = ::T.let(nil, ::T.untyped)
  NONMUTATING_MSG = ::T.let(nil, ::T.untyped)
  OPERATORS = ::T.let(nil, ::T.untyped)
  OP_MSG = ::T.let(nil, ::T.untyped)
  SELF_MSG = ::T.let(nil, ::T.untyped)
  UNARY_OPERATORS = ::T.let(nil, ::T.untyped)
  VAR_MSG = ::T.let(nil, ::T.untyped)
  VOID_CONTEXT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Void
end

module RuboCop::Cop::Lint
end

module RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::MatchRange
end

class RuboCop::Cop::MessageAnnotator
  def annotate(message); end

  def config(); end

  def cop_config(); end

  def cop_name(); end

  def initialize(config, cop_name, cop_config, options); end

  def options(); end

  def urls(); end
end

class RuboCop::Cop::MessageAnnotator
  def self.style_guide_urls(); end
end

module RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredMethods
  def define_method?(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end
end

module RuboCop::Cop::MethodComplexity
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::MethodPreference
end

module RuboCop::Cop::MethodPreference
end

module RuboCop::Cop::Metrics
end

class RuboCop::Cop::Metrics::AbcSize
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredMethods
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::AbcSize
end

class RuboCop::Cop::Metrics::BlockLength
  include ::RuboCop::Cop::TooManyLines
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def on_block(node); end
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::BlockLength
end

class RuboCop::Cop::Metrics::BlockNesting
  include ::RuboCop::Cop::ConfigurableMax
  def investigate(processed_source); end
  NESTING_BLOCKS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::BlockNesting
end

class RuboCop::Cop::Metrics::ClassLength
  include ::RuboCop::Cop::ClassishLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def class_definition?(node=T.unsafe(nil)); end

  def on_casgn(node); end

  def on_class(node); end
end

class RuboCop::Cop::Metrics::ClassLength
end

class RuboCop::Cop::Metrics::CyclomaticComplexity
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredMethods
  COUNTED_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::CyclomaticComplexity
end

class RuboCop::Cop::Metrics::MethodLength
  include ::RuboCop::Cop::TooManyLines
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::MethodLength
end

class RuboCop::Cop::Metrics::ModuleLength
  include ::RuboCop::Cop::ClassishLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def module_definition?(node=T.unsafe(nil)); end

  def on_casgn(node); end

  def on_module(node); end
end

class RuboCop::Cop::Metrics::ModuleLength
end

class RuboCop::Cop::Metrics::ParameterLists
  include ::RuboCop::Cop::ConfigurableMax
  def argument_to_lambda_or_proc?(node=T.unsafe(nil)); end

  def on_args(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::ParameterLists
end

class RuboCop::Cop::Metrics::PerceivedComplexity
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredMethods
  COUNTED_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::PerceivedComplexity
end

module RuboCop::Cop::Metrics::Utils
end

class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  def calculate(); end

  def else_branch?(node); end

  def evaluate_branch_nodes(node); end

  def evaluate_condition_node(node); end

  def initialize(node); end
  BRANCH_NODES = ::T.let(nil, ::T.untyped)
  CONDITION_NODES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  def self.calculate(node); end
end

module RuboCop::Cop::Metrics::Utils
end

module RuboCop::Cop::Metrics
end

module RuboCop::Cop::Migration
end

class RuboCop::Cop::Migration::DepartmentName
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  DISABLE_COMMENT_FORMAT = ::T.let(nil, ::T.untyped)
  DISABLING_COPS_CONTENT_TOKEN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Migration::DepartmentName
end

module RuboCop::Cop::Migration
end

module RuboCop::Cop::MinBodyLength
end

module RuboCop::Cop::MinBodyLength
end

module RuboCop::Cop::MultilineElementIndentation
end

module RuboCop::Cop::MultilineElementIndentation
end

module RuboCop::Cop::MultilineElementLineBreaks
end

module RuboCop::Cop::MultilineElementLineBreaks
end

module RuboCop::Cop::MultilineExpressionIndentation
  def on_send(node); end
  ASSIGNMENT_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  DEFAULT_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  KEYWORD_ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
  KEYWORD_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  UNALIGNED_RHS_TYPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::MultilineExpressionIndentation
end

class RuboCop::Cop::MultilineLiteralBraceCorrector
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def call(corrector); end

  def initialize(node, processed_source); end
end

class RuboCop::Cop::MultilineLiteralBraceCorrector
end

module RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
end

module RuboCop::Cop::MultilineLiteralBraceLayout
end

module RuboCop::Cop::Naming
end

class RuboCop::Cop::Naming::AccessorMethodName
  def on_def(node); end

  def on_defs(node); end
  MSG_READER = ::T.let(nil, ::T.untyped)
  MSG_WRITER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::AccessorMethodName
end

class RuboCop::Cop::Naming::AsciiIdentifiers
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::AsciiIdentifiers
end

class RuboCop::Cop::Naming::BinaryOperatorParameterName
  def on_def(node); end

  def op_method_candidate?(node=T.unsafe(nil)); end
  BLACKLISTED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  OP_LIKE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::BinaryOperatorParameterName
end

class RuboCop::Cop::Naming::BlockParameterName
  include ::RuboCop::Cop::UncommunicativeName
  def on_block(node); end
end

class RuboCop::Cop::Naming::BlockParameterName
end

class RuboCop::Cop::Naming::ClassAndModuleCamelCase
  def on_class(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::ClassAndModuleCamelCase
end

class RuboCop::Cop::Naming::ConstantName
  def class_or_struct_return_method?(node=T.unsafe(nil)); end

  def literal_receiver?(node=T.unsafe(nil)); end

  def on_casgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::ConstantName
end

class RuboCop::Cop::Naming::FileName
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end
  MSG_NO_DEFINITION = ::T.let(nil, ::T.untyped)
  MSG_REGEX = ::T.let(nil, ::T.untyped)
  MSG_SNAKE_CASE = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::FileName
end

class RuboCop::Cop::Naming::HeredocDelimiterCase
  include ::RuboCop::Cop::Heredoc
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::HeredocDelimiterCase
end

class RuboCop::Cop::Naming::HeredocDelimiterNaming
  include ::RuboCop::Cop::Heredoc
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::HeredocDelimiterNaming
end

class RuboCop::Cop::Naming::MemoizedInstanceVariableName
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def memoized?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE_REQUIRED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::MemoizedInstanceVariableName
end

class RuboCop::Cop::Naming::MethodName
  include ::RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredPattern
  include ::RuboCop::Cop::RangeHelp
  def attr?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def str_name(node=T.unsafe(nil)); end

  def sym_name(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::MethodName
end

class RuboCop::Cop::Naming::MethodParameterName
  include ::RuboCop::Cop::UncommunicativeName
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Naming::MethodParameterName
end

class RuboCop::Cop::Naming::PredicateName
  def dynamic_method_define(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
end

class RuboCop::Cop::Naming::PredicateName
end

class RuboCop::Cop::Naming::RescuedExceptionsVariableName
  def autocorrect(node); end

  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::RescuedExceptionsVariableName
end

class RuboCop::Cop::Naming::VariableName
  include ::RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_arg(node); end

  def on_blockarg(node); end

  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_optarg(node); end

  def on_restarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::VariableName
end

class RuboCop::Cop::Naming::VariableNumber
  include ::RuboCop::Cop::ConfigurableNumbering
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_arg(node); end

  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::VariableNumber
end

module RuboCop::Cop::Naming
end

module RuboCop::Cop::NegativeConditional
  def empty_condition?(node=T.unsafe(nil)); end

  def single_negative?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::NegativeConditional
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::NilMethods
end

module RuboCop::Cop::NilMethods
end

class RuboCop::Cop::Offense
  include ::Comparable
  def ==(other); end

  def column(); end

  def column_length(); end

  def column_range(); end

  def cop_name(); end

  def correctable?(); end

  def corrected?(); end

  def corrected_with_todo?(); end

  def disabled?(); end

  def eql?(other); end

  def first_line(); end

  def highlighted_area(); end

  def initialize(severity, location, message, cop_name, status=T.unsafe(nil)); end

  def last_column(); end

  def last_line(); end

  def line(); end

  def location(); end

  def message(); end

  def real_column(); end

  def severity(); end

  def source_line(); end

  def status(); end
  COMPARISON_ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Offense
end

module RuboCop::Cop::OnNormalIfUnless
  def on_if(node); end
end

module RuboCop::Cop::OnNormalIfUnless
end

class RuboCop::Cop::OrderedGemCorrector
end

class RuboCop::Cop::OrderedGemCorrector
  extend ::RuboCop::Cop::OrderedGemNode
  def self.comments_as_separators(); end

  def self.correct(processed_source, node, previous_declaration, comments_as_separators); end

  def self.processed_source(); end
end

module RuboCop::Cop::OrderedGemNode
end

module RuboCop::Cop::OrderedGemNode
end

module RuboCop::Cop::Parentheses
end

module RuboCop::Cop::Parentheses
end

class RuboCop::Cop::ParenthesesCorrector
end

class RuboCop::Cop::ParenthesesCorrector
  def self.correct(node); end
end

module RuboCop::Cop::ParserDiagnostic
  def investigate(processed_source); end
end

module RuboCop::Cop::ParserDiagnostic
end

module RuboCop::Cop::PercentArray
end

module RuboCop::Cop::PercentArray
end

module RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::PercentLiteral
end

class RuboCop::Cop::PercentLiteralCorrector
  include ::RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  def config(); end

  def correct(node, char); end

  def initialize(config, preferred_delimiters); end

  def preferred_delimiters(); end
end

class RuboCop::Cop::PercentLiteralCorrector
end

module RuboCop::Cop::PrecedingFollowingAlignment
end

module RuboCop::Cop::PrecedingFollowingAlignment
end

class RuboCop::Cop::PreferredDelimiters
  def config(); end

  def delimiters(); end

  def initialize(type, config, preferred_delimiters); end

  def type(); end
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::PreferredDelimiters
end

class RuboCop::Cop::PunctuationCorrector
end

class RuboCop::Cop::PunctuationCorrector
  def self.add_space(token); end

  def self.remove_space(space_before); end

  def self.swap_comma(range); end
end

module RuboCop::Cop::RangeHelp
  BYTE_ORDER_MARK = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::RationalLiteral
  def rational_literal?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::RationalLiteral
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::Registry
  def ==(other); end

  def contains_cop_matching?(names); end

  def cops(); end

  def department_missing?(badge, name); end

  def departments(); end

  def each(&block); end

  def enabled(config, only, only_safe=T.unsafe(nil)); end

  def enabled?(cop, config, only_safe); end

  def enabled_pending_cop?(cop_cfg, config); end

  def enlist(cop); end

  def find_by_cop_name(cop_name); end

  def initialize(cops=T.unsafe(nil), options=T.unsafe(nil)); end

  def length(); end

  def names(); end

  def print_warning(name, path); end

  def qualified_cop_name(name, path, shall_warn=T.unsafe(nil)); end

  def select(&block); end

  def sort!(); end

  def to_h(); end

  def unqualified_cop_names(); end

  def with_department(department); end

  def without_department(department); end
end

class RuboCop::Cop::Registry
end

module RuboCop::Cop::RescueNode
  def investigate(processed_source); end
end

module RuboCop::Cop::RescueNode
end

module RuboCop::Cop::SafeAssignment
  def empty_condition?(node=T.unsafe(nil)); end

  def safe_assignment?(node=T.unsafe(nil)); end

  def setter_method?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::SafeAssignment
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::Security
end

class RuboCop::Cop::Security::Eval
  def eval?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::Eval
end

class RuboCop::Cop::Security::JSONLoad
  def autocorrect(node); end

  def json_load(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::JSONLoad
end

class RuboCop::Cop::Security::MarshalLoad
  def marshal_load(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::MarshalLoad
end

class RuboCop::Cop::Security::Open
  def on_send(node); end

  def open?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::Open
end

class RuboCop::Cop::Security::YAMLLoad
  def autocorrect(node); end

  def on_send(node); end

  def yaml_load(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::YAMLLoad
end

module RuboCop::Cop::Security
end

class RuboCop::Cop::Severity
  include ::Comparable
  def ==(other); end

  def code(); end

  def initialize(name_or_code); end

  def level(); end

  def name(); end
  CODE_TABLE = ::T.let(nil, ::T.untyped)
  NAMES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Severity
  def self.name_from_code(code); end
end

module RuboCop::Cop::SpaceAfterPunctuation
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SpaceAfterPunctuation
end

module RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SpaceBeforePunctuation
end

class RuboCop::Cop::SpaceCorrector
end

class RuboCop::Cop::SpaceCorrector
  extend ::RuboCop::Cop::SurroundingSpace
  extend ::RuboCop::Cop::RangeHelp
  def self.add_space(processed_source, corrector, left_token, right_token); end

  def self.empty_corrections(processed_source, corrector, empty_config, left_token, right_token); end

  def self.processed_source(); end

  def self.remove_space(processed_source, corrector, left_token, right_token); end
end

module RuboCop::Cop::StatementModifier
end

module RuboCop::Cop::StatementModifier
end

module RuboCop::Cop::StringHelp
  def on_regexp(node); end

  def on_str(node); end
end

module RuboCop::Cop::StringHelp
end

class RuboCop::Cop::StringLiteralCorrector
end

class RuboCop::Cop::StringLiteralCorrector
  extend ::RuboCop::Cop::Util
  extend ::RuboCop::PathUtil
  def self.correct(node, style); end
end

module RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
end

module RuboCop::Cop::StringLiteralsHelp
end

module RuboCop::Cop::Style
end

class RuboCop::Cop::Style::AccessModifierDeclarations
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def access_modifier_with_symbol?(node=T.unsafe(nil)); end

  def on_send(node); end
  GROUP_STYLE_MESSAGE = ::T.let(nil, ::T.untyped)
  INLINE_STYLE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AccessModifierDeclarations
end

class RuboCop::Cop::Style::Alias
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def identifier(node=T.unsafe(nil)); end

  def on_alias(node); end

  def on_send(node); end
  MSG_ALIAS = ::T.let(nil, ::T.untyped)
  MSG_ALIAS_METHOD = ::T.let(nil, ::T.untyped)
  MSG_SYMBOL_ARGS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Alias
end

class RuboCop::Cop::Style::AndOr
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_and(node); end

  def on_if(node); end

  def on_or(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AndOr
end

module RuboCop::Cop::Style::AnnotationComment
end

module RuboCop::Cop::Style::AnnotationComment
end

class RuboCop::Cop::Style::ArrayJoin
  def autocorrect(node); end

  def join_candidate?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayJoin
end

class RuboCop::Cop::Style::AsciiComments
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AsciiComments
end

class RuboCop::Cop::Style::Attr
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def class_eval?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Attr
end

class RuboCop::Cop::Style::AutoResourceCleanup
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  TARGET_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AutoResourceCleanup
end

class RuboCop::Cop::Style::BarePercentLiterals
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_dstr(node); end

  def on_str(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BarePercentLiterals
end

class RuboCop::Cop::Style::BeginBlock
  def on_preexe(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BeginBlock
end

class RuboCop::Cop::Style::BlockComments
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(comment); end

  def investigate(processed_source); end
  BEGIN_LENGTH = ::T.let(nil, ::T.untyped)
  END_LENGTH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BlockComments
end

class RuboCop::Cop::Style::BlockDelimiters
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods
  def autocorrect(node); end

  def on_block(node); end

  def on_send(node); end
  ALWAYS_BRACES_MESSAGE = ::T.let(nil, ::T.untyped)
  BRACES_REQUIRED_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BlockDelimiters
end

class RuboCop::Cop::Style::CaseCorrector
end

class RuboCop::Cop::Style::CaseCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(cop, node); end

  def self.move_assignment_inside_condition(node); end
end

class RuboCop::Cop::Style::CaseEquality
  def case_equality?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CaseEquality
end

class RuboCop::Cop::Style::CharacterLiteral
  include ::RuboCop::Cop::StringHelp
  def autocorrect(node); end

  def correct_style_detected(); end

  def offense?(node); end

  def opposite_style_detected(); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CharacterLiteral
end

class RuboCop::Cop::Style::ClassAndModuleChildren
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_class(node); end

  def on_module(node); end
  COMPACT_MSG = ::T.let(nil, ::T.untyped)
  NESTED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassAndModuleChildren
end

class RuboCop::Cop::Style::ClassCheck
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def class_check?(node=T.unsafe(nil)); end

  def message(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassCheck
end

class RuboCop::Cop::Style::ClassMethods
  def autocorrect(node); end

  def on_class(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassMethods
end

class RuboCop::Cop::Style::ClassVars
  def message(node); end

  def on_cvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassVars
end

class RuboCop::Cop::Style::CollectionMethods
  include ::RuboCop::Cop::MethodPreference
  def autocorrect(node); end

  def on_block(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CollectionMethods
end

class RuboCop::Cop::Style::ColonMethodCall
  def autocorrect(node); end

  def java_type_node?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ColonMethodCall
end

class RuboCop::Cop::Style::ColonMethodDefinition
  def autocorrect(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ColonMethodDefinition
end

class RuboCop::Cop::Style::CommandLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_xstr(node); end
  MSG_USE_BACKTICKS = ::T.let(nil, ::T.untyped)
  MSG_USE_PERCENT_X = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommandLiteral
end

class RuboCop::Cop::Style::CommentAnnotation
  include ::RuboCop::Cop::Style::AnnotationComment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(comment); end

  def investigate(processed_source); end
  MISSING_NOTE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommentAnnotation
end

class RuboCop::Cop::Style::CommentedKeyword
  def investigate(processed_source); end
  ALLOWED_COMMENTS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommentedKeyword
end

class RuboCop::Cop::Style::ConditionalAssignment
  include ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def assignment_type?(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def candidate_condition?(node=T.unsafe(nil)); end

  def on_and_asgn(node); end

  def on_case(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  ASSIGN_TO_CONDITION_MSG = ::T.let(nil, ::T.untyped)
  ENABLED = ::T.let(nil, ::T.untyped)
  INDENTATION_WIDTH = ::T.let(nil, ::T.untyped)
  LINE_LENGTH = ::T.let(nil, ::T.untyped)
  MAX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SINGLE_LINE_CONDITIONS_ONLY = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  WIDTH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConditionalAssignment
end

module RuboCop::Cop::Style::ConditionalAssignmentHelper
  def end_with_eq?(sym); end

  def expand_elses(branch); end

  def expand_when_branches(when_branches); end

  def indent(cop, source); end

  def lhs(node); end

  def tail(branch); end
  ALIGN_WITH = ::T.let(nil, ::T.untyped)
  END_ALIGNMENT = ::T.let(nil, ::T.untyped)
  EQUAL = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::NodePattern::Macros
end

module RuboCop::Cop::Style::ConditionalCorrectorHelper
  def assignment(node); end

  def correct_branches(corrector, branches); end

  def correct_if_branches(corrector, cop, node); end

  def remove_whitespace_in_branches(corrector, branch, condition, column); end

  def replace_branch_assignment(corrector, branch); end

  def white_space_range(node, column); end
end

module RuboCop::Cop::Style::ConditionalCorrectorHelper
end

class RuboCop::Cop::Style::ConstantVisibility
  def on_casgn(node); end

  def visibility_declaration_for?(node=T.unsafe(nil), param1); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConstantVisibility
end

class RuboCop::Cop::Style::Copyright
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(token); end

  def investigate(processed_source); end
  AUTOCORRECT_EMPTY_WARNING = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Copyright
end

class RuboCop::Cop::Style::DateTime
  def date_time?(node=T.unsafe(nil)); end

  def historic_date?(node=T.unsafe(nil)); end

  def on_send(node); end

  def to_datetime?(node=T.unsafe(nil)); end
  CLASS_MSG = ::T.let(nil, ::T.untyped)
  COERCION_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DateTime
end

class RuboCop::Cop::Style::DefWithParentheses
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DefWithParentheses
end

class RuboCop::Cop::Style::Dir
  def autocorrect(node); end

  def dir_replacement?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Dir
end

class RuboCop::Cop::Style::DisableCopsWithinSourceCodeDirective
  def autocorrect(comment); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DisableCopsWithinSourceCodeDirective
end

class RuboCop::Cop::Style::Documentation
  include ::RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::Style::AnnotationComment
  def constant_definition?(node=T.unsafe(nil)); end

  def constant_visibility_declaration?(node=T.unsafe(nil)); end

  def on_class(node); end

  def on_module(node); end

  def outer_module(node0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Documentation
end

class RuboCop::Cop::Style::DocumentationMethod
  include ::RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::Style::AnnotationComment
  include ::RuboCop::Cop::DefNode
  def module_function_node?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DocumentationMethod
end

class RuboCop::Cop::Style::DoubleCopDisableDirective
  def autocorrect(comment); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DoubleCopDisableDirective
end

class RuboCop::Cop::Style::DoubleNegation
  def double_negative?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DoubleNegation
end

class RuboCop::Cop::Style::EachForSimpleLoop
  def autocorrect(node); end

  def offending_each_range(node=T.unsafe(nil)); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachForSimpleLoop
end

class RuboCop::Cop::Style::EachWithObject
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def each_with_object_candidate?(node=T.unsafe(nil)); end

  def on_block(node); end
  METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachWithObject
end

class RuboCop::Cop::Style::EmptyBlockParameter
  include ::RuboCop::Cop::EmptyParameter
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyBlockParameter
end

class RuboCop::Cop::Style::EmptyCaseCondition
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(case_node); end

  def on_case(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyCaseCondition
end

class RuboCop::Cop::Style::EmptyElse
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_case(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyElse
end

class RuboCop::Cop::Style::EmptyLambdaParameter
  include ::RuboCop::Cop::EmptyParameter
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLambdaParameter
end

class RuboCop::Cop::Style::EmptyLiteral
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  def array_node(node=T.unsafe(nil)); end

  def array_with_block(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def hash_node(node=T.unsafe(nil)); end

  def hash_with_block(node=T.unsafe(nil)); end

  def on_send(node); end

  def str_node(node=T.unsafe(nil)); end
  ARR_MSG = ::T.let(nil, ::T.untyped)
  HASH_MSG = ::T.let(nil, ::T.untyped)
  STR_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLiteral
end

class RuboCop::Cop::Style::EmptyMethod
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG_COMPACT = ::T.let(nil, ::T.untyped)
  MSG_EXPANDED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyMethod
end

class RuboCop::Cop::Style::Encoding
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  ENCODING_PATTERN = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Encoding
end

class RuboCop::Cop::Style::EndBlock
  def autocorrect(node); end

  def on_postexe(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EndBlock
end

class RuboCop::Cop::Style::EvalWithLocation
  def eval_without_location?(node=T.unsafe(nil)); end

  def line_with_offset?(node=T.unsafe(nil), param1, param2); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_INCORRECT_LINE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvalWithLocation
end

class RuboCop::Cop::Style::EvenOdd
  def autocorrect(node); end

  def even_odd_candidate?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvenOdd
end

class RuboCop::Cop::Style::ExpandPathArguments
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def file_expand_path(node=T.unsafe(nil)); end

  def on_send(node); end

  def pathname_new_parent_expand_path(node=T.unsafe(nil)); end

  def pathname_parent_expand_path(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  PATHNAME_MSG = ::T.let(nil, ::T.untyped)
  PATHNAME_NEW_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExpandPathArguments
end

class RuboCop::Cop::Style::ExponentialNotation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_float(node); end
end

class RuboCop::Cop::Style::ExponentialNotation
end

class RuboCop::Cop::Style::FloatDivision
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def any_coerce?(node=T.unsafe(nil)); end

  def both_coerce?(node=T.unsafe(nil)); end

  def left_coerce?(node=T.unsafe(nil)); end

  def on_send(node); end

  def right_coerce?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::FloatDivision
end

class RuboCop::Cop::Style::For
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def on_for(node); end
  EACH_LENGTH = ::T.let(nil, ::T.untyped)
  PREFER_EACH = ::T.let(nil, ::T.untyped)
  PREFER_FOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::For
end

class RuboCop::Cop::Style::FormatString
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def formatter(node=T.unsafe(nil)); end

  def message(detected_style); end

  def method_name(style_name); end

  def on_send(node); end

  def variable_argument?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FormatString
end

class RuboCop::Cop::Style::FormatStringToken
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def format_string_in_typical_context?(node=T.unsafe(nil)); end

  def on_str(node); end
end

class RuboCop::Cop::Style::FormatStringToken
end

class RuboCop::Cop::Style::FrozenStringLiteralComment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def investigate(processed_source); end
  MSG_DISABLED = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
  MSG_MISSING_TRUE = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FrozenStringLiteralComment
end

class RuboCop::Cop::Style::GlobalVars
  def allowed_var?(global_var); end

  def check(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def user_vars(); end
  BUILT_IN_VARS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GlobalVars
end

class RuboCop::Cop::Style::GuardClause
  include ::RuboCop::Cop::MinBodyLength
  include ::RuboCop::Cop::StatementModifier
  def on_def(node); end

  def on_defs(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GuardClause
end

class RuboCop::Cop::Style::HashEachMethods
  include ::RuboCop::Cop::Lint::UnusedArgument
  def autocorrect(node); end

  def kv_each(node=T.unsafe(nil)); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashEachMethods
end

class RuboCop::Cop::Style::HashSyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def hash_rockets_check(pairs); end

  def no_mixed_keys_check(pairs); end

  def on_hash(node); end

  def ruby19_check(pairs); end

  def ruby19_no_mixed_keys_check(pairs); end
  MSG_19 = ::T.let(nil, ::T.untyped)
  MSG_HASH_ROCKETS = ::T.let(nil, ::T.untyped)
  MSG_NO_MIXED_KEYS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashSyntax
end

class RuboCop::Cop::Style::HashTransformKeys
  include ::RuboCop::Cop::HashTransformMethod
  def on_bad_each_with_object(node=T.unsafe(nil)); end

  def on_bad_hash_brackets_map(node=T.unsafe(nil)); end

  def on_bad_map_to_h(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::HashTransformKeys
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::HashTransformValues
  include ::RuboCop::Cop::HashTransformMethod
  def on_bad_each_with_object(node=T.unsafe(nil)); end

  def on_bad_hash_brackets_map(node=T.unsafe(nil)); end

  def on_bad_map_to_h(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::HashTransformValues
end

class RuboCop::Cop::Style::IdenticalConditionalBranches
  def on_case(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IdenticalConditionalBranches
end

class RuboCop::Cop::Style::IfCorrector
end

class RuboCop::Cop::Style::IfCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(cop, node); end

  def self.move_assignment_inside_condition(node); end
end

class RuboCop::Cop::Style::IfInsideElse
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfInsideElse
end

class RuboCop::Cop::Style::IfUnlessModifier
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::IgnoredPattern
  def autocorrect(node); end

  def on_if(node); end
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG_USE_MODIFIER = ::T.let(nil, ::T.untyped)
  MSG_USE_NORMAL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfUnlessModifier
end

class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless
  include ::RuboCop::Cop::StatementModifier
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless
end

class RuboCop::Cop::Style::IfWithSemicolon
  include ::RuboCop::Cop::OnNormalIfUnless
  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfWithSemicolon
end

class RuboCop::Cop::Style::ImplicitRuntimeError
  def implicit_runtime_error_raise_or_fail(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ImplicitRuntimeError
end

class RuboCop::Cop::Style::InfiniteLoop
  def after_leaving_scope(scope, _variable_table); end

  def autocorrect(node); end

  def join_force?(force_class); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  LEADING_SPACE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InfiniteLoop
end

class RuboCop::Cop::Style::InlineComment
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InlineComment
end

class RuboCop::Cop::Style::InverseMethods
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def correct_inverse_block(node); end

  def correct_inverse_method(node); end

  def correct_inverse_selector(block, corrector); end

  def inverse_block?(node=T.unsafe(nil)); end

  def inverse_candidate?(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_send(node); end
  CAMEL_CASE = ::T.let(nil, ::T.untyped)
  CLASS_COMPARISON_METHODS = ::T.let(nil, ::T.untyped)
  EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NEGATED_EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InverseMethods
end

class RuboCop::Cop::Style::IpAddresses
  include ::RuboCop::Cop::StringHelp
  def correct_style_detected(); end

  def offense?(node); end

  def opposite_style_detected(); end
  IPV6_MAX_SIZE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IpAddresses
end

class RuboCop::Cop::Style::Lambda
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_block(node); end

  def on_numblock(node); end
  LITERAL_MESSAGE = ::T.let(nil, ::T.untyped)
  METHOD_MESSAGE = ::T.let(nil, ::T.untyped)
  OFFENDING_SELECTORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Lambda
end

class RuboCop::Cop::Style::LambdaCall
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::LambdaCall
end

class RuboCop::Cop::Style::LineEndConcatenation
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(operator_range); end

  def investigate(processed_source); end
  COMPLEX_STRING_BEGIN_TOKEN = ::T.let(nil, ::T.untyped)
  COMPLEX_STRING_END_TOKEN = ::T.let(nil, ::T.untyped)
  CONCAT_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  HIGH_PRECEDENCE_OP_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  QUOTE_DELIMITERS = ::T.let(nil, ::T.untyped)
  SIMPLE_STRING_TOKEN_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::LineEndConcatenation
end

class RuboCop::Cop::Style::MethodCallWithArgsParentheses
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods
  include ::RuboCop::Cop::IgnoredPattern
  def autocorrect(_node); end

  def initialize(*_); end
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses
  def autocorrect(node); end

  def message(_node=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end

  def on_super(node); end

  def on_yield(node); end
  TRAILING_WHITESPACE_REGEX = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::RequireParentheses
  def autocorrect(node); end

  def message(_node=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end

  def on_super(node); end

  def on_yield(node); end
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::RequireParentheses
end

class RuboCop::Cop::Style::MethodCallWithArgsParentheses
end

class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses
  include ::RuboCop::Cop::IgnoredMethods
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses
end

class RuboCop::Cop::Style::MethodCalledOnDoEndBlock
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCalledOnDoEndBlock
end

class RuboCop::Cop::Style::MethodDefParentheses
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG_MISSING = ::T.let(nil, ::T.untyped)
  MSG_PRESENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodDefParentheses
end

class RuboCop::Cop::Style::MethodMissingSuper
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodMissingSuper
end

class RuboCop::Cop::Style::MinMax
  def autocorrect(node); end

  def min_max_candidate(node=T.unsafe(nil)); end

  def on_array(node); end

  def on_return(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MinMax
end

class RuboCop::Cop::Style::MissingElse
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_case(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_EMPTY = ::T.let(nil, ::T.untyped)
  MSG_NIL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MissingElse
end

class RuboCop::Cop::Style::MissingRespondToMissing
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MissingRespondToMissing
end

class RuboCop::Cop::Style::MixinGrouping
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_class(node); end

  def on_module(node); end
  MIXIN_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MixinGrouping
end

class RuboCop::Cop::Style::MixinUsage
  def include_statement(node=T.unsafe(nil)); end

  def on_send(node); end

  def wrapped_macro_scope?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MixinUsage
end

class RuboCop::Cop::Style::ModuleFunction
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def extend_self_node?(node=T.unsafe(nil)); end

  def module_function_node?(node=T.unsafe(nil)); end

  def on_module(node); end

  def private_directive?(node=T.unsafe(nil)); end
  EXTEND_SELF_MSG = ::T.let(nil, ::T.untyped)
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  MODULE_FUNCTION_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ModuleFunction
end

class RuboCop::Cop::Style::MultilineBlockChain
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineBlockChain
end

class RuboCop::Cop::Style::MultilineIfModifier
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineIfModifier
end

class RuboCop::Cop::Style::MultilineIfThen
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
  NON_MODIFIER_THEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineIfThen
end

class RuboCop::Cop::Style::MultilineMemoization
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_or_asgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMemoization
end

class RuboCop::Cop::Style::MultilineMethodSignature
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMethodSignature
end

class RuboCop::Cop::Style::MultilineTernaryOperator
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineTernaryOperator
end

class RuboCop::Cop::Style::MultilineWhenThen
  include ::RuboCop::Cop::RangeHelp
  def accept_node_type?(node); end

  def autocorrect(node); end

  def on_when(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineWhenThen
end

class RuboCop::Cop::Style::MultipleComparison
  def on_or(node); end

  def simple_comparison?(node=T.unsafe(nil)); end

  def simple_double_comparison?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultipleComparison
end

class RuboCop::Cop::Style::MutableConstant
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_casgn(node); end

  def on_or_asgn(node); end

  def operation_produces_immutable_object?(node=T.unsafe(nil)); end

  def range_enclosed_in_parentheses?(node=T.unsafe(nil)); end

  def splat_value(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MutableConstant
end

class RuboCop::Cop::Style::NegatedIf
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::NegativeConditional
  def autocorrect(node); end

  def on_if(node); end
end

class RuboCop::Cop::Style::NegatedIf
end

class RuboCop::Cop::Style::NegatedUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::NegativeConditional
  def autocorrect(node); end

  def on_if(node); end
end

class RuboCop::Cop::Style::NegatedUnless
end

class RuboCop::Cop::Style::NegatedWhile
  include ::RuboCop::Cop::NegativeConditional
  def autocorrect(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::NegatedWhile
end

class RuboCop::Cop::Style::NestedModifier
  include ::RuboCop::Cop::RangeHelp
  def add_parentheses_to_method_arguments(send_node); end

  def autocorrect(node); end

  def check(node); end

  def left_hand_operand(node, operator); end

  def modifier?(node); end

  def new_expression(inner_node); end

  def on_if(node); end

  def on_until(node); end

  def on_while(node); end

  def replacement_operator(keyword); end

  def requires_parens?(node); end

  def right_hand_operand(node, left_hand_keyword); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedModifier
end

class RuboCop::Cop::Style::NestedParenthesizedCalls
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(nested); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedParenthesizedCalls
end

class RuboCop::Cop::Style::NestedTernaryOperator
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedTernaryOperator
end

class RuboCop::Cop::Style::Next
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MinBodyLength
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def investigate(_processed_source); end

  def on_block(node); end

  def on_for(node); end

  def on_until(node); end

  def on_while(node); end
  EXIT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Next
end

class RuboCop::Cop::Style::NilComparison
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def nil_check?(node=T.unsafe(nil)); end

  def nil_comparison?(node=T.unsafe(nil)); end

  def on_send(node); end
  EXPLICIT_MSG = ::T.let(nil, ::T.untyped)
  PREDICATE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NilComparison
end

class RuboCop::Cop::Style::NonNilCheck
  def autocorrect(node); end

  def nil_check?(node=T.unsafe(nil)); end

  def not_and_nil_check?(node=T.unsafe(nil)); end

  def not_equal_to_nil?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def unless_check?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::NonNilCheck
end

class RuboCop::Cop::Style::Not
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OPPOSITE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Not
end

class RuboCop::Cop::Style::NumericLiteralPrefix
  include ::RuboCop::Cop::IntegerNode
  def autocorrect(node); end

  def on_int(node); end
  BINARY_MSG = ::T.let(nil, ::T.untyped)
  BINARY_REGEX = ::T.let(nil, ::T.untyped)
  DECIMAL_MSG = ::T.let(nil, ::T.untyped)
  DECIMAL_REGEX = ::T.let(nil, ::T.untyped)
  HEX_MSG = ::T.let(nil, ::T.untyped)
  HEX_REGEX = ::T.let(nil, ::T.untyped)
  OCTAL_MSG = ::T.let(nil, ::T.untyped)
  OCTAL_REGEX = ::T.let(nil, ::T.untyped)
  OCTAL_ZERO_ONLY_MSG = ::T.let(nil, ::T.untyped)
  OCTAL_ZERO_ONLY_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericLiteralPrefix
end

class RuboCop::Cop::Style::NumericLiterals
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IntegerNode
  def autocorrect(node); end

  def on_float(node); end

  def on_int(node); end
  DELIMITER_REGEXP = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericLiterals
end

class RuboCop::Cop::Style::NumericPredicate
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods
  def autocorrect(node); end

  def comparison(node=T.unsafe(nil)); end

  def inverted_comparison(node=T.unsafe(nil)); end

  def on_send(node); end

  def predicate(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  REPLACEMENTS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericPredicate
end

class RuboCop::Cop::Style::OneLineConditional
  include ::RuboCop::Cop::OnNormalIfUnless
  def autocorrect(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OneLineConditional
end

class RuboCop::Cop::Style::OptionHash
  def on_args(node); end

  def option_hash(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionHash
end

class RuboCop::Cop::Style::OptionalArguments
  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionalArguments
end

class RuboCop::Cop::Style::OrAssignment
  def autocorrect(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def ternary_assignment?(node=T.unsafe(nil)); end

  def unless_assignment?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OrAssignment
end

class RuboCop::Cop::Style::ParallelAssignment
  include ::RuboCop::Cop::RescueNode
  def autocorrect(node); end

  def implicit_self_getter?(node=T.unsafe(nil)); end

  def on_masgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter
  include ::TSort
  def accesses?(rhs, lhs); end

  def dependency?(lhs, rhs); end

  def initialize(assignments); end

  def matching_calls(node0, param1, param2); end

  def tsort_each_child(assignment); end

  def uses_var?(node0, param1); end

  def var_name(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
  include ::RuboCop::Cop::Alignment
  def assignment(); end

  def config(); end

  def correction(); end

  def correction_range(); end

  def initialize(node, config, new_elements); end

  def node(); end
end

class RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::ModifierCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::ModifierCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::RescueCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::RescueCorrector
end

class RuboCop::Cop::Style::ParallelAssignment
end

class RuboCop::Cop::Style::ParenthesesAroundCondition
  include ::RuboCop::Cop::SafeAssignment
  include ::RuboCop::Cop::Parentheses
  def autocorrect(node); end

  def control_op_condition(node=T.unsafe(nil)); end

  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::ParenthesesAroundCondition
end

class RuboCop::Cop::Style::PercentLiteralDelimiters
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def message(node); end

  def on_array(node); end

  def on_dstr(node); end

  def on_regexp(node); end

  def on_str(node); end

  def on_sym(node); end

  def on_xstr(node); end
end

class RuboCop::Cop::Style::PercentLiteralDelimiters
end

class RuboCop::Cop::Style::PercentQLiterals
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_str(node); end
  LOWER_CASE_Q_MSG = ::T.let(nil, ::T.untyped)
  UPPER_CASE_Q_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PercentQLiterals
end

class RuboCop::Cop::Style::PerlBackrefs
  def autocorrect(node); end

  def on_nth_ref(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PerlBackrefs
end

class RuboCop::Cop::Style::PreferredHashMethods
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OFFENDING_SELECTORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PreferredHashMethods
end

class RuboCop::Cop::Style::Proc
  def autocorrect(node); end

  def on_block(node); end

  def proc_new?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Proc
end

class RuboCop::Cop::Style::RaiseArgs
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
  COMPACT_MSG = ::T.let(nil, ::T.untyped)
  EXPLODED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RaiseArgs
end

class RuboCop::Cop::Style::RandomWithOffset
  def autocorrect(node); end

  def integer_op_rand?(node=T.unsafe(nil)); end

  def namespace(node=T.unsafe(nil)); end

  def on_send(node); end

  def rand_modified?(node=T.unsafe(nil)); end

  def rand_op_integer?(node=T.unsafe(nil)); end

  def random_call(node=T.unsafe(nil)); end

  def to_int(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RandomWithOffset
end

class RuboCop::Cop::Style::RedundantBegin
  def autocorrect(node); end

  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantBegin
end

class RuboCop::Cop::Style::RedundantCapitalW
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantCapitalW
end

class RuboCop::Cop::Style::RedundantCondition
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
  REDUNDANT_CONDITION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantCondition
end

class RuboCop::Cop::Style::RedundantConditional
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_if(node); end

  def redundant_condition?(node=T.unsafe(nil)); end

  def redundant_condition_inverted?(node=T.unsafe(nil)); end
  COMPARISON_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantConditional
end

class RuboCop::Cop::Style::RedundantException
  def autocorrect(node); end

  def compact?(node=T.unsafe(nil)); end

  def exploded?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG_1 = ::T.let(nil, ::T.untyped)
  MSG_2 = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantException
end

class RuboCop::Cop::Style::RedundantFreeze
  include ::RuboCop::Cop::FrozenStringLiteral
  def autocorrect(node); end

  def on_send(node); end

  def operation_produces_immutable_object?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFreeze
end

class RuboCop::Cop::Style::RedundantInterpolation
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_dstr(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantInterpolation
end

class RuboCop::Cop::Style::RedundantParentheses
  include ::RuboCop::Cop::Parentheses
  def arg_in_call_with_block?(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def first_send_argument?(node=T.unsafe(nil)); end

  def first_super_argument?(node=T.unsafe(nil)); end

  def method_node_and_args(node=T.unsafe(nil)); end

  def on_begin(node); end

  def range_end?(node=T.unsafe(nil)); end

  def rescue?(node=T.unsafe(nil)); end

  def square_brackets?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::RedundantParentheses
end

class RuboCop::Cop::Style::RedundantPercentQ
  def autocorrect(node); end

  def on_dstr(node); end

  def on_str(node); end
  DYNAMIC_MSG = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ESCAPED_NON_BACKSLASH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_Q = ::T.let(nil, ::T.untyped)
  PERCENT_Q = ::T.let(nil, ::T.untyped)
  QUOTE = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTE = ::T.let(nil, ::T.untyped)
  STRING_INTERPOLATION_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantPercentQ
end

class RuboCop::Cop::Style::RedundantReturn
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MULTI_RETURN_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantReturn
end

class RuboCop::Cop::Style::RedundantSelf
  def autocorrect(node); end

  def on_and_asgn(node); end

  def on_args(node); end

  def on_block(node); end

  def on_blockarg(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
  KERNEL_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelf
end

class RuboCop::Cop::Style::RedundantSort
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def redundant_sort?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSort
end

class RuboCop::Cop::Style::RedundantSortBy
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def redundant_sort_by(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSortBy
end

class RuboCop::Cop::Style::RegexpLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_regexp(node); end
  MSG_USE_PERCENT_R = ::T.let(nil, ::T.untyped)
  MSG_USE_SLASHES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RegexpLiteral
end

class RuboCop::Cop::Style::RescueModifier
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::RescueNode
  def autocorrect(node); end

  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RescueModifier
end

class RuboCop::Cop::Style::RescueStandardError
  include ::RuboCop::Cop::RescueNode
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_resbody(node); end

  def rescue_standard_error?(node=T.unsafe(nil)); end

  def rescue_without_error_class?(node=T.unsafe(nil)); end
  MSG_EXPLICIT = ::T.let(nil, ::T.untyped)
  MSG_IMPLICIT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RescueStandardError
end

class RuboCop::Cop::Style::ReturnNil
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def chained_send?(node=T.unsafe(nil)); end

  def define_method?(node=T.unsafe(nil)); end

  def on_return(node); end

  def return_nil_node?(node=T.unsafe(nil)); end

  def return_node?(node=T.unsafe(nil)); end
  RETURN_MSG = ::T.let(nil, ::T.untyped)
  RETURN_NIL_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ReturnNil
end

class RuboCop::Cop::Style::SafeNavigation
  include ::RuboCop::Cop::NilMethods
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def check_node(node); end

  def modifier_if_safe_navigation_candidate(node=T.unsafe(nil)); end

  def not_nil_check?(node=T.unsafe(nil)); end

  def on_and(node); end

  def on_if(node); end

  def use_var_only_in_unless_modifier?(node, variable); end
  LOGIC_JUMP_KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SafeNavigation
end

class RuboCop::Cop::Style::Sample
  def autocorrect(node); end

  def on_send(node); end

  def sample_candidate?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Sample
end

class RuboCop::Cop::Style::SelfAssignment
  def autocorrect(node); end

  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SelfAssignment
end

class RuboCop::Cop::Style::Semicolon
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end

  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Semicolon
end

class RuboCop::Cop::Style::Send
  def on_csend(node); end

  def on_send(node); end

  def sending?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Send
end

class RuboCop::Cop::Style::SignalException
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def custom_fail_methods(node0); end

  def investigate(processed_source); end

  def kernel_call?(node=T.unsafe(nil), param1); end

  def on_rescue(node); end

  def on_send(node); end
  FAIL_MSG = ::T.let(nil, ::T.untyped)
  RAISE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SignalException
end

class RuboCop::Cop::Style::SingleLineBlockParams
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineBlockParams
end

class RuboCop::Cop::Style::SingleLineMethods
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineMethods
end

class RuboCop::Cop::Style::SpecialGlobalVars
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def message(node); end

  def on_gvar(node); end
  ENGLISH_VARS = ::T.let(nil, ::T.untyped)
  MSG_BOTH = ::T.let(nil, ::T.untyped)
  MSG_ENGLISH = ::T.let(nil, ::T.untyped)
  MSG_REGULAR = ::T.let(nil, ::T.untyped)
  NON_ENGLISH_VARS = ::T.let(nil, ::T.untyped)
  PERL_VARS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SpecialGlobalVars
end

class RuboCop::Cop::Style::StabbyLambdaParentheses
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
  MSG_NO_REQUIRE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StabbyLambdaParentheses
end

class RuboCop::Cop::Style::StderrPuts
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def stderr_puts?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StderrPuts
end

class RuboCop::Cop::Style::StringHashKeys
  def autocorrect(node); end

  def on_pair(node); end

  def receive_environments_method?(node=T.unsafe(nil)); end

  def string_hash_key?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringHashKeys
end

class RuboCop::Cop::Style::StringLiterals
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
  def autocorrect(node); end

  def on_dstr(node); end
  MSG_INCONSISTENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringLiterals
end

class RuboCop::Cop::Style::StringLiteralsInInterpolation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
  def autocorrect(node); end
end

class RuboCop::Cop::Style::StringLiteralsInInterpolation
end

class RuboCop::Cop::Style::StringMethods
  include ::RuboCop::Cop::MethodPreference
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringMethods
end

class RuboCop::Cop::Style::Strip
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def lstrip_rstrip(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Strip
end

class RuboCop::Cop::Style::StructInheritance
  def on_class(node); end

  def struct_constructor?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StructInheritance
end

class RuboCop::Cop::Style::SymbolArray
  include ::RuboCop::Cop::ArrayMinSize
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::PercentArray
  def autocorrect(node); end

  def on_array(node); end
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  PERCENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolArray
  def self.largest_brackets(); end

  def self.largest_brackets=(largest_brackets); end
end

class RuboCop::Cop::Style::SymbolLiteral
  def autocorrect(node); end

  def on_sym(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolLiteral
end

class RuboCop::Cop::Style::SymbolProc
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::IgnoredMethods
  def autocorrect(node); end

  def destructuring_block_argument?(argument_node); end

  def on_block(node); end

  def proc_node?(node=T.unsafe(nil)); end

  def symbol_proc?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  SUPER_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolProc
end

class RuboCop::Cop::Style::TernaryCorrector
end

class RuboCop::Cop::Style::TernaryCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(node); end

  def self.move_assignment_inside_condition(node); end
end

class RuboCop::Cop::Style::TernaryParentheses
  include ::RuboCop::Cop::SafeAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def method_name(node=T.unsafe(nil)); end

  def on_if(node); end

  def only_closing_parenthesis_is_last_line?(condition); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_COMPLEX = ::T.let(nil, ::T.untyped)
  NON_COMPLEX_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TernaryParentheses
end

class RuboCop::Cop::Style::TrailingBodyOnClass
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  def autocorrect(node); end

  def on_class(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnClass
end

class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition
end

class RuboCop::Cop::Style::TrailingBodyOnModule
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  def autocorrect(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnModule
end

class RuboCop::Cop::Style::TrailingCommaInArguments
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::TrailingCommaInArguments
end

class RuboCop::Cop::Style::TrailingCommaInArrayLiteral
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_array(node); end
end

class RuboCop::Cop::Style::TrailingCommaInArrayLiteral
end

class RuboCop::Cop::Style::TrailingCommaInBlockArgs
  def autocorrect(node); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingCommaInBlockArgs
end

class RuboCop::Cop::Style::TrailingCommaInHashLiteral
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_hash(node); end
end

class RuboCop::Cop::Style::TrailingCommaInHashLiteral
end

class RuboCop::Cop::Style::TrailingMethodEndStatement
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingMethodEndStatement
end

class RuboCop::Cop::Style::TrailingUnderscoreVariable
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_masgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingUnderscoreVariable
end

class RuboCop::Cop::Style::TrivialAccessors
  def autocorrect(node); end

  def looks_like_trivial_writer?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrivialAccessors
end

class RuboCop::Cop::Style::UnlessElse
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_if(node); end

  def range_between_condition_and_else(node, condition); end

  def range_between_else_and_end(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnlessElse
end

class RuboCop::Cop::Style::UnpackFirst
  def autocorrect(node); end

  def on_send(node); end

  def unpack_and_first_element?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnpackFirst
end

class RuboCop::Cop::Style::VariableInterpolation
  include ::RuboCop::Cop::Interpolation
  def autocorrect(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::VariableInterpolation
end

class RuboCop::Cop::Style::WhenThen
  def autocorrect(node); end

  def on_when(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhenThen
end

class RuboCop::Cop::Style::WhileUntilDo
  def autocorrect(node); end

  def handle(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhileUntilDo
end

class RuboCop::Cop::Style::WhileUntilModifier
  include ::RuboCop::Cop::StatementModifier
  def autocorrect(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhileUntilModifier
end

class RuboCop::Cop::Style::WordArray
  include ::RuboCop::Cop::ArrayMinSize
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::PercentArray
  def autocorrect(node); end

  def on_array(node); end
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  PERCENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WordArray
  def self.largest_brackets(); end

  def self.largest_brackets=(largest_brackets); end
end

class RuboCop::Cop::Style::YodaCondition
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def file_constant_equal_program_name?(node=T.unsafe(nil)); end

  def on_send(node); end
  EQUALITY_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NONCOMMUTATIVE_OPERATORS = ::T.let(nil, ::T.untyped)
  PROGRAM_NAMES = ::T.let(nil, ::T.untyped)
  REVERSE_COMPARISON = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::YodaCondition
end

class RuboCop::Cop::Style::ZeroLengthPredicate
  def autocorrect(node); end

  def non_polymorphic_collection?(node=T.unsafe(nil)); end

  def nonzero_length_predicate(node=T.unsafe(nil)); end

  def on_send(node); end

  def other_receiver(node=T.unsafe(nil)); end

  def zero_length_predicate(node=T.unsafe(nil)); end

  def zero_length_receiver(node=T.unsafe(nil)); end
  NONZERO_MSG = ::T.let(nil, ::T.untyped)
  ZERO_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ZeroLengthPredicate
end

module RuboCop::Cop::Style
end

module RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  NO_SPACE_COMMAND = ::T.let(nil, ::T.untyped)
  SINGLE_SPACE_REGEXP = ::T.let(nil, ::T.untyped)
  SPACE_COMMAND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SurroundingSpace
end

module RuboCop::Cop::TargetRubyVersion
  def minimum_target_ruby_version(version); end

  def support_target_ruby_version?(version); end
end

module RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Team
  def autocorrect(buffer, cops); end

  def autocorrect?(); end

  def cops(); end

  def debug?(); end

  def errors(); end

  def external_dependency_checksum(); end

  def forces(); end

  def forces_for(cops); end

  def initialize(cop_classes, config, options=T.unsafe(nil)); end

  def inspect_file(processed_source); end

  def updated_source_file(); end

  def updated_source_file?(); end

  def warnings(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Team::Investigation
  def errors(); end

  def errors=(_); end

  def offenses(); end

  def offenses=(_); end
end

class RuboCop::Cop::Team::Investigation
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::Team
end

module RuboCop::Cop::TooManyLines
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::TooManyLines
end

module RuboCop::Cop::TrailingBody
  def body_on_first_line?(node, body); end

  def first_part_of(body); end

  def trailing_body?(node); end
end

module RuboCop::Cop::TrailingBody
end

module RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::TrailingComma
end

module RuboCop::Cop::UncommunicativeName
  def check(node, args); end
  CASE_MSG = ::T.let(nil, ::T.untyped)
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  LENGTH_MSG = ::T.let(nil, ::T.untyped)
  NUM_MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::UncommunicativeName
end

class RuboCop::Cop::UnusedArgCorrector
end

class RuboCop::Cop::UnusedArgCorrector
  extend ::RuboCop::Cop::RangeHelp
  def self.correct(processed_source, node); end

  def self.correct_for_blockarg_type(node); end

  def self.processed_source(); end
end

module RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  LITERAL_REGEX = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Util
  def self.begins_its_line?(range); end

  def self.comment_line?(line_source); end

  def self.double_quotes_required?(string); end

  def self.escape_string(string); end

  def self.first_part_of_call_chain(node); end

  def self.interpret_string_escapes(string); end

  def self.line_range(node); end

  def self.needs_escaping?(string); end

  def self.on_node(syms, sexp, excludes=T.unsafe(nil), &block); end

  def self.parentheses?(node); end

  def self.same_line?(node1, node2); end

  def self.to_string_literal(string); end

  def self.to_supported_styles(enforced_style); end

  def self.tokens(node); end

  def self.trim_string_interporation_escape_character(str); end
end

module RuboCop::Cop::Utils
end

class RuboCop::Cop::Utils::FormatString
  def format_sequences(); end

  def initialize(string); end

  def max_digit_dollar_num(); end

  def named_interpolation?(); end
  DIGIT_DOLLAR = ::T.let(nil, ::T.untyped)
  FLAG = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  NUMBER_ARG = ::T.let(nil, ::T.untyped)
  PRECISION = ::T.let(nil, ::T.untyped)
  SEQUENCE = ::T.let(nil, ::T.untyped)
  TEMPLATE_NAME = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
  WIDTH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Utils::FormatString::FormatSequence
  def annotated?(); end

  def arity(); end

  def begin_pos(); end

  def end_pos(); end

  def flags(); end

  def initialize(match); end

  def max_digit_dollar_num(); end

  def name(); end

  def percent?(); end

  def precision(); end

  def style(); end

  def template?(); end

  def type(); end

  def width(); end
end

class RuboCop::Cop::Utils::FormatString::FormatSequence
end

class RuboCop::Cop::Utils::FormatString
end

module RuboCop::Cop::Utils
end

class RuboCop::Cop::VariableForce
  def investigate(processed_source); end

  def process_node(node); end

  def variable_table(); end
  ARGUMENT_DECLARATION_TYPES = ::T.let(nil, ::T.untyped)
  LOGICAL_OPERATOR_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  LOOP_TYPES = ::T.let(nil, ::T.untyped)
  MULTIPLE_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  OPERATOR_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  POST_CONDITION_LOOP_TYPES = ::T.let(nil, ::T.untyped)
  REGEXP_NAMED_CAPTURE_TYPE = ::T.let(nil, ::T.untyped)
  RESCUE_TYPE = ::T.let(nil, ::T.untyped)
  SCOPE_TYPES = ::T.let(nil, ::T.untyped)
  SEND_TYPE = ::T.let(nil, ::T.untyped)
  TWISTED_SCOPE_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_REFERENCE_TYPE = ::T.let(nil, ::T.untyped)
  ZERO_ARITY_SUPER_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Assignment
  include ::RuboCop::Cop::VariableForce::Branchable
  def initialize(node, variable); end

  def meta_assignment_node(); end

  def multiple_assignment?(); end

  def name(); end

  def node(); end

  def operator(); end

  def operator_assignment?(); end

  def reference!(node); end

  def referenced(); end

  def referenced?(); end

  def references(); end

  def regexp_named_capture?(); end

  def scope(); end

  def used?(); end

  def variable(); end
  MULTIPLE_LEFT_HAND_SIDE_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Assignment
end

class RuboCop::Cop::VariableForce::AssignmentReference
  def assignment?(); end

  def node(); end

  def node=(_); end
end

class RuboCop::Cop::VariableForce::AssignmentReference
  def self.[](*_); end

  def self.members(); end
end

module RuboCop::Cop::VariableForce::Branch
  CLASSES_BY_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Branch::And
  include ::RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def left_body?(); end

  def right_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::And
end

class RuboCop::Cop::VariableForce::Branch::Base
  def ==(other); end

  def always_run?(); end

  def branched?(); end

  def child_node(); end

  def child_node=(_); end

  def control_node(); end

  def each_ancestor(include_self: T.unsafe(nil), &block); end

  def eql?(other); end

  def exclusive_with?(other); end

  def may_jump_to_other_branch?(); end

  def may_run_incompletely?(); end

  def parent(); end

  def scope(); end

  def scope=(_); end
end

class RuboCop::Cop::VariableForce::Branch::Base
  def self.[](*_); end

  def self.classes(); end

  def self.define_predicate(name, child_index: T.unsafe(nil)); end

  def self.inherited(subclass); end

  def self.members(); end

  def self.type(); end
end

class RuboCop::Cop::VariableForce::Branch::Case
  def else_body?(); end

  def target?(); end

  def when_clause?(); end
end

class RuboCop::Cop::VariableForce::Branch::Case
end

class RuboCop::Cop::VariableForce::Branch::Ensure
  include ::RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def ensure_body?(); end

  def main_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Ensure
end

module RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def may_jump_to_other_branch?(); end

  def may_run_incompletely?(); end
end

module RuboCop::Cop::VariableForce::Branch::ExceptionHandler
end

class RuboCop::Cop::VariableForce::Branch::For
  def collection?(); end

  def element?(); end

  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::For
end

class RuboCop::Cop::VariableForce::Branch::If
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def falsey_body?(); end

  def truthy_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::If
end

module RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def always_run?(); end
end

module RuboCop::Cop::VariableForce::Branch::LogicalOperator
end

class RuboCop::Cop::VariableForce::Branch::Or
  include ::RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def left_body?(); end

  def right_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Or
end

class RuboCop::Cop::VariableForce::Branch::Rescue
  include ::RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def else_body?(); end

  def main_body?(); end

  def rescue_clause?(); end
end

class RuboCop::Cop::VariableForce::Branch::Rescue
end

module RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def always_run?(); end

  def conditional_clause?(); end
end

module RuboCop::Cop::VariableForce::Branch::SimpleConditional
end

class RuboCop::Cop::VariableForce::Branch::Until
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Until
end

class RuboCop::Cop::VariableForce::Branch::UntilPost
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::UntilPost
end

class RuboCop::Cop::VariableForce::Branch::While
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::While
end

class RuboCop::Cop::VariableForce::Branch::WhilePost
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::WhilePost
end

module RuboCop::Cop::VariableForce::Branch
  def self.of(target_node, scope: T.unsafe(nil)); end
end

module RuboCop::Cop::VariableForce::Branchable
  def branch(); end

  def run_exclusively_with?(other); end
end

module RuboCop::Cop::VariableForce::Branchable
end

class RuboCop::Cop::VariableForce::Reference
  include ::RuboCop::Cop::VariableForce::Branchable
  def explicit?(); end

  def initialize(node, scope); end

  def node(); end

  def scope(); end
  VARIABLE_REFERENCE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Reference
end

class RuboCop::Cop::VariableForce::Scope
  def ==(other); end

  def body_node(); end

  def each_node(&block); end

  def include?(target_node); end

  def initialize(node); end

  def naked_top_level(); end

  def naked_top_level?(); end

  def name(); end

  def node(); end

  def variables(); end
  OUTER_SCOPE_CHILD_INDICES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Scope
end

class RuboCop::Cop::VariableForce::Variable
  def argument?(); end

  def assign(node); end

  def assignments(); end

  def block_argument?(); end

  def capture_with_block!(); end

  def captured_by_block(); end

  def captured_by_block?(); end

  def declaration_node(); end

  def explicit_block_local_variable?(); end

  def in_modifier_if?(assignment); end

  def initialize(name, declaration_node, scope); end

  def keyword_argument?(); end

  def method_argument?(); end

  def name(); end

  def reference!(node); end

  def referenced?(); end

  def references(); end

  def scope(); end

  def should_be_unused?(); end

  def used?(); end
  VARIABLE_DECLARATION_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Variable
end

class RuboCop::Cop::VariableForce::VariableReference
  def assignment?(); end

  def name(); end

  def name=(_); end
end

class RuboCop::Cop::VariableForce::VariableReference
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::VariableForce::VariableTable
  def accessible_variables(); end

  def assign_to_variable(name, node); end

  def current_scope(); end

  def current_scope_level(); end

  def declare_variable(name, node); end

  def find_variable(name); end

  def initialize(hook_receiver=T.unsafe(nil)); end

  def invoke_hook(hook_name, *args); end

  def pop_scope(); end

  def push_scope(scope_node); end

  def reference_variable(name, node); end

  def scope_stack(); end

  def variable_exist?(name); end
end

class RuboCop::Cop::VariableForce::VariableTable
end

class RuboCop::Cop::VariableForce
end

module RuboCop::Cop
end

class RuboCop::Error
end

class RuboCop::Error
end

class RuboCop::ErrorWithAnalyzedFileLocation
  def column(); end

  def cop(); end

  def initialize(cause:, node:, cop:); end

  def line(); end
end

class RuboCop::ErrorWithAnalyzedFileLocation
end

module RuboCop::FileFinder
  def find_file_upwards(filename, start_dir); end

  def find_files_upwards(filename, start_dir); end
end

module RuboCop::FileFinder
  def self.root_level=(level); end

  def self.root_level?(path); end
end

module RuboCop::Formatter
end

class RuboCop::Formatter::AutoGenConfigFormatter
end

class RuboCop::Formatter::AutoGenConfigFormatter
end

class RuboCop::Formatter::BaseFormatter
  def file_finished(file, offenses); end

  def file_started(file, options); end

  def finished(inspected_files); end

  def initialize(output, options=T.unsafe(nil)); end

  def options(); end

  def output(); end

  def started(target_files); end
end

class RuboCop::Formatter::BaseFormatter
end

class RuboCop::Formatter::ClangStyleFormatter
  ELLIPSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::ClangStyleFormatter
end

module RuboCop::Formatter::Colorizable
  def black(string); end

  def blue(string); end

  def colorize(string, *args); end

  def cyan(string); end

  def green(string); end

  def magenta(string); end

  def rainbow(); end

  def red(string); end

  def white(string); end

  def yellow(string); end
end

module RuboCop::Formatter::Colorizable
end

class RuboCop::Formatter::DisabledConfigFormatter
  def file_started(_file, _file_info); end

  def finished(_inspected_files); end
  HEADING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::DisabledConfigFormatter
  def self.config_to_allow_offenses(); end

  def self.config_to_allow_offenses=(config_to_allow_offenses); end

  def self.detected_styles(); end

  def self.detected_styles=(detected_styles); end
end

class RuboCop::Formatter::EmacsStyleFormatter
end

class RuboCop::Formatter::EmacsStyleFormatter
end

class RuboCop::Formatter::FileListFormatter
end

class RuboCop::Formatter::FileListFormatter
end

class RuboCop::Formatter::FormatterSet
  def add_formatter(formatter_type, output_path=T.unsafe(nil)); end

  def close_output_files(); end

  def file_finished(file, offenses); end

  def file_started(file, options); end

  def finished(*args); end

  def initialize(options=T.unsafe(nil)); end

  def started(*args); end
  BUILTIN_FORMATTERS_FOR_KEYS = ::T.let(nil, ::T.untyped)
  FORMATTER_APIS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::FormatterSet
end

class RuboCop::Formatter::FuubarStyleFormatter
  def initialize(*output); end

  def progressbar_color(); end

  def started(target_files); end

  def with_color(); end
  RESET_SEQUENCE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::FuubarStyleFormatter
end

class RuboCop::Formatter::HTMLFormatter
  def files(); end

  def render_html(); end

  def summary(); end
  ELLIPSES = ::T.let(nil, ::T.untyped)
  TEMPLATE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter::Color
  def alpha(); end

  def alpha=(_); end

  def blue(); end

  def blue=(_); end

  def fade_out(amount); end

  def green(); end

  def green=(_); end

  def red(); end

  def red=(_); end
end

class RuboCop::Formatter::HTMLFormatter::Color
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Formatter::HTMLFormatter::ERBContext
  include ::RuboCop::PathUtil
  include ::RuboCop::Formatter::TextUtil
  def base64_encoded_logo_image(); end

  def decorated_message(offense); end

  def escape(string); end

  def files(); end

  def highlighted_source_line(offense); end

  def hightlight_source_tag(offense); end

  def initialize(files, summary); end

  def possible_ellipses(location); end

  def source_after_highlight(offense); end

  def source_before_highlight(offense); end

  def summary(); end
  LOGO_IMAGE_PATH = ::T.let(nil, ::T.untyped)
  SEVERITY_COLORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter::ERBContext
end

class RuboCop::Formatter::HTMLFormatter
end

class RuboCop::Formatter::JSONFormatter
  include ::RuboCop::PathUtil
  def hash_for_file(file, offenses); end

  def hash_for_location(offense); end

  def hash_for_offense(offense); end

  def metadata_hash(); end

  def output_hash(); end
end

class RuboCop::Formatter::JSONFormatter
end

class RuboCop::Formatter::JUnitFormatter
  def classname_attribute_value(file); end

  def finished(_inspected_files); end
end

class RuboCop::Formatter::JUnitFormatter
end

class RuboCop::Formatter::OffenseCountFormatter
  def file_finished(_file, offenses); end

  def finished(_inspected_files); end

  def offense_counts(); end

  def ordered_offense_counts(offense_counts); end

  def report_summary(offense_counts); end

  def total_offense_count(offense_counts); end
end

class RuboCop::Formatter::OffenseCountFormatter
end

class RuboCop::Formatter::PacmanFormatter
  include ::RuboCop::Formatter::TextUtil
  def cols(); end

  def file_started(_file, _options); end

  def next_step(offenses); end

  def pacdots(number); end

  def progress_line(); end

  def progress_line=(progress_line); end

  def started(target_files); end

  def step(character); end

  def update_progress_line(); end
  FALLBACK_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
  GHOST = ::T.let(nil, ::T.untyped)
  PACDOT = ::T.let(nil, ::T.untyped)
  PACMAN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::PacmanFormatter
end

class RuboCop::Formatter::ProgressFormatter
  include ::RuboCop::Formatter::TextUtil
  def report_file_as_mark(offenses); end

  def started(target_files); end
  DOT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::ProgressFormatter
end

class RuboCop::Formatter::QuietFormatter
end

class RuboCop::Formatter::QuietFormatter
end

class RuboCop::Formatter::SimpleTextFormatter
  include ::RuboCop::Formatter::Colorizable
  include ::RuboCop::PathUtil
  def report_file(file, offenses); end

  def report_summary(file_count, offense_count, correction_count); end

  def started(_target_files); end
  COLOR_FOR_SEVERITY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::SimpleTextFormatter::Report
  include ::RuboCop::Formatter::Colorizable
  include ::RuboCop::Formatter::TextUtil
  def initialize(file_count, offense_count, correction_count, rainbow); end

  def summary(); end
end

class RuboCop::Formatter::SimpleTextFormatter::Report
end

class RuboCop::Formatter::SimpleTextFormatter
end

class RuboCop::Formatter::TapFormatter
  def started(target_files); end
end

class RuboCop::Formatter::TapFormatter
end

module RuboCop::Formatter::TextUtil
end

module RuboCop::Formatter::TextUtil
  def self.pluralize(number, thing, options=T.unsafe(nil)); end
end

class RuboCop::Formatter::WorstOffendersFormatter
  def finished(_inspected_files); end

  def offense_counts(); end

  def ordered_offense_counts(offense_counts); end

  def report_summary(offense_counts); end

  def total_offense_count(offense_counts); end
end

class RuboCop::Formatter::WorstOffendersFormatter
end

module RuboCop::Formatter
end

class RuboCop::IncorrectCopNameError
end

class RuboCop::IncorrectCopNameError
end

class RuboCop::MagicComment
  def any?(); end

  def encoding_specified?(); end

  def frozen_string_literal(); end

  def frozen_string_literal?(); end

  def frozen_string_literal_specified?(); end

  def initialize(comment); end

  def valid_literal_value?(); end
  TOKEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::EditorComment
end

class RuboCop::MagicComment::EditorComment
end

class RuboCop::MagicComment::EmacsComment
  def encoding(); end
  FORMAT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::EmacsComment
end

class RuboCop::MagicComment::SimpleComment
  def encoding(); end
end

class RuboCop::MagicComment::SimpleComment
end

class RuboCop::MagicComment::VimComment
  def encoding(); end
  FORMAT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::VimComment
end

class RuboCop::MagicComment
  def self.parse(comment); end
end

module RuboCop::NameSimilarity
  def find_similar_name(target_name, scope); end
  MINIMUM_SIMILARITY_TO_SUGGEST = ::T.let(nil, ::T.untyped)
end

module RuboCop::NameSimilarity
end

class RuboCop::NodePattern
  def ==(other); end

  def eql?(other); end

  def initialize(str); end

  def marshal_dump(); end

  def marshal_load(pattern); end

  def match(*args); end

  def pattern(); end
end

class RuboCop::NodePattern::Invalid
end

class RuboCop::NodePattern::Invalid
end

module RuboCop::NodePattern::Macros
  def def_node_matcher(method_name, pattern_str); end

  def def_node_search(method_name, pattern_str); end

  def node_search(method_name, compiler, on_match, prelude, called_from); end

  def node_search_all(method_name, compiler, called_from); end

  def node_search_body(method_name, trailing_params, prelude, match_code, on_match); end

  def node_search_first(method_name, compiler, called_from); end
end

module RuboCop::NodePattern::Macros
end

class RuboCop::NodePattern
  def self.descend(element, &block); end
end

class RuboCop::OptionArgumentError
end

class RuboCop::OptionArgumentError
end

class RuboCop::Options
  def parse(command_line_args); end
  DEFAULT_MAXIMUM_EXCLUSION_ITEMS = ::T.let(nil, ::T.untyped)
  EXITING_OPTIONS = ::T.let(nil, ::T.untyped)
  E_STDIN_NO_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Options
end

module RuboCop::OptionsHelp
  FORMATTER_OPTION_LIST = ::T.let(nil, ::T.untyped)
  MAX_EXCL = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
end

module RuboCop::OptionsHelp
end

class RuboCop::OptionsValidator
  def boolean_or_empty_cache?(); end

  def display_only_fail_level_offenses_with_autocorrect?(); end

  def except_syntax?(); end

  def incompatible_options(); end

  def initialize(options); end

  def only_includes_redundant_disable?(); end

  def validate_auto_correct(); end

  def validate_auto_gen_config(); end

  def validate_compatibility(); end

  def validate_cop_options(); end

  def validate_exclude_limit_option(); end

  def validate_parallel(); end

  def validate_parallel_with_combo_option(); end
end

class RuboCop::OptionsValidator
  def self.validate_cop_list(names); end
end

module RuboCop::PathUtil
end

module RuboCop::PathUtil
  def self.absolute?(path); end

  def self.chdir(dir, &block); end

  def self.hidden_dir?(path); end

  def self.hidden_file_in_not_hidden_dir?(pattern, path); end

  def self.match_path?(pattern, path); end

  def self.pwd(); end

  def self.relative_path(path, base_dir=T.unsafe(nil)); end

  def self.reset_pwd(); end

  def self.smart_path(path); end
end

module RuboCop::Platform
end

module RuboCop::Platform
  def self.windows?(); end
end

class RuboCop::ProcessedSource
  def [](*args); end

  def ast(); end

  def ast_with_comments(); end

  def buffer(); end

  def checksum(); end

  def comment_config(); end

  def commented?(source_range); end

  def comments(); end

  def comments_before_line(line); end

  def current_line(token); end

  def diagnostics(); end

  def disabled_line_ranges(); end

  def each_comment(); end

  def each_token(); end

  def file_path(); end

  def find_comment(); end

  def find_token(); end

  def following_line(token); end

  def initialize(source, ruby_version, path=T.unsafe(nil)); end

  def line_indentation(line_number); end

  def lines(); end

  def parser_error(); end

  def path(); end

  def preceding_line(token); end

  def raw_source(); end

  def ruby_version(); end

  def start_with?(string); end

  def tokens(); end

  def valid_syntax?(); end
  STRING_SOURCE_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::ProcessedSource
  def self.from_file(path, ruby_version); end
end

class RuboCop::RemoteConfig
  def file(); end

  def inherit_from_remote(file, path); end

  def initialize(url, base_dir); end

  def uri(); end
  CACHE_LIFETIME = ::T.let(nil, ::T.untyped)
end

class RuboCop::RemoteConfig
end

class RuboCop::ResultCache
  def initialize(file, team, options, config_store, cache_root=T.unsafe(nil)); end

  def load(); end

  def save(offenses); end

  def valid?(); end
  NON_CHANGING = ::T.let(nil, ::T.untyped)
end

class RuboCop::ResultCache
  def self.allow_symlinks_in_cache_location?(config_store); end

  def self.cache_root(config_store); end

  def self.cleanup(config_store, verbose, cache_root=T.unsafe(nil)); end

  def self.inhibit_cleanup(); end

  def self.inhibit_cleanup=(inhibit_cleanup); end

  def self.source_checksum(); end

  def self.source_checksum=(source_checksum); end
end

class RuboCop::Runner
  def aborting=(aborting); end

  def aborting?(); end

  def errors(); end

  def initialize(options, config_store); end

  def run(paths); end

  def warnings(); end
  MAX_ITERATIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Runner::InfiniteCorrectionLoop
  def initialize(path, offenses); end

  def offenses(); end
end

class RuboCop::Runner::InfiniteCorrectionLoop
end

class RuboCop::Runner
end

class RuboCop::StringInterpreter
  STRING_ESCAPES = ::T.let(nil, ::T.untyped)
  STRING_ESCAPE_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::StringInterpreter
  def self.interpret(string); end
end

module RuboCop::StringUtil
end

module RuboCop::StringUtil
  def self.similarity(string_a, string_b); end
end

class RuboCop::TargetFinder
  def all_cops_include(); end

  def configured_include?(file); end

  def debug?(); end

  def excluded_dirs(base_dir); end

  def fail_fast?(); end

  def find(args); end

  def find_files(base_dir, flags); end

  def force_exclusion?(); end

  def included_file?(file); end

  def initialize(config_store, options=T.unsafe(nil)); end

  def process_explicit_path(path); end

  def ruby_executable?(file); end

  def ruby_extension?(file); end

  def ruby_extensions(); end

  def ruby_file?(file); end

  def ruby_filename?(file); end

  def ruby_filenames(); end

  def ruby_interpreters(file); end

  def stdin?(); end

  def target_files_in_dir(base_dir=T.unsafe(nil)); end

  def to_inspect?(file, hidden_files, base_dir_config); end

  def toplevel_dirs(base_dir, flags); end
end

class RuboCop::TargetFinder
end

class RuboCop::TargetRuby
  def initialize(config); end

  def rubocop_version_with_support(); end

  def source(); end

  def supported?(); end

  def version(); end
  DEFAULT_VERSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby::BundlerLockFile
end

class RuboCop::TargetRuby::BundlerLockFile
end

class RuboCop::TargetRuby::Default
end

class RuboCop::TargetRuby::Default
end

class RuboCop::TargetRuby::RuboCopConfig
end

class RuboCop::TargetRuby::RuboCopConfig
end

class RuboCop::TargetRuby::RubyVersionFile
  FILENAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby::RubyVersionFile
end

class RuboCop::TargetRuby::Source
  def initialize(config); end

  def name(); end

  def version(); end
end

class RuboCop::TargetRuby::Source
end

class RuboCop::TargetRuby
  def self.supported_versions(); end
end

class RuboCop::Token
  def begin_pos(); end

  def column(); end

  def comma?(); end

  def comment?(); end

  def end?(); end

  def end_pos(); end

  def equal_sign?(); end

  def initialize(pos, type, text); end

  def left_array_bracket?(); end

  def left_brace?(); end

  def left_bracket?(); end

  def left_curly_brace?(); end

  def left_parens?(); end

  def left_ref_bracket?(); end

  def line(); end

  def pos(); end

  def rescue_modifier?(); end

  def right_bracket?(); end

  def right_curly_brace?(); end

  def right_parens?(); end

  def semicolon?(); end

  def space_after?(); end

  def space_before?(); end

  def text(); end

  def type(); end
end

class RuboCop::Token
  def self.from_parser_token(parser_token); end
end

class RuboCop::ValidationError
end

class RuboCop::ValidationError
end

module RuboCop::Version
  MSG = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
end

module RuboCop::Version
  def self.version(debug=T.unsafe(nil)); end
end

class RuboCop::Warning
end

class RuboCop::Warning
end

module RuboCop::YAMLDuplicationChecker
end

module RuboCop::YAMLDuplicationChecker
  def self.check(yaml_string, filename, &on_duplicated); end
end

module RuboCop
end

module RubyDep
  PROJECT_URL = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class RubyDep::NullLogger
  LOG_LEVELS = ::T.let(nil, ::T.untyped)
end

class RubyDep::RubyVersion
  VERSION_INFO = ::T.let(nil, ::T.untyped)
end

class RubyDep::Travis::RubyVersion
  REGEXP = ::T.let(nil, ::T.untyped)
end

class RubyDep::Warning
  DISABLING_ENVIRONMENT_VAR = ::T.let(nil, ::T.untyped)
  NOTICE_BUGGY_ALTERNATIVE = ::T.let(nil, ::T.untyped)
  NOTICE_HOW_TO_DISABLE = ::T.let(nil, ::T.untyped)
  NOTICE_OPEN_ISSUE = ::T.let(nil, ::T.untyped)
  NOTICE_RECOMMENDATION = ::T.let(nil, ::T.untyped)
  PREFIX = ::T.let(nil, ::T.untyped)
  WARNING = ::T.let(nil, ::T.untyped)
end

class RubyLex
  include ::RubyToken
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def char_no(); end

  def each_top_level_statement(); end

  def eof?(); end

  def exception_on_syntax_error(); end

  def exception_on_syntax_error=(exception_on_syntax_error); end

  def get_readed(); end

  def getc(); end

  def getc_of_rests(); end

  def gets(); end

  def identify_comment(); end

  def identify_gvar(); end

  def identify_here_document(); end

  def identify_identifier(); end

  def identify_number(); end

  def identify_quotation(); end

  def identify_string(ltype, quoted=T.unsafe(nil)); end

  def identify_string_dvar(); end

  def indent(); end

  def initialize_input(); end

  def lex(); end

  def lex_init(); end

  def lex_int2(); end

  def line_no(); end

  def peek(i=T.unsafe(nil)); end

  def peek_equal?(str); end

  def peek_match?(regexp); end

  def prompt(); end

  def read_escape(); end

  def readed_auto_clean_up(); end

  def readed_auto_clean_up=(readed_auto_clean_up); end

  def seek(); end

  def set_input(io, p=T.unsafe(nil), &block); end

  def set_prompt(p=T.unsafe(nil), &block); end

  def skip_space(); end

  def skip_space=(skip_space); end

  def token(); end

  def ungetc(c=T.unsafe(nil)); end
  DEINDENT_CLAUSE = ::T.let(nil, ::T.untyped)
  DLtype2Token = ::T.let(nil, ::T.untyped)
  ENINDENT_CLAUSE = ::T.let(nil, ::T.untyped)
  Ltype2Token = ::T.let(nil, ::T.untyped)
  PERCENT_LTYPE = ::T.let(nil, ::T.untyped)
  PERCENT_PAREN = ::T.let(nil, ::T.untyped)
end

class RubyLex::AlreadyDefinedToken
end

class RubyLex::AlreadyDefinedToken
end

class RubyLex::SyntaxError
end

class RubyLex::SyntaxError
end

class RubyLex::TerminateLineInput
end

class RubyLex::TerminateLineInput
end

class RubyLex::TkReading2TokenDuplicateError
end

class RubyLex::TkReading2TokenDuplicateError
end

class RubyLex::TkReading2TokenNoKey
end

class RubyLex::TkReading2TokenNoKey
end

class RubyLex::TkSymbol2TokenNoKey
end

class RubyLex::TkSymbol2TokenNoKey
end

class RubyLex
  extend ::Exception2MessageMapper
  def self.debug?(); end

  def self.debug_level(); end

  def self.debug_level=(debug_level); end

  def self.included(mod); end
end

module RubyToken
  def Token(token, value=T.unsafe(nil)); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  TkReading2Token = ::T.let(nil, ::T.untyped)
  TkSymbol2Token = ::T.let(nil, ::T.untyped)
  TokenDefinitions = ::T.let(nil, ::T.untyped)
end

class RubyToken::TkALIAS
end

class RubyToken::TkALIAS
end

class RubyToken::TkAMPER
end

class RubyToken::TkAMPER
end

class RubyToken::TkAND
end

class RubyToken::TkAND
end

class RubyToken::TkANDOP
end

class RubyToken::TkANDOP
end

class RubyToken::TkAREF
end

class RubyToken::TkAREF
end

class RubyToken::TkASET
end

class RubyToken::TkASET
end

class RubyToken::TkASSIGN
end

class RubyToken::TkASSIGN
end

class RubyToken::TkASSOC
end

class RubyToken::TkASSOC
end

class RubyToken::TkAT
end

class RubyToken::TkAT
end

class RubyToken::TkBACKQUOTE
end

class RubyToken::TkBACKQUOTE
end

class RubyToken::TkBACKSLASH
end

class RubyToken::TkBACKSLASH
end

class RubyToken::TkBACK_REF
end

class RubyToken::TkBACK_REF
end

class RubyToken::TkBEGIN
end

class RubyToken::TkBEGIN
end

class RubyToken::TkBITAND
end

class RubyToken::TkBITAND
end

class RubyToken::TkBITNOT
end

class RubyToken::TkBITNOT
end

class RubyToken::TkBITOR
end

class RubyToken::TkBITOR
end

class RubyToken::TkBITXOR
end

class RubyToken::TkBITXOR
end

class RubyToken::TkBREAK
end

class RubyToken::TkBREAK
end

class RubyToken::TkCASE
end

class RubyToken::TkCASE
end

class RubyToken::TkCLASS
end

class RubyToken::TkCLASS
end

class RubyToken::TkCMP
end

class RubyToken::TkCMP
end

class RubyToken::TkCOLON
end

class RubyToken::TkCOLON
end

class RubyToken::TkCOLON2
end

class RubyToken::TkCOLON2
end

class RubyToken::TkCOLON3
end

class RubyToken::TkCOLON3
end

class RubyToken::TkCOMMA
end

class RubyToken::TkCOMMA
end

class RubyToken::TkCOMMENT
end

class RubyToken::TkCOMMENT
end

class RubyToken::TkCONSTANT
end

class RubyToken::TkCONSTANT
end

class RubyToken::TkCVAR
end

class RubyToken::TkCVAR
end

class RubyToken::TkDEF
end

class RubyToken::TkDEF
end

class RubyToken::TkDEFINED
end

class RubyToken::TkDEFINED
end

class RubyToken::TkDIV
end

class RubyToken::TkDIV
end

class RubyToken::TkDO
end

class RubyToken::TkDO
end

class RubyToken::TkDOLLAR
end

class RubyToken::TkDOLLAR
end

class RubyToken::TkDOT
end

class RubyToken::TkDOT
end

class RubyToken::TkDOT2
end

class RubyToken::TkDOT2
end

class RubyToken::TkDOT3
end

class RubyToken::TkDOT3
end

class RubyToken::TkDREGEXP
end

class RubyToken::TkDREGEXP
end

class RubyToken::TkDSTRING
end

class RubyToken::TkDSTRING
end

class RubyToken::TkDXSTRING
end

class RubyToken::TkDXSTRING
end

class RubyToken::TkELSE
end

class RubyToken::TkELSE
end

class RubyToken::TkELSIF
end

class RubyToken::TkELSIF
end

class RubyToken::TkEND
end

class RubyToken::TkEND
end

class RubyToken::TkEND_OF_SCRIPT
end

class RubyToken::TkEND_OF_SCRIPT
end

class RubyToken::TkENSURE
end

class RubyToken::TkENSURE
end

class RubyToken::TkEQ
end

class RubyToken::TkEQ
end

class RubyToken::TkEQQ
end

class RubyToken::TkEQQ
end

class RubyToken::TkError
end

class RubyToken::TkError
end

class RubyToken::TkFALSE
end

class RubyToken::TkFALSE
end

class RubyToken::TkFID
end

class RubyToken::TkFID
end

class RubyToken::TkFLOAT
end

class RubyToken::TkFLOAT
end

class RubyToken::TkFOR
end

class RubyToken::TkFOR
end

class RubyToken::TkGEQ
end

class RubyToken::TkGEQ
end

class RubyToken::TkGT
end

class RubyToken::TkGT
end

class RubyToken::TkGVAR
end

class RubyToken::TkGVAR
end

class RubyToken::TkIDENTIFIER
end

class RubyToken::TkIDENTIFIER
end

class RubyToken::TkIF
end

class RubyToken::TkIF
end

class RubyToken::TkIF_MOD
end

class RubyToken::TkIF_MOD
end

class RubyToken::TkIN
end

class RubyToken::TkIN
end

class RubyToken::TkINTEGER
end

class RubyToken::TkINTEGER
end

class RubyToken::TkIVAR
end

class RubyToken::TkIVAR
end

class RubyToken::TkId
  def initialize(seek, line_no, char_no, name); end

  def name(); end
end

class RubyToken::TkId
end

class RubyToken::TkLBRACE
end

class RubyToken::TkLBRACE
end

class RubyToken::TkLBRACK
end

class RubyToken::TkLBRACK
end

class RubyToken::TkLEQ
end

class RubyToken::TkLEQ
end

class RubyToken::TkLPAREN
end

class RubyToken::TkLPAREN
end

class RubyToken::TkLSHFT
end

class RubyToken::TkLSHFT
end

class RubyToken::TkLT
end

class RubyToken::TkLT
end

class RubyToken::TkMATCH
end

class RubyToken::TkMATCH
end

class RubyToken::TkMINUS
end

class RubyToken::TkMINUS
end

class RubyToken::TkMOD
end

class RubyToken::TkMOD
end

class RubyToken::TkMODULE
end

class RubyToken::TkMODULE
end

class RubyToken::TkMULT
end

class RubyToken::TkMULT
end

class RubyToken::TkNEQ
end

class RubyToken::TkNEQ
end

class RubyToken::TkNEXT
end

class RubyToken::TkNEXT
end

class RubyToken::TkNIL
end

class RubyToken::TkNIL
end

class RubyToken::TkNL
end

class RubyToken::TkNL
end

class RubyToken::TkNMATCH
end

class RubyToken::TkNMATCH
end

class RubyToken::TkNOT
end

class RubyToken::TkNOT
end

class RubyToken::TkNOTOP
end

class RubyToken::TkNOTOP
end

class RubyToken::TkNTH_REF
end

class RubyToken::TkNTH_REF
end

class RubyToken::TkNode
  def node(); end
end

class RubyToken::TkNode
end

class RubyToken::TkOPASGN
  def initialize(seek, line_no, char_no, op); end

  def op(); end
end

class RubyToken::TkOPASGN
end

class RubyToken::TkOR
end

class RubyToken::TkOR
end

class RubyToken::TkOROP
end

class RubyToken::TkOROP
end

class RubyToken::TkOp
  def name(); end

  def name=(name); end
end

class RubyToken::TkOp
end

class RubyToken::TkPLUS
end

class RubyToken::TkPLUS
end

class RubyToken::TkPOW
end

class RubyToken::TkPOW
end

class RubyToken::TkQUESTION
end

class RubyToken::TkQUESTION
end

class RubyToken::TkRBRACE
end

class RubyToken::TkRBRACE
end

class RubyToken::TkRBRACK
end

class RubyToken::TkRBRACK
end

class RubyToken::TkRD_COMMENT
end

class RubyToken::TkRD_COMMENT
end

class RubyToken::TkREDO
end

class RubyToken::TkREDO
end

class RubyToken::TkREGEXP
end

class RubyToken::TkREGEXP
end

class RubyToken::TkRESCUE
end

class RubyToken::TkRESCUE
end

class RubyToken::TkRETRY
end

class RubyToken::TkRETRY
end

class RubyToken::TkRETURN
end

class RubyToken::TkRETURN
end

class RubyToken::TkRPAREN
end

class RubyToken::TkRPAREN
end

class RubyToken::TkRSHFT
end

class RubyToken::TkRSHFT
end

class RubyToken::TkSELF
end

class RubyToken::TkSELF
end

class RubyToken::TkSEMICOLON
end

class RubyToken::TkSEMICOLON
end

class RubyToken::TkSPACE
end

class RubyToken::TkSPACE
end

class RubyToken::TkSTAR
end

class RubyToken::TkSTAR
end

class RubyToken::TkSTRING
end

class RubyToken::TkSTRING
end

class RubyToken::TkSUPER
end

class RubyToken::TkSUPER
end

class RubyToken::TkSYMBEG
end

class RubyToken::TkSYMBEG
end

class RubyToken::TkSYMBOL
end

class RubyToken::TkSYMBOL
end

class RubyToken::TkTHEN
end

class RubyToken::TkTHEN
end

class RubyToken::TkTRUE
end

class RubyToken::TkTRUE
end

class RubyToken::TkUMINUS
end

class RubyToken::TkUMINUS
end

class RubyToken::TkUNDEF
end

class RubyToken::TkUNDEF
end

class RubyToken::TkUNLESS
end

class RubyToken::TkUNLESS
end

class RubyToken::TkUNLESS_MOD
end

class RubyToken::TkUNLESS_MOD
end

class RubyToken::TkUNTIL
end

class RubyToken::TkUNTIL
end

class RubyToken::TkUNTIL_MOD
end

class RubyToken::TkUNTIL_MOD
end

class RubyToken::TkUPLUS
end

class RubyToken::TkUPLUS
end

class RubyToken::TkUnknownChar
  def initialize(seek, line_no, char_no, id); end

  def name(); end
end

class RubyToken::TkUnknownChar
end

class RubyToken::TkVal
  def initialize(seek, line_no, char_no, value=T.unsafe(nil)); end

  def value(); end
end

class RubyToken::TkVal
end

class RubyToken::TkWHEN
end

class RubyToken::TkWHEN
end

class RubyToken::TkWHILE
end

class RubyToken::TkWHILE
end

class RubyToken::TkWHILE_MOD
end

class RubyToken::TkWHILE_MOD
end

class RubyToken::TkXSTRING
end

class RubyToken::TkXSTRING
end

class RubyToken::TkYIELD
end

class RubyToken::TkYIELD
end

class RubyToken::Tk__FILE__
end

class RubyToken::Tk__FILE__
end

class RubyToken::Tk__LINE__
end

class RubyToken::Tk__LINE__
end

class RubyToken::TkfLBRACE
end

class RubyToken::TkfLBRACE
end

class RubyToken::TkfLBRACK
end

class RubyToken::TkfLBRACK
end

class RubyToken::TkfLPAREN
end

class RubyToken::TkfLPAREN
end

class RubyToken::TklBEGIN
end

class RubyToken::TklBEGIN
end

class RubyToken::TklEND
end

class RubyToken::TklEND
end

class RubyToken::Token
  def char_no(); end

  def initialize(seek, line_no, char_no); end

  def line_no(); end

  def seek(); end
end

class RubyToken::Token
end

module RubyToken
  def self.def_token(token_n, super_token=T.unsafe(nil), reading=T.unsafe(nil), *opts); end
end

module RubyVM::AbstractSyntaxTree
end

class RubyVM::AbstractSyntaxTree::Node
  def children(); end

  def first_column(); end

  def first_lineno(); end

  def last_column(); end

  def last_lineno(); end

  def pretty_print_children(q, names=T.unsafe(nil)); end

  def type(); end
end

class RubyVM::AbstractSyntaxTree::Node
end

module RubyVM::AbstractSyntaxTree
  def self.of(_); end

  def self.parse(_); end

  def self.parse_file(_); end
end

class RubyVM::InstructionSequence
  def absolute_path(); end

  def base_label(); end

  def disasm(); end

  def disassemble(); end

  def each_child(); end

  def eval(); end

  def first_lineno(); end

  def label(); end

  def path(); end

  def to_a(); end

  def to_binary(*_); end

  def trace_points(); end
end

class RubyVM::InstructionSequence
  extend ::Bootsnap::CompileCache::ISeq::InstructionSequenceMixin
  def self.compile(*_); end

  def self.compile_file(*_); end

  def self.compile_option(); end

  def self.compile_option=(compile_option); end

  def self.disasm(_); end

  def self.disassemble(_); end

  def self.load_from_binary(_); end

  def self.load_from_binary_extra_data(_); end

  def self.of(_); end
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(*_); end

  def self.resume(); end
end

class RubyVM
  def self.resolve_feature_path(_); end

  def self.stat(*_); end
end

module SassC
  VERSION = ::T.let(nil, ::T.untyped)
end

class SassC::Engine
  OUTPUT_STYLES = ::T.let(nil, ::T.untyped)
end

module SassC::Native
  SassInputStyle = ::T.let(nil, ::T.untyped)
  SassOutputStyle = ::T.let(nil, ::T.untyped)
  SassSeparator = ::T.let(nil, ::T.untyped)
  SassTag = ::T.let(nil, ::T.untyped)
end

module SassC::Rails
  VERSION = ::T.let(nil, ::T.untyped)
end

class SassC::Rails::Importer
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  GLOB = ::T.let(nil, ::T.untyped)
  PREFIXS = ::T.let(nil, ::T.untyped)
end

class SassC::Script::Value::Bool
  FALSE = ::T.let(nil, ::T.untyped)
  TRUE = ::T.let(nil, ::T.untyped)
end

class SassC::Script::Value::Number
  CONVERSION_TABLE = ::T.let(nil, ::T.untyped)
  MUTUALLY_CONVERTIBLE = ::T.let(nil, ::T.untyped)
  NO_UNITS = ::T.let(nil, ::T.untyped)
  OPERATIONS = ::T.let(nil, ::T.untyped)
end

module SassC::Script::ValueConversion
  SEPARATORS = ::T.let(nil, ::T.untyped)
end

module SassC::Util
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_VERSION_COMPONENTS = ::T.let(nil, ::T.untyped)
end

ScanError = StringScanner::Error

module SecureRandom
  BASE36_ALPHABET = ::T.let(nil, ::T.untyped)
  BASE58_ALPHABET = ::T.let(nil, ::T.untyped)
end

module SecureRandom
  def self.bytes(n); end
end

module Selenium::WebDriver
  VERSION = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Chrome::Bridge
  COMMANDS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Chrome::Options
  KEY = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::DriverExtensions::Rotatable
  ORIENTATIONS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Error
  DEPRECATED_ERRORS = ::T.let(nil, ::T.untyped)
  ERRORS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Firefox
  DEFAULT_ASSUME_UNTRUSTED_ISSUER = ::T.let(nil, ::T.untyped)
  DEFAULT_ENABLE_NATIVE_EVENTS = ::T.let(nil, ::T.untyped)
  DEFAULT_LOAD_NO_FOCUS_LIB = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  DEFAULT_SECURE_SSL = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Binary
  NO_FOCUS_LIBRARIES = ::T.let(nil, ::T.untyped)
  NO_FOCUS_LIBRARY_NAME = ::T.let(nil, ::T.untyped)
  QUIT_TIMEOUT = ::T.let(nil, ::T.untyped)
  WAIT_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Extension
  NAMESPACE = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Launcher
  SOCKET_LOCK_TIMEOUT = ::T.let(nil, ::T.untyped)
  STABLE_CONNECTION_TIMEOUT = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Firefox::Marionette::Bridge
  COMMANDS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Options
  KEY = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Profile
  VALID_PREFERENCE_TYPES = ::T.let(nil, ::T.untyped)
  WEBDRIVER_EXTENSION_PATH = ::T.let(nil, ::T.untyped)
  WEBDRIVER_PREFS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::HTML5::SharedWebStorage
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Selenium::WebDriver::IE::Options
  CAPABILITIES = ::T.let(nil, ::T.untyped)
  KEY = ::T.let(nil, ::T.untyped)
  SCROLL_BOTTOM = ::T.let(nil, ::T.untyped)
  SCROLL_TOP = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Interactions
  KEY = ::T.let(nil, ::T.untyped)
  NONE = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  SOURCE_TYPES = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::Interaction
  PAUSE = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::KeyInput
  SUBTYPES = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::PointerInput
  KIND = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::PointerMove
  ORIGINS = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  VIEWPORT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::PointerPress
  BUTTONS = ::T.let(nil, ::T.untyped)
  DIRECTIONS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Keyboard
  MODIFIERS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Keys
  KEYS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Manager
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::PortProber
  IGNORED_ERRORS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Proxy
  ALLOWED = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::Bridge
  COMMANDS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::Capabilities
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::Http::Common
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  DEFAULT_HEADERS = ::T.let(nil, ::T.untyped)
  MAX_REDIRECTS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::Http::Default
  MAX_RETRIES = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::OSS::Bridge
  COMMANDS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::Response
  STACKTRACE_KEY = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::W3C::Bridge
  COMMANDS = ::T.let(nil, ::T.untyped)
  ESCAPE_CSS_REGEXP = ::T.let(nil, ::T.untyped)
  QUIT_ERRORS = ::T.let(nil, ::T.untyped)
  UNICODE_CODE_POINT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::W3C::Capabilities
  EXTENSION_CAPABILITY_PATTERN = ::T.let(nil, ::T.untyped)
  KNOWN = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Safari::Bridge
  COMMANDS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::SearchContext
  FINDERS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Service
  SOCKET_LOCK_TIMEOUT = ::T.let(nil, ::T.untyped)
  START_TIMEOUT = ::T.let(nil, ::T.untyped)
  STOP_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::SocketPoller
  CONNECTED_ERRORS = ::T.let(nil, ::T.untyped)
  CONNECT_TIMEOUT = ::T.let(nil, ::T.untyped)
  NOT_CONNECTED_ERRORS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Support::Color
  HEX3_PATTERN = ::T.let(nil, ::T.untyped)
  HEX_PATTERN = ::T.let(nil, ::T.untyped)
  HSLA_PATTERN = ::T.let(nil, ::T.untyped)
  HSL_PATTERN = ::T.let(nil, ::T.untyped)
  RGBA_PATTERN = ::T.let(nil, ::T.untyped)
  RGBA_PCT_PATTERN = ::T.let(nil, ::T.untyped)
  RGB_PATTERN = ::T.let(nil, ::T.untyped)
  RGB_PCT_PATTERN = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::TouchScreen
  FLICK_SPEED = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Wait
  DEFAULT_INTERVAL = ::T.let(nil, ::T.untyped)
  DEFAULT_TIMEOUT = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Zipper
  EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

module Shellwords
end

module Shellwords
  def self.escape(str); end

  def self.join(array); end

  def self.shellescape(str); end

  def self.shelljoin(array); end

  def self.shellsplit(line); end

  def self.shellwords(line); end

  def self.split(line); end
end

class SignalException
  def signm(); end

  def signo(); end
end

module SingleForwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_single_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_single_delegators(accessor, *methods); end

  def delegate(hash); end

  def single_delegate(hash); end
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

module Skiptrace
  VERSION = ::T.let(nil, ::T.untyped)
end

module Slim
  VERSION = ::T.let(nil, ::T.untyped)
end

class Slim::Controls
  IF_RE = ::T.let(nil, ::T.untyped)
end

class Slim::DoInserter
  BLOCK_REGEX = ::T.let(nil, ::T.untyped)
end

class Slim::EndInserter
  ELSE_RE = ::T.let(nil, ::T.untyped)
  END_RE = ::T.let(nil, ::T.untyped)
  IF_RE = ::T.let(nil, ::T.untyped)
end

class Slim::Splat::Builder
  INVALID_ATTRIBUTE_NAME_REGEX = ::T.let(nil, ::T.untyped)
end

class Socket
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Solargraph
  VERSION = ::T.let(nil, ::T.untyped)
  VIEWS_PATH = ::T.let(nil, ::T.untyped)
  YARDOC_PATH = ::T.let(nil, ::T.untyped)
  YARD_EXTENSION_FILE = ::T.let(nil, ::T.untyped)
end

class Solargraph::ApiMap
  include ::Solargraph::ApiMap::SourceToYard
  include ::Solargraph::ApiMap::BundlerMethods
  def bundled?(filename); end

  def catalog(bundle); end

  def clip(cursor); end

  def clip_at(filename, position); end

  def cursor_at(filename, position); end

  def document(path); end

  def document_symbols(filename); end

  def get_class_variable_pins(namespace); end

  def get_complex_type_methods(type, context=T.unsafe(nil), internal=T.unsafe(nil)); end

  def get_constants(namespace, *contexts); end

  def get_global_variable_pins(); end

  def get_instance_variable_pins(namespace, scope=T.unsafe(nil)); end

  def get_method_stack(fqns, name, scope: T.unsafe(nil)); end

  def get_methods(fqns, scope: T.unsafe(nil), visibility: T.unsafe(nil), deep: T.unsafe(nil)); end

  def get_path_pins(path); end

  def get_path_suggestions(path); end

  def get_symbols(); end

  def implicit(); end

  def index(pins); end

  def initialize(pins: T.unsafe(nil)); end

  def local_path_hash(); end

  def locate_pins(location); end

  def map(source); end

  def named_macro(name); end

  def namespace_exists?(name, context=T.unsafe(nil)); end

  def namespaces(); end

  def pins(); end

  def qualify(namespace, context=T.unsafe(nil)); end

  def query_symbols(query); end

  def require_reference_at(location); end

  def search(query); end

  def source_map(filename); end

  def source_maps(); end

  def super_and_sub?(sup, sub); end

  def unresolved_requires(); end

  def workspaced?(filename); end
end

module Solargraph::ApiMap::BundlerMethods
end

module Solargraph::ApiMap::BundlerMethods
  def self.require_from_bundle(directory); end

  def self.reset_require_from_bundle(); end
end

class Solargraph::ApiMap::Cache
  def clear(); end

  def empty?(); end

  def get_constants(namespace, context); end

  def get_methods(fqns, scope, visibility, deep); end

  def get_qualified_namespace(name, context); end

  def get_receiver_definition(path); end

  def receiver_defined?(path); end

  def set_constants(namespace, context, value); end

  def set_methods(fqns, scope, visibility, deep, value); end

  def set_qualified_namespace(name, context, value); end

  def set_receiver_definition(path, pin); end
end

class Solargraph::ApiMap::Cache
end

module Solargraph::ApiMap::SourceToYard
  def code_object_at(path); end

  def code_object_paths(); end

  def rake_yard(store); end
end

module Solargraph::ApiMap::SourceToYard
end

class Solargraph::ApiMap::Store
  def block_pins(); end

  def domains(fqns); end

  def get_class_variables(fqns); end

  def get_constants(fqns, visibility=T.unsafe(nil)); end

  def get_extends(fqns); end

  def get_includes(fqns); end

  def get_instance_variables(fqns, scope=T.unsafe(nil)); end

  def get_methods(fqns, scope: T.unsafe(nil), visibility: T.unsafe(nil)); end

  def get_path_pins(path); end

  def get_superclass(fqns); end

  def get_symbols(); end

  def initialize(pins=T.unsafe(nil)); end

  def method_pins(); end

  def named_macros(); end

  def namespace_exists?(fqns); end

  def namespace_pins(); end

  def namespaces(); end

  def pins(); end
end

class Solargraph::ApiMap::Store
end

class Solargraph::ApiMap
  def self.keywords(); end

  def self.load(directory); end
end

class Solargraph::Bundle
  def initialize(workspace: T.unsafe(nil), opened: T.unsafe(nil)); end

  def opened(); end

  def sources(); end

  def workspace(); end
end

class Solargraph::Bundle
end

class Solargraph::BundleNotFoundError
end

class Solargraph::BundleNotFoundError
end

class Solargraph::ComplexType
  def [](index); end

  def all?(&block); end

  def each(&block); end

  def first(); end

  def initialize(types=T.unsafe(nil)); end

  def length(); end

  def map(&block); end

  def method_missing(name, *args, &block); end

  def qualify(api_map, context=T.unsafe(nil)); end

  def select(&block); end

  def self_to(dst); end

  def selfy?(); end
  BOOLEAN = ::T.let(nil, ::T.untyped)
  NIL = ::T.let(nil, ::T.untyped)
  ROOT = ::T.let(nil, ::T.untyped)
  SELF = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
end

module Solargraph::ComplexType::TypeMethods
  def ==(other); end

  def defined?(); end

  def duck_type?(); end

  def fixed_parameters?(); end

  def hash_parameters?(); end

  def key_types(); end

  def list_parameters?(); end

  def name(); end

  def namespace(); end

  def nil_type?(); end

  def parameters?(); end

  def qualify(api_map, context=T.unsafe(nil)); end

  def rooted?(); end

  def scope(); end

  def substring(); end

  def subtypes(); end

  def tag(); end

  def undefined?(); end

  def value_types(); end

  def void?(); end
end

module Solargraph::ComplexType::TypeMethods
end

class Solargraph::ComplexType::UniqueType
  include ::Solargraph::ComplexType::TypeMethods
  def initialize(name, substring=T.unsafe(nil)); end

  def self_to(dst); end

  def selfy?(); end
  BOOLEAN = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

class Solargraph::ComplexType::UniqueType
end

class Solargraph::ComplexType
  def self.parse(*strings, partial: T.unsafe(nil)); end

  def self.try_parse(*strings); end
end

class Solargraph::ComplexTypeError
end

class Solargraph::ComplexTypeError
end

module Solargraph::Convention
end

class Solargraph::Convention::Base
  def environ(); end

  def match?(source); end

  def process(); end
  EMPTY_ENVIRON = ::T.let(nil, ::T.untyped)
end

class Solargraph::Convention::Base
end

class Solargraph::Convention::Gemfile
end

class Solargraph::Convention::Gemfile
end

class Solargraph::Convention::Gemspec
end

class Solargraph::Convention::Gemspec
end

class Solargraph::Convention::Rspec
end

class Solargraph::Convention::Rspec
end

module Solargraph::Convention
  def self.for(source); end

  def self.register(convention); end
end

module Solargraph::CoreFills
  KEYWORDS = ::T.let(nil, ::T.untyped)
  OVERRIDES = ::T.let(nil, ::T.untyped)
end

Solargraph::CoreFills::Override = Solargraph::Pin::Reference::Override

module Solargraph::CoreFills
end

module Solargraph::Diagnostics
end

class Solargraph::Diagnostics::Base
  def args(); end

  def diagnose(source, api_map); end

  def initialize(*args); end
end

class Solargraph::Diagnostics::Base
end

class Solargraph::Diagnostics::RequireNotFound
end

class Solargraph::Diagnostics::RequireNotFound
end

class Solargraph::Diagnostics::Rubocop
  include ::Solargraph::Diagnostics::RubocopHelpers
  def diagnose(source, _api_map); end
  SEVERITIES = ::T.let(nil, ::T.untyped)
end

class Solargraph::Diagnostics::Rubocop
end

module Solargraph::Diagnostics::RubocopHelpers
end

module Solargraph::Diagnostics::RubocopHelpers
  def self.find_rubocop_file(filename); end

  def self.fix_drive_letter(path); end

  def self.generate_options(filename, code); end

  def self.redirect_stdout(); end
end

module Solargraph::Diagnostics::Severities
  ERROR = ::T.let(nil, ::T.untyped)
  HINT = ::T.let(nil, ::T.untyped)
  INFORMATION = ::T.let(nil, ::T.untyped)
  WARNING = ::T.let(nil, ::T.untyped)
end

module Solargraph::Diagnostics::Severities
end

class Solargraph::Diagnostics::TypeCheck
end

class Solargraph::Diagnostics::TypeCheck
end

class Solargraph::Diagnostics::UpdateErrors
end

class Solargraph::Diagnostics::UpdateErrors
end

module Solargraph::Diagnostics
  def self.register(name, klass); end

  def self.reporter(name); end

  def self.reporters(); end
end

class Solargraph::DiagnosticsError
end

class Solargraph::DiagnosticsError
end

class Solargraph::Documentor
  def document(); end

  def initialize(directory, rebuild: T.unsafe(nil), out: T.unsafe(nil)); end
  RDOC_GEMS = ::T.let(nil, ::T.untyped)
end

class Solargraph::Documentor
  def self.specs_from_bundle(directory); end
end

class Solargraph::Environ
  def clear(); end

  def domains(); end

  def initialize(requires: T.unsafe(nil), domains: T.unsafe(nil), overrides: T.unsafe(nil)); end

  def merge(other); end

  def overrides(); end

  def requires(); end
end

class Solargraph::Environ
end

class Solargraph::FileNotFoundError
end

class Solargraph::FileNotFoundError
end

class Solargraph::InvalidOffsetError
end

class Solargraph::InvalidOffsetError
end

module Solargraph::LanguageServer
end

module Solargraph::LanguageServer::CompletionItemKinds
  CLASS = ::T.let(nil, ::T.untyped)
  COLOR = ::T.let(nil, ::T.untyped)
  CONSTANT = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_MEMBER = ::T.let(nil, ::T.untyped)
  EVENT = ::T.let(nil, ::T.untyped)
  FIELD = ::T.let(nil, ::T.untyped)
  FILE = ::T.let(nil, ::T.untyped)
  FOLDER = ::T.let(nil, ::T.untyped)
  FUNCTION = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
  METHOD = ::T.let(nil, ::T.untyped)
  MODULE = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  PROPERTY = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
  SNIPPET = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  TYPE_PARAMETER = ::T.let(nil, ::T.untyped)
  UNIT = ::T.let(nil, ::T.untyped)
  VALUE = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module Solargraph::LanguageServer::CompletionItemKinds
end

module Solargraph::LanguageServer::ErrorCodes
  INTERNAL_ERROR = ::T.let(nil, ::T.untyped)
  INVALID_PARAMS = ::T.let(nil, ::T.untyped)
  INVALID_REQUEST = ::T.let(nil, ::T.untyped)
  METHOD_NOT_FOUND = ::T.let(nil, ::T.untyped)
  PARSE_ERROR = ::T.let(nil, ::T.untyped)
  REQUEST_CANCELLED = ::T.let(nil, ::T.untyped)
  SERVER_ERROR_END = ::T.let(nil, ::T.untyped)
  SERVER_ERROR_START = ::T.let(nil, ::T.untyped)
  SERVER_NOT_INITIALIZED = ::T.let(nil, ::T.untyped)
  UNKNOWN_ERROR_CODE = ::T.let(nil, ::T.untyped)
end

module Solargraph::LanguageServer::ErrorCodes
end

class Solargraph::LanguageServer::Host
  include ::Solargraph::LanguageServer::UriHelpers
  include ::Solargraph::Logging
  include ::Solargraph::LanguageServer::Host::Dispatch
  include ::Observable
  def allow_registration(method); end

  def can_register?(method); end

  def cancel(id); end

  def cancel?(id); end

  def catalog(); end

  def change(params); end

  def clear(id); end

  def client_capabilities(); end

  def client_capabilities=(client_capabilities); end

  def close(uri); end

  def completions_at(uri, line, column); end

  def configure(update); end

  def create(uri); end

  def default_configuration(); end

  def definitions_at(uri, line, column); end

  def delete(uri); end

  def diagnose(uri); end

  def document(query); end

  def document_symbols(uri); end

  def flush(); end

  def folders(); end

  def folding_ranges(uri); end

  def locate_pins(params); end

  def open(uri, text, version); end

  def open?(uri); end

  def open_from_disk(uri); end

  def options(); end

  def pending_requests(); end

  def prepare(directory, name=T.unsafe(nil)); end

  def prepare_folders(array); end

  def query_symbols(query); end

  def queue(message); end

  def read_text(uri); end

  def receive(request); end

  def references_from(uri, line, column, strip: T.unsafe(nil)); end

  def register_capabilities(methods); end

  def registered?(method); end

  def remove(directory); end

  def remove_folders(array); end

  def search(query); end

  def send_notification(method, params); end

  def send_request(method, params, &block); end

  def show_message(text, type=T.unsafe(nil)); end

  def show_message_request(text, type, actions, &block); end

  def signatures_at(uri, line, column); end

  def start(); end

  def stop(); end

  def stopped?(); end

  def synchronizing?(); end

  def unregister_capabilities(methods); end
end

class Solargraph::LanguageServer::Host::Cataloger
  def initialize(host); end

  def start(); end

  def stop(); end

  def stopped?(); end

  def tick(); end
end

class Solargraph::LanguageServer::Host::Cataloger
end

class Solargraph::LanguageServer::Host::Diagnoser
  def initialize(host); end

  def schedule(uri); end

  def start(); end

  def stop(); end

  def stopped?(); end

  def tick(); end
end

class Solargraph::LanguageServer::Host::Diagnoser
end

module Solargraph::LanguageServer::Host::Dispatch
  def explicit_library_for(uri); end

  def generic_library(); end

  def generic_library_for(uri); end

  def implicit_library_for(uri); end

  def libraries(); end

  def library_for(uri); end

  def sources(); end

  def update_libraries(uri); end
end

module Solargraph::LanguageServer::Host::Dispatch
end

class Solargraph::LanguageServer::Host::Sources
  include ::Observable
  include ::Solargraph::LanguageServer::UriHelpers
  def async_update(uri, updater); end

  def clear(); end

  def close(uri); end

  def find(uri); end

  def include?(uri); end

  def open(uri, text, version); end

  def open_from_disk(uri); end

  def start(); end

  def stop(); end

  def stopped?(); end

  def tick(); end

  def update(uri, updater); end
end

class Solargraph::LanguageServer::Host::Sources
end

class Solargraph::LanguageServer::Host
end

module Solargraph::LanguageServer::Message
end

class Solargraph::LanguageServer::Message::Base
  def error(); end

  def host(); end

  def id(); end

  def initialize(host, request); end

  def method(); end

  def params(); end

  def post_initialize(); end

  def process(); end

  def request(); end

  def result(); end

  def send_response(); end

  def set_error(code, message); end

  def set_result(data); end
end

class Solargraph::LanguageServer::Message::Base
end

class Solargraph::LanguageServer::Message::CancelRequest
end

class Solargraph::LanguageServer::Message::CancelRequest
end

module Solargraph::LanguageServer::Message::CompletionItem
end

class Solargraph::LanguageServer::Message::CompletionItem::Resolve
end

class Solargraph::LanguageServer::Message::CompletionItem::Resolve
end

module Solargraph::LanguageServer::Message::CompletionItem
end

class Solargraph::LanguageServer::Message::ExitNotification
end

class Solargraph::LanguageServer::Message::ExitNotification
end

module Solargraph::LanguageServer::Message::Extended
end

class Solargraph::LanguageServer::Message::Extended::CheckGemVersion
  def initialize(host, request, current: T.unsafe(nil), available: T.unsafe(nil)); end
  GEM_ZERO = ::T.let(nil, ::T.untyped)
end

class Solargraph::LanguageServer::Message::Extended::CheckGemVersion
  def self.fetcher(); end

  def self.fetcher=(obj); end
end

class Solargraph::LanguageServer::Message::Extended::Document
end

class Solargraph::LanguageServer::Message::Extended::Document
end

class Solargraph::LanguageServer::Message::Extended::DocumentGems
end

class Solargraph::LanguageServer::Message::Extended::DocumentGems
end

class Solargraph::LanguageServer::Message::Extended::DownloadCore
end

class Solargraph::LanguageServer::Message::Extended::DownloadCore
end

class Solargraph::LanguageServer::Message::Extended::Environment
end

class Solargraph::LanguageServer::Message::Extended::Environment
end

class Solargraph::LanguageServer::Message::Extended::Search
end

class Solargraph::LanguageServer::Message::Extended::Search
end

module Solargraph::LanguageServer::Message::Extended
end

class Solargraph::LanguageServer::Message::Initialize
end

class Solargraph::LanguageServer::Message::Initialize
end

class Solargraph::LanguageServer::Message::Initialized
end

class Solargraph::LanguageServer::Message::Initialized
end

class Solargraph::LanguageServer::Message::MethodNotFound
end

class Solargraph::LanguageServer::Message::MethodNotFound
end

class Solargraph::LanguageServer::Message::MethodNotImplemented
end

class Solargraph::LanguageServer::Message::MethodNotImplemented
end

class Solargraph::LanguageServer::Message::Shutdown
end

class Solargraph::LanguageServer::Message::Shutdown
end

module Solargraph::LanguageServer::Message::TextDocument
end

class Solargraph::LanguageServer::Message::TextDocument::Base
  include ::Solargraph::LanguageServer::UriHelpers
  def filename(); end
end

class Solargraph::LanguageServer::Message::TextDocument::Base
end

class Solargraph::LanguageServer::Message::TextDocument::CodeAction
end

class Solargraph::LanguageServer::Message::TextDocument::CodeAction
end

class Solargraph::LanguageServer::Message::TextDocument::Completion
  def empty_result(incomplete=T.unsafe(nil)); end
end

class Solargraph::LanguageServer::Message::TextDocument::Completion
end

class Solargraph::LanguageServer::Message::TextDocument::Definition
end

class Solargraph::LanguageServer::Message::TextDocument::Definition
end

class Solargraph::LanguageServer::Message::TextDocument::DidChange
end

class Solargraph::LanguageServer::Message::TextDocument::DidChange
end

class Solargraph::LanguageServer::Message::TextDocument::DidClose
end

class Solargraph::LanguageServer::Message::TextDocument::DidClose
end

class Solargraph::LanguageServer::Message::TextDocument::DidOpen
end

class Solargraph::LanguageServer::Message::TextDocument::DidOpen
end

class Solargraph::LanguageServer::Message::TextDocument::DidSave
end

class Solargraph::LanguageServer::Message::TextDocument::DidSave
end

class Solargraph::LanguageServer::Message::TextDocument::DocumentSymbol
  include ::Solargraph::LanguageServer::UriHelpers
end

class Solargraph::LanguageServer::Message::TextDocument::DocumentSymbol
end

class Solargraph::LanguageServer::Message::TextDocument::FoldingRange
end

class Solargraph::LanguageServer::Message::TextDocument::FoldingRange
end

class Solargraph::LanguageServer::Message::TextDocument::Formatting
  include ::Solargraph::Diagnostics::RubocopHelpers
end

class Solargraph::LanguageServer::Message::TextDocument::Formatting
end

class Solargraph::LanguageServer::Message::TextDocument::Hover
end

class Solargraph::LanguageServer::Message::TextDocument::Hover
end

class Solargraph::LanguageServer::Message::TextDocument::OnTypeFormatting
end

class Solargraph::LanguageServer::Message::TextDocument::OnTypeFormatting
end

class Solargraph::LanguageServer::Message::TextDocument::PrepareRename
end

class Solargraph::LanguageServer::Message::TextDocument::PrepareRename
end

class Solargraph::LanguageServer::Message::TextDocument::References
end

class Solargraph::LanguageServer::Message::TextDocument::References
end

class Solargraph::LanguageServer::Message::TextDocument::Rename
end

class Solargraph::LanguageServer::Message::TextDocument::Rename
end

class Solargraph::LanguageServer::Message::TextDocument::SignatureHelp
end

class Solargraph::LanguageServer::Message::TextDocument::SignatureHelp
end

module Solargraph::LanguageServer::Message::TextDocument
end

module Solargraph::LanguageServer::Message::Workspace
end

class Solargraph::LanguageServer::Message::Workspace::DidChangeConfiguration
end

class Solargraph::LanguageServer::Message::Workspace::DidChangeConfiguration
end

class Solargraph::LanguageServer::Message::Workspace::DidChangeWatchedFiles
  include ::Solargraph::LanguageServer::UriHelpers
  CHANGED = ::T.let(nil, ::T.untyped)
  CREATED = ::T.let(nil, ::T.untyped)
  DELETED = ::T.let(nil, ::T.untyped)
end

class Solargraph::LanguageServer::Message::Workspace::DidChangeWatchedFiles
end

class Solargraph::LanguageServer::Message::Workspace::DidChangeWorkspaceFolders
end

class Solargraph::LanguageServer::Message::Workspace::DidChangeWorkspaceFolders
end

class Solargraph::LanguageServer::Message::Workspace::WorkspaceSymbol
  include ::Solargraph::LanguageServer::UriHelpers
end

class Solargraph::LanguageServer::Message::Workspace::WorkspaceSymbol
end

module Solargraph::LanguageServer::Message::Workspace
end

module Solargraph::LanguageServer::Message
  def self.register(path, message_class); end

  def self.select(path); end
end

module Solargraph::LanguageServer::MessageTypes
  ERROR = ::T.let(nil, ::T.untyped)
  INFO = ::T.let(nil, ::T.untyped)
  LOG = ::T.let(nil, ::T.untyped)
  WARNING = ::T.let(nil, ::T.untyped)
end

module Solargraph::LanguageServer::MessageTypes
end

class Solargraph::LanguageServer::Request
  def initialize(id, &block); end

  def process(result); end

  def send_response(); end
end

class Solargraph::LanguageServer::Request
end

module Solargraph::LanguageServer::SymbolKinds
  ARRAY = ::T.let(nil, ::T.untyped)
  BOOLEAN = ::T.let(nil, ::T.untyped)
  CLASS = ::T.let(nil, ::T.untyped)
  CONSTANT = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_MEMBER = ::T.let(nil, ::T.untyped)
  EVENT = ::T.let(nil, ::T.untyped)
  FIELD = ::T.let(nil, ::T.untyped)
  FILE = ::T.let(nil, ::T.untyped)
  FUNCTION = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  KEY = ::T.let(nil, ::T.untyped)
  METHOD = ::T.let(nil, ::T.untyped)
  MODULE = ::T.let(nil, ::T.untyped)
  NAMESPACE = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  PACKAGE = ::T.let(nil, ::T.untyped)
  PROPERTY = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  TYPE_PARAMETER = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module Solargraph::LanguageServer::SymbolKinds
end

module Solargraph::LanguageServer::Transport
end

module Solargraph::LanguageServer::Transport::Adapter
  def closing(); end

  def opening(); end

  def receiving(data); end

  def update(); end
end

module Solargraph::LanguageServer::Transport::Adapter
end

class Solargraph::LanguageServer::Transport::DataReader
  def receive(data); end

  def set_message_handler(&block); end
end

class Solargraph::LanguageServer::Transport::DataReader
end

module Solargraph::LanguageServer::Transport
end

module Solargraph::LanguageServer::UriHelpers
end

module Solargraph::LanguageServer::UriHelpers
  def self.file_to_uri(file); end

  def self.uri_to_file(uri); end
end

module Solargraph::LanguageServer
end

class Solargraph::Library
  include ::Solargraph::Logging
  def attach(source); end

  def attached?(filename); end

  def catalog(); end

  def close(filename); end

  def completions_at(filename, line, column); end

  def contain?(filename); end

  def create(filename, text); end

  def create_from_disk(filename); end

  def current(); end

  def definitions_at(filename, line, column); end

  def delete(filename); end

  def detach(filename); end

  def diagnose(filename); end

  def document(query); end

  def document_symbols(filename); end

  def folding_ranges(filename); end

  def get_path_pins(path); end

  def initialize(workspace=T.unsafe(nil), name=T.unsafe(nil)); end

  def locate_pins(location); end

  def locate_ref(location); end

  def merge(source); end

  def name(); end

  def open?(filename); end

  def path_pins(path); end

  def query_symbols(query); end

  def read_text(filename); end

  def references_from(filename, line, column, strip: T.unsafe(nil)); end

  def search(query); end

  def signatures_at(filename, line, column); end

  def synchronized?(); end

  def workspace(); end
end

class Solargraph::Library
  def self.load(directory=T.unsafe(nil), name=T.unsafe(nil)); end
end

class Solargraph::Location
  def ==(other); end

  def filename(); end

  def initialize(filename, range); end

  def range(); end

  def to_hash(); end
end

class Solargraph::Location
end

module Solargraph::Logging
  DEFAULT_LOG_LEVEL = ::T.let(nil, ::T.untyped)
  LOG_LEVELS = ::T.let(nil, ::T.untyped)
end

module Solargraph::Logging
  def self.logger(); end
end

class Solargraph::Page
  def initialize(directory=T.unsafe(nil)); end

  def render(template, layout: T.unsafe(nil), locals: T.unsafe(nil)); end
end

class Solargraph::Page
  def self.select_template(directories, name); end
end

module Solargraph::Pin
  ROOT_PIN = ::T.let(nil, ::T.untyped)
end

class Solargraph::Pin::Attribute
  def access(); end

  def initialize(access: T.unsafe(nil), **splat); end
end

class Solargraph::Pin::Attribute
end

class Solargraph::Pin::Base
  include ::Solargraph::Pin::Common
  include ::Solargraph::Pin::Conversions
  include ::Solargraph::Pin::Documenting
  def ==(other); end

  def code_object(); end

  def completion_item_kind(); end

  def deprecated?(); end

  def directives(); end

  def docstring(); end

  def filename(); end

  def identity(); end

  def infer(api_map); end

  def initialize(location: T.unsafe(nil), closure: T.unsafe(nil), name: T.unsafe(nil), comments: T.unsafe(nil)); end

  def macros(); end

  def maybe_directives?(); end

  def nearly?(other); end

  def probe(api_map); end

  def probed=(probed); end

  def probed?(); end

  def proxied=(proxied); end

  def proxied?(); end

  def proxy(return_type); end

  def realize(api_map); end

  def return_type=(return_type); end

  def symbol_kind(); end

  def try_merge!(pin); end

  def typify(api_map); end

  def variable?(); end
end

class Solargraph::Pin::Base
end

class Solargraph::Pin::BaseMethod
  def initialize(visibility: T.unsafe(nil), **splat); end

  def parameter_names(); end

  def parameters(); end

  def visibility(); end
end

class Solargraph::Pin::BaseMethod
end

class Solargraph::Pin::BaseVariable
  include ::Solargraph::Source::NodeMethods
  def assignment(); end

  def initialize(assignment: T.unsafe(nil), **splat); end

  def nil_assignment?(); end

  def signature(); end
end

class Solargraph::Pin::BaseVariable
end

class Solargraph::Pin::Block
  def initialize(receiver: T.unsafe(nil), args: T.unsafe(nil), **splat); end

  def parameter_names(); end

  def parameters(); end

  def rebind(context); end

  def rebound?(); end

  def receiver(); end
end

class Solargraph::Pin::Block
end

class Solargraph::Pin::ClassVariable
end

class Solargraph::Pin::ClassVariable
end

class Solargraph::Pin::Closure
  def gates(); end

  def initialize(scope: T.unsafe(nil), **splat); end

  def scope(); end
end

class Solargraph::Pin::Closure
end

module Solargraph::Pin::Common
  def binder(); end

  def closure(); end

  def comments(); end

  def context(); end

  def full_context(); end

  def location(); end

  def name(); end

  def namespace(); end

  def path(); end

  def return_type(); end
end

module Solargraph::Pin::Common
end

class Solargraph::Pin::Constant
  def initialize(visibility: T.unsafe(nil), **splat); end

  def visibility(); end
end

class Solargraph::Pin::Constant
end

module Solargraph::Pin::Conversions
  def completion_item(); end

  def detail(); end

  def link_documentation(); end

  def reset_conversions(); end

  def resolve_completion_item(); end

  def signature_help(); end

  def text_documentation(); end
end

module Solargraph::Pin::Conversions
end

module Solargraph::Pin::Documenting
  def documentation(); end
end

module Solargraph::Pin::Documenting
end

class Solargraph::Pin::DuckMethod
end

class Solargraph::Pin::DuckMethod
end

class Solargraph::Pin::GlobalVariable
end

class Solargraph::Pin::GlobalVariable
end

class Solargraph::Pin::InstanceVariable
  def scope(); end
end

class Solargraph::Pin::InstanceVariable
end

class Solargraph::Pin::Keyword
  def initialize(name); end
end

class Solargraph::Pin::Keyword
end

class Solargraph::Pin::KeywordParam
end

class Solargraph::Pin::KeywordParam
end

class Solargraph::Pin::LocalVariable
  include ::Solargraph::Pin::Localized
  def initialize(assignment: T.unsafe(nil), presence: T.unsafe(nil), **splat); end
end

class Solargraph::Pin::LocalVariable
end

module Solargraph::Pin::Localized
  def presence(); end

  def visible_at?(other_loc); end

  def visible_from?(other, position); end
end

module Solargraph::Pin::Localized
end

class Solargraph::Pin::Method
  include ::Solargraph::Source::NodeMethods
  def initialize(args: T.unsafe(nil), node: T.unsafe(nil), **splat); end

  def node(); end

  def overloads(); end
end

class Solargraph::Pin::Method
end

class Solargraph::Pin::MethodAlias
  def initialize(scope: T.unsafe(nil), original: T.unsafe(nil), **splat); end

  def original(); end
end

class Solargraph::Pin::MethodAlias
end

class Solargraph::Pin::Namespace
  def domains(); end

  def initialize(type: T.unsafe(nil), visibility: T.unsafe(nil), gates: T.unsafe(nil), **splat); end

  def type(); end

  def visibility(); end
end

class Solargraph::Pin::Namespace
end

class Solargraph::Pin::Parameter
  def index(); end
end

class Solargraph::Pin::Parameter
end

class Solargraph::Pin::ProxyType
  def initialize(return_type: T.unsafe(nil), **splat); end
end

class Solargraph::Pin::ProxyType
  def self.anonymous(return_type); end
end

class Solargraph::Pin::Reference
end

class Solargraph::Pin::Reference::Override
  def delete(); end

  def initialize(location, name, tags, delete=T.unsafe(nil)); end

  def tags(); end
end

class Solargraph::Pin::Reference::Override
  def self.from_comment(name, comment); end

  def self.method_return(name, *tags, delete: T.unsafe(nil)); end
end

class Solargraph::Pin::Reference
end

class Solargraph::Pin::Singleton
  def initialize(name: T.unsafe(nil), location: T.unsafe(nil), closure: T.unsafe(nil)); end
end

class Solargraph::Pin::Singleton
end

class Solargraph::Pin::Symbol
  def initialize(location, name); end

  def visibility(); end
end

class Solargraph::Pin::Symbol
end

module Solargraph::Pin::YardPin
end

class Solargraph::Pin::YardPin::Constant
  include ::Solargraph::Pin::YardPin::YardMixin
  def initialize(code_object, closure=T.unsafe(nil), spec=T.unsafe(nil)); end
end

class Solargraph::Pin::YardPin::Constant
end

class Solargraph::Pin::YardPin::Method
  include ::Solargraph::Pin::YardPin::YardMixin
  def initialize(code_object, name=T.unsafe(nil), scope=T.unsafe(nil), visibility=T.unsafe(nil), closure=T.unsafe(nil), spec=T.unsafe(nil)); end
end

class Solargraph::Pin::YardPin::Method
end

class Solargraph::Pin::YardPin::Namespace
  include ::Solargraph::Pin::YardPin::YardMixin
  def initialize(code_object, spec, closure=T.unsafe(nil)); end
end

class Solargraph::Pin::YardPin::Namespace
end

module Solargraph::Pin::YardPin::YardMixin
  def code_object(); end

  def comments(); end

  def location(); end

  def spec(); end
end

module Solargraph::Pin::YardPin::YardMixin
end

module Solargraph::Pin::YardPin
end

module Solargraph::Pin
end

class Solargraph::Position
  def ==(other); end

  def character(); end

  def column(); end

  def initialize(line, character); end

  def line(); end

  def to_hash(); end
end

class Solargraph::Position
  def self.from_offset(text, offset); end

  def self.line_char_to_offset(text, line, character); end

  def self.normalize(object); end

  def self.to_offset(text, position); end
end

class Solargraph::Range
  def ==(other); end

  def contain?(position); end

  def ending(); end

  def include?(position); end

  def initialize(start, ending); end

  def start(); end

  def to_hash(); end
end

class Solargraph::Range
  def self.from_expr(expr); end

  def self.from_node(node); end

  def self.from_to(l1, c1, l2, c2); end
end

module Solargraph::ServerMethods
  def available_port(); end
end

module Solargraph::ServerMethods
end

class Solargraph::Shell
  include ::Solargraph::ServerMethods
  def available_cores(); end

  def bundle(); end

  def clear(); end

  def config(directory=T.unsafe(nil)); end

  def download_core(version=T.unsafe(nil)); end

  def list_cores(); end

  def rdoc(gem, version=T.unsafe(nil)); end

  def reporters(); end

  def scan(); end

  def socket(); end

  def stdio(); end

  def typecheck(*files); end

  def uncache(*gems); end

  def version(); end
end

class Solargraph::Shell
end

class Solargraph::Source
  include ::Solargraph::Source::EncodingFixes
  include ::Solargraph::Source::NodeMethods
  def associated_comments(); end

  def at(range); end

  def code(); end

  def code=(code); end

  def code_for(node); end

  def comment_at?(position); end

  def comments(); end

  def comments=(comments); end

  def comments_for(node); end

  def cursor_at(position); end

  def error_ranges(); end

  def error_ranges=(error_ranges); end

  def filename(); end

  def filename=(filename); end

  def finish_synchronize(); end

  def folding_ranges(); end

  def from_to(l1, c1, l2, c2); end

  def initialize(code, filename=T.unsafe(nil), version=T.unsafe(nil)); end

  def last_updater(); end

  def last_updater=(last_updater); end

  def location(); end

  def node(); end

  def node=(node); end

  def node_at(line, column); end

  def parsed=(parsed); end

  def parsed?(); end

  def references(name); end

  def repaired(); end

  def repaired=(repaired); end

  def repaired?(); end

  def start_synchronize(updater); end

  def string_at?(position); end

  def synchronize(updater); end

  def synchronized=(synchronized); end

  def synchronized?(); end

  def tree_at(line, column); end

  def version(); end

  def version=(version); end
  FOLDING_NODE_TYPES = ::T.let(nil, ::T.untyped)
end

class Solargraph::Source::Chain
  def base(); end

  def constant?(); end

  def define(api_map, name_pin, locals); end

  def defined?(); end

  def infer(api_map, name_pin, locals); end

  def initialize(links); end

  def links(); end

  def literal?(); end

  def undefined?(); end
  UNDEFINED_CALL = ::T.let(nil, ::T.untyped)
  UNDEFINED_CONSTANT = ::T.let(nil, ::T.untyped)
end

class Solargraph::Source::Chain::BlockVariable
end

class Solargraph::Source::Chain::BlockVariable
end

class Solargraph::Source::Chain::Call
  def arguments(); end

  def initialize(word, arguments=T.unsafe(nil), with_block=T.unsafe(nil)); end

  def with_block?(); end
end

class Solargraph::Source::Chain::Call
end

class Solargraph::Source::Chain::ClassVariable
end

class Solargraph::Source::Chain::ClassVariable
end

class Solargraph::Source::Chain::Constant
  def initialize(word); end
end

class Solargraph::Source::Chain::Constant
end

class Solargraph::Source::Chain::GlobalVariable
end

class Solargraph::Source::Chain::GlobalVariable
end

class Solargraph::Source::Chain::Head
end

class Solargraph::Source::Chain::Head
end

class Solargraph::Source::Chain::InstanceVariable
end

class Solargraph::Source::Chain::InstanceVariable
end

class Solargraph::Source::Chain::Link
  def ==(other); end

  def clone_body(); end

  def clone_head(); end

  def constant?(); end

  def head?(); end

  def initialize(word=T.unsafe(nil)); end

  def last_context(); end

  def last_context=(last_context); end

  def mark_head(bool); end

  def resolve(api_map, name_pin, locals); end

  def undefined?(); end

  def word(); end
end

class Solargraph::Source::Chain::Link
end

class Solargraph::Source::Chain::Literal
  def initialize(type); end
end

class Solargraph::Source::Chain::Literal
end

class Solargraph::Source::Chain::Or
  def initialize(links); end
end

class Solargraph::Source::Chain::Or
end

class Solargraph::Source::Chain::Variable
end

class Solargraph::Source::Chain::Variable
end

class Solargraph::Source::Chain
end

class Solargraph::Source::Change
  include ::Solargraph::Source::EncodingFixes
  def initialize(range, new_text); end

  def new_text(); end

  def range(); end

  def repair(text); end

  def write(text, nullable=T.unsafe(nil)); end
end

class Solargraph::Source::Change
end

class Solargraph::Source::Cursor
  def argument?(); end

  def chain(); end

  def comment?(); end

  def end_of_word(); end

  def filename(); end

  def initialize(source, position); end

  def node(); end

  def node_position(); end

  def position(); end

  def range(); end

  def receiver(); end

  def recipient(); end

  def recipient_node(); end

  def source(); end

  def start_of_constant?(); end

  def start_of_word(); end

  def string?(); end

  def word(); end
end

class Solargraph::Source::Cursor
end

module Solargraph::Source::EncodingFixes
end

module Solargraph::Source::EncodingFixes
  def self.normalize(string); end
end

class Solargraph::Source::FlawedBuilder
end

class Solargraph::Source::FlawedBuilder
end

class Solargraph::Source::NodeChainer
  include ::Solargraph::Source::NodeMethods
  def chain(); end

  def initialize(node, filename=T.unsafe(nil), in_block=T.unsafe(nil)); end
end

class Solargraph::Source::NodeChainer
  def self.chain(node, filename=T.unsafe(nil), in_block=T.unsafe(nil)); end

  def self.load_string(code); end
end

module Solargraph::Source::NodeMethods
  NIL_NODE = ::T.let(nil, ::T.untyped)
end

module Solargraph::Source::NodeMethods
  def self.const_from(node); end

  def self.drill_signature(node, signature); end

  def self.get_node_end_position(node); end

  def self.get_node_start_position(node); end

  def self.infer_literal_node_type(node); end

  def self.pack_name(node); end

  def self.resolve_node_signature(node); end

  def self.returns_from(node); end

  def self.unpack_name(node); end
end

class Solargraph::Source::SourceChainer
  include ::Solargraph::Source::NodeMethods
  def chain(); end

  def initialize(source, position); end
end

class Solargraph::Source::SourceChainer
  def self.chain(source, position); end
end

class Solargraph::Source::Updater
  def changes(); end

  def filename(); end

  def initialize(filename, version, changes); end

  def repair(text); end

  def version(); end

  def write(text, nullable=T.unsafe(nil)); end
end

class Solargraph::Source::Updater
end

class Solargraph::Source
  def self.load(filename); end

  def self.load_string(code, filename=T.unsafe(nil), version=T.unsafe(nil)); end

  def self.parse(code, filename=T.unsafe(nil), line=T.unsafe(nil)); end

  def self.parse_docstring(comments); end

  def self.parse_with_comments(code, filename=T.unsafe(nil)); end

  def self.parser(); end
end

class Solargraph::SourceMap
  def code(); end

  def cursor_at(position); end

  def document_symbols(); end

  def environ(); end

  def filename(); end

  def first_pin(path); end

  def initialize(source, pins, locals); end

  def locals(); end

  def locals_at(location); end

  def locate_block_pin(line, character); end

  def locate_named_path_pin(line, character); end

  def locate_pins(location); end

  def pins(); end

  def query_symbols(query); end

  def references(name); end

  def requires(); end

  def source(); end

  def try_merge!(other_map); end
end

class Solargraph::SourceMap::Clip
  def complete(); end

  def define(); end

  def gates(); end

  def in_block?(); end

  def infer(); end

  def initialize(api_map, cursor); end

  def locals(); end

  def signify(); end
end

class Solargraph::SourceMap::Clip
end

class Solargraph::SourceMap::Completion
  def initialize(pins, range); end

  def pins(); end

  def range(); end
end

class Solargraph::SourceMap::Completion
end

class Solargraph::SourceMap::Mapper
  include ::Solargraph::Source::NodeMethods
  def closure_at(position); end

  def find_directive_line_number(comment, tag, start); end

  def map(source); end

  def pins(); end

  def process_comment(source_position, comment_position, comment); end

  def process_comment_directives(); end

  def process_directive(source_position, comment_position, directive); end

  def remove_inline_comment_hashes(comment); end

  def unmap(filename, code); end
  MACRO_REGEXP = ::T.let(nil, ::T.untyped)
end

class Solargraph::SourceMap::Mapper
  def self.map(source); end
end

module Solargraph::SourceMap::NodeProcessor
end

class Solargraph::SourceMap::NodeProcessor::AliasNode
end

class Solargraph::SourceMap::NodeProcessor::AliasNode
end

class Solargraph::SourceMap::NodeProcessor::ArgsNode
end

class Solargraph::SourceMap::NodeProcessor::ArgsNode
end

class Solargraph::SourceMap::NodeProcessor::Base
  include ::Solargraph::Source::NodeMethods
  def initialize(node, region, pins, locals); end

  def locals(); end

  def node(); end

  def pins(); end

  def process(); end

  def region(); end
end

class Solargraph::SourceMap::NodeProcessor::Base
end

class Solargraph::SourceMap::NodeProcessor::BeginNode
end

class Solargraph::SourceMap::NodeProcessor::BeginNode
end

class Solargraph::SourceMap::NodeProcessor::BlockNode
end

class Solargraph::SourceMap::NodeProcessor::BlockNode
end

class Solargraph::SourceMap::NodeProcessor::CasgnNode
end

class Solargraph::SourceMap::NodeProcessor::CasgnNode
end

class Solargraph::SourceMap::NodeProcessor::CvasgnNode
end

class Solargraph::SourceMap::NodeProcessor::CvasgnNode
end

class Solargraph::SourceMap::NodeProcessor::DefNode
end

class Solargraph::SourceMap::NodeProcessor::DefNode
end

class Solargraph::SourceMap::NodeProcessor::DefsNode
end

class Solargraph::SourceMap::NodeProcessor::DefsNode
end

class Solargraph::SourceMap::NodeProcessor::GvasgnNode
end

class Solargraph::SourceMap::NodeProcessor::GvasgnNode
end

class Solargraph::SourceMap::NodeProcessor::IvasgnNode
end

class Solargraph::SourceMap::NodeProcessor::IvasgnNode
end

class Solargraph::SourceMap::NodeProcessor::LvasgnNode
end

class Solargraph::SourceMap::NodeProcessor::LvasgnNode
end

class Solargraph::SourceMap::NodeProcessor::NamespaceNode
end

class Solargraph::SourceMap::NodeProcessor::NamespaceNode
end

class Solargraph::SourceMap::NodeProcessor::OrasgnNode
end

class Solargraph::SourceMap::NodeProcessor::OrasgnNode
end

class Solargraph::SourceMap::NodeProcessor::ResbodyNode
end

class Solargraph::SourceMap::NodeProcessor::ResbodyNode
end

class Solargraph::SourceMap::NodeProcessor::SclassNode
end

class Solargraph::SourceMap::NodeProcessor::SclassNode
end

class Solargraph::SourceMap::NodeProcessor::SendNode
end

class Solargraph::SourceMap::NodeProcessor::SendNode
end

class Solargraph::SourceMap::NodeProcessor::SymNode
end

class Solargraph::SourceMap::NodeProcessor::SymNode
end

module Solargraph::SourceMap::NodeProcessor
  def self.process(node, region=T.unsafe(nil), pins=T.unsafe(nil), locals=T.unsafe(nil)); end
end

class Solargraph::SourceMap::Region
  def closure(); end

  def code_for(node); end

  def filename(); end

  def initialize(source: T.unsafe(nil), closure: T.unsafe(nil), scope: T.unsafe(nil), visibility: T.unsafe(nil)); end

  def scope(); end

  def source(); end

  def update(closure: T.unsafe(nil), scope: T.unsafe(nil), visibility: T.unsafe(nil)); end

  def visibility(); end
end

class Solargraph::SourceMap::Region
end

class Solargraph::SourceMap
  def self.load(filename); end

  def self.load_string(code, filename=T.unsafe(nil)); end

  def self.map(source); end
end

class Solargraph::SourceNotAvailableError
end

class Solargraph::SourceNotAvailableError
end

module Solargraph::StdlibFills
  LIBS = ::T.let(nil, ::T.untyped)
end

Solargraph::StdlibFills::Override = Solargraph::Pin::Reference::Override

module Solargraph::StdlibFills
  def self.get(path); end
end

class Solargraph::TypeChecker
  def filename(); end

  def initialize(filename, api_map: T.unsafe(nil)); end

  def param_type_problems(); end

  def return_type_problems(); end

  def strict_type_problems(); end
end

class Solargraph::TypeChecker::ParamDef
  def initialize(name, type); end

  def name(); end

  def type(); end
end

class Solargraph::TypeChecker::ParamDef
  def self.from(pin); end
end

class Solargraph::TypeChecker::Problem
  def initialize(location, message, pin: T.unsafe(nil), suggestion: T.unsafe(nil)); end

  def location(); end

  def message(); end

  def pin(); end

  def suggestion(); end
end

class Solargraph::TypeChecker::Problem
end

class Solargraph::TypeChecker
  def self.load(filename); end

  def self.load_string(code, filename=T.unsafe(nil)); end
end

class Solargraph::Workspace
  def config(); end

  def directory(); end

  def filenames(); end

  def gemnames(); end

  def gemspec?(); end

  def gemspecs(); end

  def has_file?(filename); end

  def initialize(directory=T.unsafe(nil), config=T.unsafe(nil)); end

  def merge(source); end

  def remove(filename); end

  def require_paths(); end

  def source(filename); end

  def sources(); end

  def synchronize!(updater); end

  def would_merge?(filename); end

  def would_require?(path); end
end

class Solargraph::Workspace::Config
  def allow?(filename); end

  def calculated(); end

  def directory(); end

  def domains(); end

  def excluded(); end

  def included(); end

  def initialize(directory=T.unsafe(nil)); end

  def max_files(); end

  def raw_data(); end

  def reporters(); end

  def require_paths(); end

  def required(); end
  MAX_FILES = ::T.let(nil, ::T.untyped)
end

class Solargraph::Workspace::Config
end

class Solargraph::Workspace
end

class Solargraph::WorkspaceTooLargeError
end

class Solargraph::WorkspaceTooLargeError
end

class Solargraph::YardMap
  def change(new_requires, new_gemset, source_gems=T.unsafe(nil)); end

  def core_pins(); end

  def gemset(); end

  def initialize(required: T.unsafe(nil), gemset: T.unsafe(nil), with_dependencies: T.unsafe(nil)); end

  def load_yardoc(y); end

  def path_pin(path); end

  def pins(); end

  def require_reference(path); end

  def required(); end

  def unresolved_requires(); end

  def with_dependencies=(with_dependencies); end

  def with_dependencies?(); end

  def yardocs(); end
end

class Solargraph::YardMap::Cache
  def get_path_pins(path); end

  def set_path_pins(path, pins); end
end

class Solargraph::YardMap::Cache
end

module Solargraph::YardMap::CoreDocs
  DEFAULT = ::T.let(nil, ::T.untyped)
  SOURCE = ::T.let(nil, ::T.untyped)
end

module Solargraph::YardMap::CoreDocs
  def self.available(); end

  def self.best_download(current=T.unsafe(nil)); end

  def self.best_match(); end

  def self.cache_dir(); end

  def self.clear(); end

  def self.download(version); end

  def self.require_minimum(); end

  def self.valid?(ver); end

  def self.versions(); end

  def self.yardoc_file(ver=T.unsafe(nil)); end

  def self.yardoc_stdlib_file(ver=T.unsafe(nil)); end
end

module Solargraph::YardMap::CoreGen
end

module Solargraph::YardMap::CoreGen
  def self.generate_docs(ruby_dir, dest_dir); end

  def self.generate_gzip(ruby_dir, ver_name=T.unsafe(nil), dest_dir=T.unsafe(nil)); end
end

class Solargraph::YardMap::Mapper
  def generate_pins(code_object); end

  def initialize(code_objects, spec=T.unsafe(nil)); end

  def map(); end
end

class Solargraph::YardMap::Mapper
end

module Solargraph::YardMap::RdocToYard
end

module Solargraph::YardMap::RdocToYard
  extend ::Solargraph::ApiMap::SourceToYard
  def self.base_name(mod); end

  def self.commentary(cmnt); end

  def self.find_file(obj); end

  def self.locate(obj); end

  def self.run(spec); end
end

class Solargraph::YardMap
end

module Solargraph
  def self.logger(); end

  def self.with_clean_env(&block); end
end

SorbetRails::ModelPlugins::Base::Parameter = Parlour::RbiGenerator::Parameter

module SorbetRails
  extend ::T::Private::Methods::SingletonMethodHooks
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

module Sprockets
  VERSION = ::T.let(nil, ::T.untyped)
end

Sprockets::Autoload::Babel = Babel

Sprockets::Autoload::SassC = SassC

class Sprockets::BabelProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::Base
  include ::Sprockets::SourceMapUtils
  include ::Sprockets::Dependencies
  include ::Sprockets::Compressing
  include ::Sprockets::Exporting
  include ::Sprockets::Loader
  include ::Sprockets::DigestUtils
  include ::Sprockets::Transformers
  include ::Sprockets::PathDependencyUtils
  include ::Sprockets::Processing
  include ::Sprockets::Mime
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::PathDigestUtils
  include ::Sprockets::ProcessorUtils
end

module Sprockets::Bower
  POSSIBLE_BOWER_JSONS = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache
  PEEK_SIZE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache::FileStore
  DEFAULT_MAX_SIZE = ::T.let(nil, ::T.untyped)
  EXCLUDED_DIRS = ::T.let(nil, ::T.untyped)
  GITKEEP_FILES = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache::MemoryStore
  DEFAULT_MAX_SIZE = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache::NullStore
  def clear(options=T.unsafe(nil)); end

  def get(key); end

  def set(key, value); end
end

class Sprockets::Cache::NullStore
end

class Sprockets::ClosureCompressor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::CoffeeScriptProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::Configuration
  include ::Sprockets::Dependencies
  include ::Sprockets::Compressing
  include ::Sprockets::Exporting
  include ::Sprockets::Processing
  include ::Sprockets::Transformers
  include ::Sprockets::Mime
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::PathDigestUtils
  include ::Sprockets::ProcessorUtils
  include ::Sprockets::HTTPUtils
  include ::Sprockets::DigestUtils
end

module Sprockets::Dependencies
  include ::Sprockets::URIUtils
  include ::Sprockets::PathDigestUtils
  include ::Sprockets::PathUtils
end

module Sprockets::DigestUtils
  DIGEST_SIZES = ::T.let(nil, ::T.untyped)
  HASH_ALGORITHMS = ::T.let(nil, ::T.untyped)
end

class Sprockets::DirectiveProcessor
  DIRECTIVE_PATTERN = ::T.let(nil, ::T.untyped)
end

module Sprockets::EcoProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::EjsProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::EncodingUtils
  BOM = ::T.let(nil, ::T.untyped)
  CHARSET_DETECT = ::T.let(nil, ::T.untyped)
  CHARSET_SIZE = ::T.let(nil, ::T.untyped)
  CHARSET_START = ::T.let(nil, ::T.untyped)
end

class Sprockets::JSMincCompressor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::Loader
  include ::Sprockets::Transformers
  include ::Sprockets::Resolve
  include ::Sprockets::PathDependencyUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::Processing
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::ProcessorUtils
end

module Sprockets::ManifestUtils
  MANIFEST_RE = ::T.let(nil, ::T.untyped)
end

module Sprockets::Mime
  include ::Sprockets::Utils
end

module Sprockets::PathDigestUtils
  include ::Sprockets::PathUtils
end

module Sprockets::PathUtils
  SEPARATOR_PATTERN = ::T.let(nil, ::T.untyped)
end

module Sprockets::Paths
  include ::Sprockets::Utils
end

module Sprockets::Processing
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
end

module Sprockets::ProcessorUtils
  VALID_METADATA_COMPOUND_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_COMPOUND_TYPES_HASH = ::T.let(nil, ::T.untyped)
  VALID_METADATA_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_VALUE_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_VALUE_TYPES_HASH = ::T.let(nil, ::T.untyped)
end

class Sprockets::ProcessorUtils::CompositeProcessor
  PLURAL = ::T.let(nil, ::T.untyped)
  SINGULAR = ::T.let(nil, ::T.untyped)
end

module Sprockets::Rails
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::Rails::Helper
  VIEW_ACCESSORS = ::T.let(nil, ::T.untyped)
end

class Sprockets::Railtie
  LOOSE_APP_ASSETS = ::T.let(nil, ::T.untyped)
end

module Sprockets::Resolve
  include ::Sprockets::PathDependencyUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::URIUtils
end

class Sprockets::SassCompressor
  VERSION = ::T.let(nil, ::T.untyped)
end

Sprockets::SassFunctions = Sprockets::SassProcessor::Functions

module Sprockets::Server
  ALLOWED_REQUEST_METHODS = ::T.let(nil, ::T.untyped)
end

module Sprockets::SourceMapUtils
  BASE64_DIGITS = ::T.let(nil, ::T.untyped)
  BASE64_VALUES = ::T.let(nil, ::T.untyped)
  VLQ_BASE = ::T.let(nil, ::T.untyped)
  VLQ_BASE_MASK = ::T.let(nil, ::T.untyped)
  VLQ_BASE_SHIFT = ::T.let(nil, ::T.untyped)
  VLQ_CONTINUATION_BIT = ::T.let(nil, ::T.untyped)
end

module Sprockets::Transformers
  include ::Sprockets::Utils
  include ::Sprockets::ProcessorUtils
end

class Sprockets::UglifierCompressor
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::Utils::Gzip
  COMPRESSABLE_MIME_TYPES = ::T.let(nil, ::T.untyped)
end

class Sprockets::YUICompressor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets
  extend ::Sprockets::Dependencies
  extend ::Sprockets::Compressing
  extend ::Sprockets::Exporting
  extend ::Sprockets::Processing
  extend ::Sprockets::Transformers
  extend ::Sprockets::Mime
  extend ::Sprockets::Utils
  extend ::Sprockets::URIUtils
  extend ::Sprockets::PathDigestUtils
  extend ::Sprockets::HTTPUtils
  extend ::Sprockets::DigestUtils
end

class StopIteration
  def result(); end
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def []=(*_); end

  def casecmp?(_); end

  def each_grapheme_cluster(); end

  def encode!(*_); end

  def grapheme_clusters(); end

  def parse_csv(**options); end

  def reverse!(); end

  def shell_split(); end

  def shellescape(); end

  def shellsplit(); end

  def succ!(); end

  def to_d(); end

  def undump(); end

  def unicode_normalize(*_); end

  def unicode_normalize!(*_); end

  def unicode_normalized?(*_); end

  def unpack1(_); end
  BLANK_RE = ::T.let(nil, ::T.untyped)
  ENCODED_BLANKS = ::T.let(nil, ::T.untyped)
end

class StringIO
  def length(); end

  def truncate(_); end
end

class StringScanner
  def <<(_); end

  def [](_); end

  def beginning_of_line?(); end

  def bol?(); end

  def captures(); end

  def charpos(); end

  def check(_); end

  def check_until(_); end

  def clear(); end

  def concat(_); end

  def empty?(); end

  def exist?(_); end

  def get_byte(); end

  def getbyte(); end

  def initialize(*_); end

  def match?(_); end

  def matched(); end

  def matched?(); end

  def matched_size(); end

  def peek(_); end

  def peep(_); end

  def pointer(); end

  def pointer=(pointer); end

  def pos(); end

  def pos=(pos); end

  def post_match(); end

  def pre_match(); end

  def reset(); end

  def rest(); end

  def rest?(); end

  def rest_size(); end

  def restsize(); end

  def scan_full(_, _1, _2); end

  def scan_until(_); end

  def search_full(_, _1, _2); end

  def size(); end

  def skip(_); end

  def skip_until(_); end

  def string(); end

  def string=(string); end

  def terminate(); end

  def unscan(); end

  def values_at(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class StringScanner
  def self.must_C_version(); end
end

class Struct
  def [](_); end

  def []=(_, _1); end

  def dig(*_); end

  def each_pair(); end

  def filter(*_); end

  def length(); end

  def members(); end

  def select(*_); end

  def size(); end

  def to_a(); end

  def to_h(); end

  def values(); end

  def values_at(*_); end
end

Struct::Group = Etc::Group

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class Symbol
  def self.from_msgpack_ext(data); end
end

class SymbolHash
  def [](key); end

  def []=(key, value); end

  def delete(key); end

  def has_key?(key); end

  def initialize(symbolize_value=T.unsafe(nil)); end

  def key?(key); end

  def merge(hash); end

  def merge!(hash); end

  def update(hash); end
end

class SymbolHash
  def self.[](*hsh); end
end

class SystemCallError
  def errno(); end
end

class SystemExit
  def status(); end

  def success?(); end
end

module TZInfo::RubyCoreSupport
  HALF_DAYS_IN_DAY = ::T.let(nil, ::T.untyped)
end

class TZInfo::ZoneinfoDataSource
  DEFAULT_ALTERNATE_ISO3166_TAB_SEARCH_PATH = ::T.let(nil, ::T.untyped)
  DEFAULT_SEARCH_PATH = ::T.let(nil, ::T.untyped)
end

class TZInfo::ZoneinfoTimezoneInfo
  MAX_TIMESTAMP = ::T.let(nil, ::T.untyped)
  MIN_TIMESTAMP = ::T.let(nil, ::T.untyped)
end

class Tempfile
  def _close(); end

  def inspect(); end
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

module Temple
  VERSION = ::T.let(nil, ::T.untyped)
end

class Temple::ERB::Engine
end

class Temple::ERB::Engine
end

class Temple::ERB::Parser
  def call(input); end
  ERB_PATTERN = ::T.let(nil, ::T.untyped)
end

class Temple::ERB::Parser
end

class Temple::ERB::Template
end

class Temple::ERB::Template
end

class Temple::ERB::Trimming
end

class Temple::ERB::Trimming
end

class Temple::FilterError
end

class Temple::FilterError
end

class Temple::Filters::CodeMerger
end

class Temple::Filters::CodeMerger
end

class Temple::Filters::DynamicInliner
end

class Temple::Filters::DynamicInliner
end

class Temple::Filters::Eraser
  def do?(list, exp); end
end

class Temple::Filters::Eraser
end

class Temple::Filters::StaticAnalyzer
  def on_dynamic(code); end
end

class Temple::Filters::StaticAnalyzer
end

class Temple::Filters::StringSplitter
  def on_dynamic(code); end
end

class Temple::Filters::StringSplitter::SyntaxChecker
end

class Temple::Filters::StringSplitter::SyntaxChecker::ParseError
end

class Temple::Filters::StringSplitter::SyntaxChecker::ParseError
end

class Temple::Filters::StringSplitter::SyntaxChecker
  def self.syntax_error?(code); end
end

class Temple::Filters::StringSplitter
  def self.compile(code); end
end

class Temple::Filters::Validator
end

class Temple::Filters::Validator
end

class Temple::Generators::ERB
end

class Temple::Generators::ERB
end

module Temple::Grammar
  Bool = ::T.let(nil, ::T.untyped)
  Case = ::T.let(nil, ::T.untyped)
  Condition = ::T.let(nil, ::T.untyped)
  EmptyExp = ::T.let(nil, ::T.untyped)
  Expression = ::T.let(nil, ::T.untyped)
  HTMLAttr = ::T.let(nil, ::T.untyped)
  HTMLIdentifier = ::T.let(nil, ::T.untyped)
end

module Temple::Grammar
  extend ::Temple::Mixins::GrammarDSL
end

class Temple::HTML::AttributeRemover
  def on_html_attr(name, value); end
end

class Temple::HTML::AttributeRemover
end

class Temple::HTML::Fast
  DOCTYPES = ::T.let(nil, ::T.untyped)
  HTML_VOID_ELEMENTS = ::T.let(nil, ::T.untyped)
end

class Temple::InvalidExpression
end

class Temple::InvalidExpression
end

module Temple::Mixins::GrammarDSL
  def ===(exp); end

  def =~(exp); end

  def Rule(rule); end

  def Value(value); end

  def const_missing(name); end

  def extended(mod); end

  def match?(exp); end

  def validate!(exp); end
end

class Temple::Mixins::GrammarDSL::Element
  def initialize(grammar, rule); end
end

class Temple::Mixins::GrammarDSL::Element
end

class Temple::Mixins::GrammarDSL::Or
  def <<(rule); end

  def after_copy(source); end

  def initialize(grammar, *children); end

  def match(exp, unmatched); end
end

class Temple::Mixins::GrammarDSL::Or
end

class Temple::Mixins::GrammarDSL::Root
  def initialize(grammar, name); end

  def validate!(exp); end
end

class Temple::Mixins::GrammarDSL::Root
end

class Temple::Mixins::GrammarDSL::Rule
  def ===(exp); end

  def =~(exp); end

  def copy_to(grammar); end

  def initialize(grammar); end

  def match?(exp); end

  def |(rule); end
end

class Temple::Mixins::GrammarDSL::Rule
end

class Temple::Mixins::GrammarDSL::Value
  def initialize(grammar, value); end

  def match(exp, unmatched); end
end

class Temple::Mixins::GrammarDSL::Value
end

module Temple::Mixins::GrammarDSL
end

module Temple::StaticAnalyzer
  DYNAMIC_TOKENS = ::T.let(nil, ::T.untyped)
  STATIC_KEYWORDS = ::T.let(nil, ::T.untyped)
  STATIC_OPERATORS = ::T.let(nil, ::T.untyped)
  STATIC_TOKENS = ::T.let(nil, ::T.untyped)
end

class Temple::StaticAnalyzer::SyntaxChecker
end

class Temple::StaticAnalyzer::SyntaxChecker::ParseError
end

class Temple::StaticAnalyzer::SyntaxChecker::ParseError
end

class Temple::StaticAnalyzer::SyntaxChecker
end

module Temple::StaticAnalyzer
  def self.available?(); end

  def self.static?(code); end

  def self.syntax_error?(code); end
end

Test = Minitest::Parallel::Test

class Thor
  Correctable = ::T.let(nil, ::T.untyped)
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Thor::Actions::CreateFile
end

class Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Thor::Actions::EmptyDirectory
end

module Thor::Actions
  def self.included(base); end
end

Thor::AmbiguousTaskError = Thor::AmbiguousCommandError

class Thor::Argument
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Thor::Arguments
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Thor::Command
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

Thor::DynamicTask = Thor::DynamicCommand

Thor::HiddenTask = Thor::HiddenCommand

class Thor::Option
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Thor::Options
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

module Thor::RakeCompat
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Thor::RakeCompat
  def self.included(base); end

  def self.rake_classes(); end
end

module Thor::Shell
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

Thor::Task = Thor::Command

Thor::UndefinedTaskError = Thor::UndefinedCommandError

module ThreadSafe
  NULL = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

ThreadSafe::Array = Array

class ThreadSafe::AtomicReferenceCacheBackend
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def compute(key); end

  def compute_if_absent(key); end

  def compute_if_present(key); end

  def delete(key); end

  def delete_pair(key, value); end

  def each_pair(); end

  def empty?(); end

  def get_and_set(key, value); end

  def get_or_default(key, else_value=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def key?(key); end

  def merge_pair(key, value); end

  def replace_if_exists(key, new_value); end

  def replace_pair(key, old_value, new_value); end

  def size(); end
  DEFAULT_CAPACITY = ::T.let(nil, ::T.untyped)
  HASH_BITS = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MAX_CAPACITY = ::T.let(nil, ::T.untyped)
  MOVED = ::T.let(nil, ::T.untyped)
  NOW_RESIZING = ::T.let(nil, ::T.untyped)
  TRANSFER_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  WAITING = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::AtomicReferenceCacheBackend::Node
  include ::ThreadSafe::Util::CheapLockable
  def initialize(hash, key, value, next_node=T.unsafe(nil)); end

  def key(); end

  def key?(key); end

  def locked?(); end

  def matches?(key, hash); end

  def pure_hash(); end

  def try_await_lock(table, i); end

  def try_lock_via_hash(node_hash=T.unsafe(nil)); end

  def unlock_via_hash(locked_hash, node_hash); end
  HASH_BITS = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MOVED = ::T.let(nil, ::T.untyped)
  SPIN_LOCK_ATTEMPTS = ::T.let(nil, ::T.untyped)
  WAITING = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::AtomicReferenceCacheBackend::Node
  extend ::ThreadSafe::Util::Volatile
  def self.locked_hash?(hash); end
end

class ThreadSafe::AtomicReferenceCacheBackend::Table
  def cas_new_node(i, hash, key, value); end

  def delete_node_at(i, node, predecessor_node); end

  def try_lock_via_hash(i, node, node_hash); end

  def try_to_cas_in_computed(i, hash, key); end
end

class ThreadSafe::AtomicReferenceCacheBackend::Table
end

class ThreadSafe::AtomicReferenceCacheBackend
  extend ::ThreadSafe::Util::Volatile
end

ThreadSafe::ConcurrentCacheBackend = ThreadSafe::MriCacheBackend

ThreadSafe::Hash = Hash

class ThreadSafe::MriCacheBackend
  WRITE_LOCK = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::SynchronizedCacheBackend
  include ::Mutex_m
  def lock(); end

  def locked?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class ThreadSafe::SynchronizedCacheBackend
end

module ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::Util::Adder
  def add(x); end

  def decrement(); end

  def increment(); end

  def reset(); end

  def sum(); end
end

class ThreadSafe::Util::Adder
end

class ThreadSafe::Util::AtomicReference
  def compare_and_set(old_value, new_value); end

  def get(); end

  def initialize(value=T.unsafe(nil)); end

  def set(new_value); end

  def value(); end

  def value=(new_value); end
end

class ThreadSafe::Util::AtomicReference
end

module ThreadSafe::Util::CheapLockable
  def cas_mutex(old_value, new_value); end

  def compare_and_set_mutex(old_value, new_value); end

  def lazy_set_mutex(value); end

  def mutex(); end

  def mutex=(value); end
end

module ThreadSafe::Util::CheapLockable
  extend ::ThreadSafe::Util::Volatile
end

class ThreadSafe::Util::PowerOfTwoTuple
  def hash_to_index(hash); end

  def next_in_size_table(); end

  def volatile_get_by_hash(hash); end

  def volatile_set_by_hash(hash, value); end
end

class ThreadSafe::Util::PowerOfTwoTuple
end

class ThreadSafe::Util::Striped64
  def busy?(); end

  def initialize(); end

  def retry_update(x, hash_code, was_uncontended); end
  THREAD_LOCAL_KEY = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::Util::Striped64::Cell
  def cas(old_value, new_value); end

  def cas_computed(); end

  def padding_(); end
end

class ThreadSafe::Util::Striped64::Cell
end

class ThreadSafe::Util::Striped64
  extend ::ThreadSafe::Util::Volatile
end

module ThreadSafe::Util::Volatile
  def attr_volatile(*attr_names); end
end

module ThreadSafe::Util::Volatile
end

class ThreadSafe::Util::VolatileTuple
  include ::Enumerable
  def cas(i, old_value, new_value); end

  def compare_and_set(i, old_value, new_value); end

  def each(&blk); end

  def initialize(size); end

  def size(); end

  def volatile_get(i); end

  def volatile_set(i, value); end
end

class ThreadSafe::Util::VolatileTuple
end

module ThreadSafe::Util::XorShiftRandom
  def get(); end

  def xorshift(x); end
  MAX_XOR_SHIFTABLE_INT = ::T.let(nil, ::T.untyped)
end

module ThreadSafe::Util::XorShiftRandom
  extend ::ThreadSafe::Util::XorShiftRandom
end

module ThreadSafe::Util
end

module Tilt
  LOCK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Tilt::BabelTemplate
end

class Tilt::BabelTemplate
end

class Tilt::BuilderTemplate
  def precompiled_postamble(locals); end

  def precompiled_template(locals); end
end

class Tilt::BuilderTemplate
end

class Tilt::CSVTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::CSVTemplate
  def self.engine(); end
end

class Tilt::ERBTemplate
  def precompiled(locals); end

  def precompiled_postamble(locals); end

  def precompiled_preamble(locals); end

  def precompiled_template(locals); end
  SUPPORTS_KVARGS = ::T.let(nil, ::T.untyped)
end

class Tilt::ERBTemplate
  def self.default_output_variable(); end

  def self.default_output_variable=(name); end
end

class Tilt::ErubiTemplate
  def precompiled_template(locals); end
end

class Tilt::ErubiTemplate
end

class Tilt::EtanniTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::EtanniTemplate
end

class Tilt::Mapping
  AUTOLOAD_IS_BROKEN = ::T.let(nil, ::T.untyped)
  LOCK = ::T.let(nil, ::T.untyped)
end

class Tilt::MarukuTemplate
  def allows_script?(); end
end

class Tilt::MarukuTemplate
end

class Tilt::NokogiriTemplate
  def evaluate(scope, locals); end

  def precompiled_postamble(locals); end

  def precompiled_preamble(locals); end

  def precompiled_template(locals); end
  DOCUMENT_HEADER = ::T.let(nil, ::T.untyped)
end

class Tilt::NokogiriTemplate
end

class Tilt::PlainTemplate
end

class Tilt::PlainTemplate
end

class Tilt::RDocTemplate
  def allows_script?(); end

  def markup(); end
end

class Tilt::RDocTemplate
end

class Tilt::SassTemplate
  def allows_script?(); end
end

Tilt::SassTemplate::Sass = SassC

class Tilt::SassTemplate
end

class Tilt::ScssTemplate
end

class Tilt::ScssTemplate
end

class Tilt::SigilTemplate
  def allows_script?(); end
end

class Tilt::SigilTemplate
end

class Tilt::StringTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::StringTemplate
end

Tilt::TOPOBJECT = Tilt::CompiledTemplates

class Time
  COMMON_YEAR_DAYS_IN_MONTH = ::T.let(nil, ::T.untyped)
  DATE_FORMATS = ::T.let(nil, ::T.untyped)
end

class TracePoint
  def __enable(_, _1); end

  def eval_script(); end

  def event(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

module Turbolinks
  VERSION = ::T.let(nil, ::T.untyped)
end

module Turbolinks::Assertions
  TURBOLINKS_VISIT = ::T.let(nil, ::T.untyped)
end

module Turbolinks::Source
  VERSION = ::T.let(nil, ::T.untyped)
end

module URI
  include ::URI::RFC2396_REGEXP
end

module URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

class URI::FTP
  include ::OpenURI::OpenRead
  def buffer_open(buf, proxy, options); end

  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::File
end

class URI::GID
  COMPONENT = ::T.let(nil, ::T.untyped)
  PATH_REGEXP = ::T.let(nil, ::T.untyped)
end

class URI::HTTP
  include ::OpenURI::OpenRead
  def buffer_open(buf, proxy, options); end
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.get_encoding(label); end

end

class UnboundMethod
  def clone(); end

  def original_name(); end
end

class UncaughtThrowError
  def tag(); end

  def value(); end
end

module Unicode
end

module Unicode::DisplayWidth
  DATA_DIRECTORY = ::T.let(nil, ::T.untyped)
  DEPTHS = ::T.let(nil, ::T.untyped)
  INDEX = ::T.let(nil, ::T.untyped)
  INDEX_FILENAME = ::T.let(nil, ::T.untyped)
  NO_STRING_EXT = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Unicode::DisplayWidth
  def self.emoji_extra_width_of(string, ambiguous=T.unsafe(nil), overwrite=T.unsafe(nil), _=T.unsafe(nil)); end

  def self.of(string, ambiguous=T.unsafe(nil), overwrite=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Unicode
end

module UnicodeNormalize
end

module UnicodeNormalize
end

class User
  include ::User::GeneratedAssociationMethods
  def password_confirmation(); end
end

class User::ActiveRecord_AssociationRelation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::User::GeneratedRelationMethods
end

class User::ActiveRecord_Associations_CollectionProxy
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::User::GeneratedRelationMethods
end

class User::ActiveRecord_Relation
  include ::ActiveRecord::Delegation::ClassSpecificRelation
  include ::User::GeneratedRelationMethods
end

module User::GeneratedAssociationMethods
end

module User::GeneratedAssociationMethods
end

module User::GeneratedAttributeMethods
  extend ::Mutex_m
end

module User::GeneratedRelationMethods
end

module User::GeneratedRelationMethods
  extend ::Mutex_m
end

class Vector
  include ::ExceptionForMatrix
  include ::Enumerable
  include ::Matrix::CoercionHelper
  def *(x); end

  def +(v); end

  def +@(); end

  def -(v); end

  def -@(); end

  def /(x); end

  def ==(other); end

  def [](i); end

  def []=(i, v); end

  def angle_with(v); end

  def coerce(other); end

  def collect(&block); end

  def collect!(&block); end

  def collect2(v); end

  def component(i); end

  def covector(); end

  def cross(*vs); end

  def cross_product(*vs); end

  def dot(v); end

  def each(&block); end

  def each2(v); end

  def element(i); end

  def elements(); end

  def elements_to_f(); end

  def elements_to_i(); end

  def elements_to_r(); end

  def eql?(other); end

  def independent?(*vs); end

  def initialize(array); end

  def inner_product(v); end

  def magnitude(); end

  def map(&block); end

  def map!(&block); end

  def map2(v, &block); end

  def norm(); end

  def normalize(); end

  def r(); end

  def round(ndigits=T.unsafe(nil)); end

  def size(); end

  def to_a(); end

  def to_matrix(); end

  def zero?(); end
end

class Vector::ZeroVectorError
end

class Vector::ZeroVectorError
end

class Vector
  extend ::Exception2MessageMapper
  extend ::Matrix::ConversionHelper
  def self.[](*array); end

  def self.basis(size:, index:); end

  def self.elements(array, copy=T.unsafe(nil)); end

  def self.included(mod); end

  def self.independent?(*vs); end

  def self.zero(size); end
end

Visitor = Psych::Visitors::Visitor

module Warning
  def warn(_); end
end

module Warning
  extend ::Warning
end

class WeakRef
  def initialize(orig); end

  def weakref_alive?(); end
end

class WeakRef::RefError
end

class WeakRef::RefError
end

class WeakRef
end

class WebConsole::Context
  def extract(input=T.unsafe(nil)); end

  def initialize(binding); end
  GLOBAL_OBJECTS = ::T.let(nil, ::T.untyped)
end

class WebConsole::Context
end

class WebConsole::DoubleRenderError
end

class WebConsole::DoubleRenderError
end

class WebConsole::Error
end

class WebConsole::Error
end

class WebConsole::Evaluator
  def cleaner(); end

  def eval(input); end

  def initialize(binding=T.unsafe(nil)); end
end

class WebConsole::Evaluator
  def self.cleaner(); end
end

class WebConsole::ExceptionMapper
  def [](index); end

  def exc(); end

  def first(); end

  def initialize(exception); end
end

class WebConsole::ExceptionMapper
  def self.find_binding(mappers, exception_object_id); end

  def self.follow(exc); end
end

class WebConsole::Injector
  def initialize(body, headers); end

  def inject(content); end
end

class WebConsole::Injector
end

class WebConsole::Middleware
  TEMPLATES_PATH = ::T.let(nil, ::T.untyped)
end

class WebConsole::Permissions
  ALWAYS_PERMITTED_NETWORKS = ::T.let(nil, ::T.untyped)
end

class WebConsole::Session
  def context(objpath); end

  def eval(input); end

  def id(); end

  def initialize(exception_mappers); end

  def inmemory_storage(); end

  def switch_binding_to(index, exception_object_id); end
end

class WebConsole::Session
  def self.find(id); end

  def self.from(storage); end

  def self.inmemory_storage(); end
end

class WebConsole::Template
  def initialize(env, session); end

  def render(template); end

  def template_paths(); end

  def template_paths=(obj); end
end

class WebConsole::Template
  def self.template_paths(); end

  def self.template_paths=(obj); end
end

class WebConsole::View
  def only_on_error_page(*args); end

  def only_on_regular_page(*args); end

  def render(*_); end

  def render_inlined_string(template); end

  def render_javascript(template); end
end

class WebConsole::View
end

class WebConsole::WhinyRequest
  def permitted?(); end
end

class WebConsole::WhinyRequest
end

class WebSocket::Driver
  BINARY = ::T.let(nil, ::T.untyped)
  MAX_LENGTH = ::T.let(nil, ::T.untyped)
  STATES = ::T.let(nil, ::T.untyped)
  UNICODE = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Client
  def headers(); end

  def proxy(origin, options=T.unsafe(nil)); end

  def status(); end
  VALID_SCHEMES = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Client
  def self.generate_key(); end
end

class WebSocket::Driver::Draft75
  def frame(buffer, type=T.unsafe(nil), error_type=T.unsafe(nil)); end

  def parse(chunk); end

  def version(); end
end

class WebSocket::Driver::Draft75
end

class WebSocket::Driver::Draft76
  BODY_SIZE = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Draft76
end

class WebSocket::Driver::Headers
  def [](name); end

  def []=(name, value); end

  def clear(); end

  def initialize(received=T.unsafe(nil)); end

  def to_h(); end
  ALLOWED_DUPLICATES = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Headers
end

class WebSocket::Driver::Hybi
  def frame(buffer, type=T.unsafe(nil), code=T.unsafe(nil)); end

  def parse(chunk); end

  def ping(message=T.unsafe(nil), &callback); end

  def pong(message=T.unsafe(nil)); end

  def version(); end
  BYTE = ::T.let(nil, ::T.untyped)
  DEFAULT_ERROR_CODE = ::T.let(nil, ::T.untyped)
  ERRORS = ::T.let(nil, ::T.untyped)
  ERROR_CODES = ::T.let(nil, ::T.untyped)
  FIN = ::T.let(nil, ::T.untyped)
  GUID = ::T.let(nil, ::T.untyped)
  LENGTH = ::T.let(nil, ::T.untyped)
  MASK = ::T.let(nil, ::T.untyped)
  MAX_RESERVED_ERROR = ::T.let(nil, ::T.untyped)
  MESSAGE_OPCODES = ::T.let(nil, ::T.untyped)
  MIN_RESERVED_ERROR = ::T.let(nil, ::T.untyped)
  OPCODE = ::T.let(nil, ::T.untyped)
  OPCODES = ::T.let(nil, ::T.untyped)
  OPCODE_CODES = ::T.let(nil, ::T.untyped)
  OPENING_OPCODES = ::T.let(nil, ::T.untyped)
  PACK_FORMATS = ::T.let(nil, ::T.untyped)
  RSV1 = ::T.let(nil, ::T.untyped)
  RSV2 = ::T.let(nil, ::T.untyped)
  RSV3 = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Hybi::Frame
  def final(); end

  def final=(final); end

  def length(); end

  def length=(length); end

  def length_bytes(); end

  def length_bytes=(length_bytes); end

  def masked(); end

  def masked=(masked); end

  def masking_key(); end

  def masking_key=(masking_key); end

  def opcode(); end

  def opcode=(opcode); end

  def payload(); end

  def payload=(payload); end

  def rsv1(); end

  def rsv1=(rsv1); end

  def rsv2(); end

  def rsv2=(rsv2); end

  def rsv3(); end

  def rsv3=(rsv3); end
end

class WebSocket::Driver::Hybi::Frame
end

class WebSocket::Driver::Hybi::Message
  def <<(frame); end

  def data(); end

  def data=(data); end

  def opcode(); end

  def opcode=(opcode); end

  def rsv1(); end

  def rsv1=(rsv1); end

  def rsv2(); end

  def rsv2=(rsv2); end

  def rsv3(); end

  def rsv3=(rsv3); end
end

class WebSocket::Driver::Hybi::Message
end

class WebSocket::Driver::Hybi
  def self.generate_accept(key); end
end

class WebSocket::Driver::Proxy
  include ::WebSocket::Driver::EventEmitter
  def headers(); end

  def initialize(client, origin, options); end

  def parse(chunk); end

  def set_header(name, value); end

  def start(); end

  def status(); end
  PORTS = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Proxy
end

class WebSocket::Driver::Server
  def add_extension(*args, &block); end

  def binary(*args, &block); end

  def close(*args, &block); end

  def env(); end

  def frame(*args, &block); end

  def parse(chunk); end

  def ping(*args, &block); end

  def set_header(*args, &block); end

  def start(*args, &block); end

  def text(*args, &block); end

  def url(); end

  def version(); end

  def write(buffer); end
  EVENTS = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::Server
end

class WebSocket::Driver::StreamReader
  def each_byte(); end

  def put(chunk); end

  def read(length); end
  MINIMUM_AUTOMATIC_PRUNE_OFFSET = ::T.let(nil, ::T.untyped)
end

class WebSocket::Driver::StreamReader
end

class WebSocket::Extensions
  MESSAGE_OPCODES = ::T.let(nil, ::T.untyped)
end

class WebSocket::Extensions::Parser
  EXT = ::T.let(nil, ::T.untyped)
  EXT_LIST = ::T.let(nil, ::T.untyped)
  NOTOKEN = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  PARAM = ::T.let(nil, ::T.untyped)
  QUOTED = ::T.let(nil, ::T.untyped)
  TOKEN = ::T.let(nil, ::T.untyped)
end

class WebSocket::Extensions::Parser::ParseError
end

class WebSocket::Extensions::Parser::ParseError
end

class WebSocket::Extensions::Parser
  def self.parse_header(header); end

  def self.serialize_params(name, params); end
end

module WebSocket::HTTP
end

module WebSocket::HTTP::Headers
  def complete?(); end

  def error?(); end

  def headers(); end

  def initialize(); end

  def parse(chunk); end
  CR = ::T.let(nil, ::T.untyped)
  HEADER_LINE = ::T.let(nil, ::T.untyped)
  LF = ::T.let(nil, ::T.untyped)
  MAX_LINE_LENGTH = ::T.let(nil, ::T.untyped)
end

module WebSocket::HTTP::Headers
end

class WebSocket::HTTP::Request
  include ::WebSocket::HTTP::Headers
  def env(); end
  REQUEST_LINE = ::T.let(nil, ::T.untyped)
  REQUEST_TARGET = ::T.let(nil, ::T.untyped)
  RESERVED_HEADERS = ::T.let(nil, ::T.untyped)
end

class WebSocket::HTTP::Request
end

class WebSocket::HTTP::Response
  include ::WebSocket::HTTP::Headers
  def [](name); end

  def body(); end

  def code(); end
  STATUS_LINE = ::T.let(nil, ::T.untyped)
end

class WebSocket::HTTP::Response
end

module WebSocket::HTTP
  def self.normalize_header(name); end
end

module Webdrivers
  DEFAULT_CACHE_TIME = ::T.let(nil, ::T.untyped)
  DEFAULT_INSTALL_DIR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Webpacker::DevServer
  DEFAULT_ENV_PREFIX = ::T.let(nil, ::T.untyped)
end

class Webpacker::Env
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module XPath::DSL
  AXES = ::T.let(nil, ::T.untyped)
  LOWERCASE_LETTERS = ::T.let(nil, ::T.untyped)
  METHODS = ::T.let(nil, ::T.untyped)
  OPERATORS = ::T.let(nil, ::T.untyped)
  UPPERCASE_LETTERS = ::T.let(nil, ::T.untyped)
end

YAML = Psych

YAMLTree = Psych::Visitors::YAMLTree

module YARD
  CONFIG_DIR = ::T.let(nil, ::T.untyped)
  ROOT = ::T.let(nil, ::T.untyped)
  TEMPLATE_ROOT = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module YARD::CLI
end

class YARD::CLI::Command
  def common_options(opts); end

  def description(); end

  def load_script(file); end

  def parse_options(opts, args); end

  def unrecognized_option(err); end
end

class YARD::CLI::Command
  def self.run(*args); end
end

class YARD::CLI::CommandParser
  def run(*args); end
end

class YARD::CLI::CommandParser
  def self.commands(); end

  def self.commands=(commands); end

  def self.default_command(); end

  def self.default_command=(default_command); end

  def self.run(*args); end
end

class YARD::CLI::Config
  def append(); end

  def append=(append); end

  def as_list(); end

  def as_list=(as_list); end

  def gem_install_cmd(); end

  def gem_install_cmd=(gem_install_cmd); end

  def key(); end

  def key=(key); end

  def reset(); end

  def reset=(reset); end

  def run(*args); end

  def values(); end

  def values=(values); end
end

class YARD::CLI::Config
end

class YARD::CLI::Diff
  def run(*args); end
end

class YARD::CLI::Diff
end

class YARD::CLI::Display
  def format_objects(); end

  def initialize(*args); end

  def wrap_layout(contents); end
end

class YARD::CLI::Display
end

class YARD::CLI::Gems
  def run(*args); end
end

class YARD::CLI::Gems
end

class YARD::CLI::Graph
  def objects(); end

  def options(); end

  def run(*args); end
end

class YARD::CLI::Graph
end

class YARD::CLI::Help
  def run(*args); end
end

class YARD::CLI::Help
end

class YARD::CLI::I18n
end

class YARD::CLI::I18n
end

class YARD::CLI::List
  def run(*args); end
end

class YARD::CLI::List
end

class YARD::CLI::MarkupTypes
  def run(*args); end
end

class YARD::CLI::MarkupTypes
end

class YARD::CLI::Server
  def adapter(); end

  def adapter=(adapter); end

  def libraries(); end

  def libraries=(libraries); end

  def options(); end

  def options=(options); end

  def run(*args); end

  def scripts(); end

  def scripts=(scripts); end

  def server_options(); end

  def server_options=(server_options); end

  def template_paths(); end

  def template_paths=(template_paths); end
end

class YARD::CLI::Server
end

class YARD::CLI::Stats
  include ::YARD::Templates::Helpers::BaseHelper
  def initialize(parse=T.unsafe(nil)); end

  def output(name, data, undoc=T.unsafe(nil)); end

  def parse(); end

  def parse=(parse); end

  def print_statistics(); end

  def print_undocumented_objects(); end

  def stats_for_attributes(); end

  def stats_for_classes(); end

  def stats_for_constants(); end

  def stats_for_files(); end

  def stats_for_methods(); end

  def stats_for_modules(); end
  STATS_ORDER = ::T.let(nil, ::T.untyped)
end

class YARD::CLI::Stats
end

class YARD::CLI::YRI
  def cache_object(name, path); end

  def find_object(name); end

  def print_object(object); end

  def print_usage(); end

  def run(*args); end
  CACHE_FILE = ::T.let(nil, ::T.untyped)
  DEFAULT_SEARCH_PATHS = ::T.let(nil, ::T.untyped)
  SEARCH_PATHS_FILE = ::T.let(nil, ::T.untyped)
end

class YARD::CLI::YRI
end

class YARD::CLI::Yardoc
  def all_objects(); end

  def apis(); end

  def apis=(apis); end

  def assets(); end

  def assets=(assets); end

  def excluded(); end

  def excluded=(excluded); end

  def fail_on_warning(); end

  def fail_on_warning=(fail_on_warning); end

  def files(); end

  def files=(files); end

  def generate(); end

  def generate=(generate); end

  def has_markup(); end

  def has_markup=(has_markup); end

  def hidden_apis(); end

  def hidden_apis=(hidden_apis); end

  def hidden_tags(); end

  def hidden_tags=(hidden_tags); end

  def list(); end

  def list=(list); end

  def options(); end

  def run(*args); end

  def save_yardoc(); end

  def save_yardoc=(save_yardoc); end

  def statistics(); end

  def statistics=(statistics); end

  def use_cache(); end

  def use_cache=(use_cache); end

  def visibilities(); end

  def visibilities=(visibilities); end
end

class YARD::CLI::Yardoc
end

class YARD::CLI::YardocOptions
  def file(); end

  def file=(file); end

  def files(); end

  def files=(files); end

  def item(); end

  def item=(item); end

  def locale(); end

  def locale=(locale); end

  def objects(); end

  def objects=(objects); end

  def onefile(); end

  def onefile=(onefile); end

  def readme(); end

  def readme=(readme); end

  def title(); end

  def title=(title); end
end

class YARD::CLI::YardocOptions
end

class YARD::CLI::YardoptsCommand
  def options_file(); end

  def options_file=(options_file); end

  def parse_arguments(*args); end

  def use_document_file(); end

  def use_document_file=(use_document_file); end

  def use_yardopts_file(); end

  def use_yardopts_file=(use_yardopts_file); end

  def yardopts_options(opts); end
  DEFAULT_YARDOPTS_FILE = ::T.let(nil, ::T.untyped)
end

class YARD::CLI::YardoptsCommand
end

module YARD::CLI
end

module YARD::CodeObjects
  BUILTIN_ALL = ::T.let(nil, ::T.untyped)
  BUILTIN_CLASSES = ::T.let(nil, ::T.untyped)
  BUILTIN_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  BUILTIN_EXCEPTIONS_HASH = ::T.let(nil, ::T.untyped)
  BUILTIN_MODULES = ::T.let(nil, ::T.untyped)
  CONSTANTMATCH = ::T.let(nil, ::T.untyped)
  CONSTANTSTART = ::T.let(nil, ::T.untyped)
  CSEP = ::T.let(nil, ::T.untyped)
  CSEPQ = ::T.let(nil, ::T.untyped)
  ISEP = ::T.let(nil, ::T.untyped)
  ISEPQ = ::T.let(nil, ::T.untyped)
  METHODMATCH = ::T.let(nil, ::T.untyped)
  METHODNAMEMATCH = ::T.let(nil, ::T.untyped)
  NAMESPACEMATCH = ::T.let(nil, ::T.untyped)
  NSEP = ::T.let(nil, ::T.untyped)
  NSEPQ = ::T.let(nil, ::T.untyped)
  PROXY_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::CodeObjects::Base
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def add_file(file, line=T.unsafe(nil), has_comments=T.unsafe(nil)); end

  def add_tag(*tags); end

  def base_docstring(); end

  def copy_to(other); end

  def copyable_attributes(); end

  def docstring(locale=T.unsafe(nil)); end

  def docstring=(comments); end

  def dynamic(); end

  def dynamic=(dynamic); end

  def dynamic?(); end

  def eql?(other); end

  def equal?(other); end

  def file(); end

  def files(); end

  def format(options=T.unsafe(nil)); end

  def group(); end

  def group=(group); end

  def has_tag?(name); end

  def initialize(namespace, name, *_); end

  def line(); end

  def method_missing(meth, *args, &block); end

  def name(prefix=T.unsafe(nil)); end

  def namespace(); end

  def namespace=(obj); end

  def parent(); end

  def parent=(obj); end

  def path(); end

  def relative_path(other); end

  def root?(); end

  def sep(); end

  def signature(); end

  def signature=(signature); end

  def source(); end

  def source=(statement); end

  def source_type(); end

  def source_type=(source_type); end

  def tag(name); end

  def tags(name=T.unsafe(nil)); end

  def title(); end

  def to_ary(); end

  def type(); end

  def visibility(); end

  def visibility=(v); end
end

class YARD::CodeObjects::Base
  def self.===(other); end

  def self.new(namespace, name, *args, &block); end
end

class YARD::CodeObjects::ClassObject
  def inheritance_tree(include_mods=T.unsafe(nil)); end

  def inherited_constants(); end

  def inherited_meths(opts=T.unsafe(nil)); end

  def is_exception?(); end

  def superclass(); end

  def superclass=(object); end
end

class YARD::CodeObjects::ClassObject
end

class YARD::CodeObjects::ClassVariableObject
  def value(); end

  def value=(value); end
end

class YARD::CodeObjects::ClassVariableObject
end

class YARD::CodeObjects::CodeObjectList
  def <<(value); end

  def initialize(owner=T.unsafe(nil)); end

  def push(value); end
end

class YARD::CodeObjects::CodeObjectList
end

class YARD::CodeObjects::ConstantObject
  def value(); end

  def value=(value); end
end

class YARD::CodeObjects::ConstantObject
end

class YARD::CodeObjects::ExtendedMethodObject
  def initialize(obj); end

  def method_missing(sym, *args, &block); end

  def scope(); end
end

class YARD::CodeObjects::ExtendedMethodObject
end

class YARD::CodeObjects::ExtraFileObject
  def ==(other); end

  def attributes(); end

  def attributes=(attributes); end

  def contents(); end

  def contents=(contents); end

  def eql?(other); end

  def equal?(other); end

  def filename(); end

  def filename=(filename); end

  def initialize(filename, contents=T.unsafe(nil)); end

  def locale(); end

  def locale=(locale); end

  def name(); end

  def name=(name); end

  def path(); end

  def title(); end

  def type(); end
end

class YARD::CodeObjects::ExtraFileObject
end

class YARD::CodeObjects::MacroObject
  def attached?(); end

  def expand(call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil)); end

  def macro_data(); end

  def macro_data=(macro_data); end

  def method_object(); end

  def method_object=(method_object); end
  MACRO_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::CodeObjects::MacroObject
  def self.apply(docstring, call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil), _method_object=T.unsafe(nil)); end

  def self.apply_macro(macro, docstring, call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil)); end

  def self.create(macro_name, data, method_object=T.unsafe(nil)); end

  def self.create_docstring(macro_name, data, method_object=T.unsafe(nil)); end

  def self.expand(macro_data, call_params=T.unsafe(nil), full_source=T.unsafe(nil), block_source=T.unsafe(nil)); end

  def self.find(macro_name); end

  def self.find_or_create(macro_name, data, method_object=T.unsafe(nil)); end
end

class YARD::CodeObjects::MethodObject
  def aliases(); end

  def attr_info(); end

  def constructor?(); end

  def explicit(); end

  def explicit=(explicit); end

  def initialize(namespace, name, scope=T.unsafe(nil), &block); end

  def is_alias?(); end

  def is_attribute?(); end

  def is_explicit?(); end

  def module_function?(); end

  def overridden_method(); end

  def parameters(); end

  def parameters=(parameters); end

  def reader?(); end

  def scope(); end

  def scope=(v); end

  def writer?(); end
end

class YARD::CodeObjects::MethodObject
end

class YARD::CodeObjects::ModuleObject
  def inheritance_tree(include_mods=T.unsafe(nil)); end
end

class YARD::CodeObjects::ModuleObject
end

module YARD::CodeObjects::NamespaceMapper
  def clear_separators(); end

  def default_separator(value=T.unsafe(nil)); end

  def register_separator(sep, *valid_types); end

  def separators(); end

  def separators_for_type(type); end

  def separators_match(); end

  def types_for_separator(sep); end

  def unregister_separator_by_type(type); end
end

module YARD::CodeObjects::NamespaceMapper
  def self.default_separator(); end

  def self.default_separator=(default_separator); end

  def self.invalidate(); end

  def self.map(); end

  def self.map_match(); end

  def self.on_invalidate(&block); end

  def self.rev_map(); end
end

class YARD::CodeObjects::NamespaceObject
  def aliases(); end

  def attributes(); end

  def child(opts=T.unsafe(nil)); end

  def children(); end

  def class_attributes(); end

  def class_mixins(); end

  def constants(opts=T.unsafe(nil)); end

  def cvars(); end

  def groups(); end

  def groups=(groups); end

  def included_constants(); end

  def included_meths(opts=T.unsafe(nil)); end

  def initialize(namespace, name, *args, &block); end

  def instance_attributes(); end

  def instance_mixins(); end

  def meths(opts=T.unsafe(nil)); end

  def mixins(*scopes); end
end

class YARD::CodeObjects::NamespaceObject
end

class YARD::CodeObjects::Proxy
  def ==(other); end

  def ===(other); end

  def equal?(other); end

  def initialize(namespace, name, type=T.unsafe(nil)); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end

  def method_missing(meth, *args, &block); end

  def name(prefix=T.unsafe(nil)); end

  def namespace(); end

  def parent(); end

  def path(); end

  def respond_to?(meth, include_private=T.unsafe(nil)); end

  def root?(); end

  def title(); end

  def to_str(); end

  def type(); end

  def type=(type); end
end

class YARD::CodeObjects::Proxy
  def self.===(other); end
end

class YARD::CodeObjects::ProxyMethodError
end

class YARD::CodeObjects::ProxyMethodError
end

class YARD::CodeObjects::RootObject
end

class YARD::CodeObjects::RootObject
end

module YARD::CodeObjects
  extend ::YARD::CodeObjects::NamespaceMapper
end

class YARD::Config
  CONFIG_DIR = ::T.let(nil, ::T.untyped)
  CONFIG_FILE = ::T.let(nil, ::T.untyped)
  DEFAULT_CONFIG_OPTIONS = ::T.let(nil, ::T.untyped)
  IGNORED_PLUGINS = ::T.let(nil, ::T.untyped)
  YARD_PLUGIN_PREFIX = ::T.let(nil, ::T.untyped)
end

class YARD::Config
  def self.add_ignored_plugins_file(); end

  def self.arguments(); end

  def self.load(); end

  def self.load_autoload_plugins(); end

  def self.load_commandline_plugins(); end

  def self.load_commandline_safemode(); end

  def self.load_gem_plugins(); end

  def self.load_plugin(name); end

  def self.load_plugin_failed(name, exception); end

  def self.load_plugins(); end

  def self.options(); end

  def self.options=(options); end

  def self.read_config_file(); end

  def self.save(); end

  def self.translate_plugin_name(name); end

  def self.translate_plugin_names(); end

  def self.with_yardopts(); end
end

class YARD::Docstring
  def +(other); end

  def add_tag(*tags); end

  def all(); end

  def all=(content, parse=T.unsafe(nil)); end

  def blank?(only_visible_tags=T.unsafe(nil)); end

  def delete_tag_if(&block); end

  def delete_tags(name); end

  def has_tag?(name); end

  def hash_flag(); end

  def hash_flag=(v); end

  def initialize(content=T.unsafe(nil), object=T.unsafe(nil)); end

  def line(); end

  def line_range(); end

  def line_range=(line_range); end

  def object(); end

  def object=(object); end

  def ref_tags(); end

  def replace(content, parse=T.unsafe(nil)); end

  def resolve_reference(); end

  def summary(); end

  def tag(name); end

  def tags(name=T.unsafe(nil)); end

  def to_raw(); end
  META_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Docstring
  def self.default_parser(); end

  def self.default_parser=(default_parser); end

  def self.new!(text, tags=T.unsafe(nil), object=T.unsafe(nil), raw_data=T.unsafe(nil), ref_object=T.unsafe(nil)); end

  def self.parser(*args); end
end

class YARD::DocstringParser
  def create_directive(tag_name, tag_buf); end

  def create_ref_tag(tag_name, name, object_name); end

  def create_tag(tag_name, tag_buf=T.unsafe(nil)); end

  def directives(); end

  def directives=(directives); end

  def handler(); end

  def handler=(handler); end

  def initialize(library=T.unsafe(nil)); end

  def library(); end

  def library=(library); end

  def object(); end

  def object=(object); end

  def parse(content, object=T.unsafe(nil), handler=T.unsafe(nil)); end

  def parse_content(content); end

  def post_process(); end

  def raw_text(); end

  def raw_text=(raw_text); end

  def reference(); end

  def reference=(reference); end

  def state(); end

  def state=(state); end

  def tag_is_directive?(tag_name); end

  def tags(); end

  def tags=(tags); end

  def text(); end

  def text=(text); end

  def to_docstring(); end
  META_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::DocstringParser
  def self.after_parse(&block); end

  def self.after_parse_callbacks(); end
end

module YARD::GemIndex
end

module YARD::GemIndex
  def self.all(); end

  def self.each(&block); end

  def self.find_all_by_name(*args); end
end

module YARD::Handlers
end

class YARD::Handlers::Base
  include ::YARD::CodeObjects
  include ::YARD::Parser
  def abort!(); end

  def call_params(); end

  def caller_method(); end

  def ensure_loaded!(object, max_retries=T.unsafe(nil)); end

  def extra_state(); end

  def globals(); end

  def initialize(source_parser, stmt); end

  def namespace(); end

  def namespace=(v); end

  def owner(); end

  def owner=(v); end

  def parse_block(*_); end

  def parser(); end

  def process(); end

  def push_state(opts=T.unsafe(nil)); end

  def register(*objects); end

  def register_docstring(object, docstring=T.unsafe(nil), stmt=T.unsafe(nil)); end

  def register_dynamic(object); end

  def register_ensure_loaded(object); end

  def register_file_info(object, file=T.unsafe(nil), line=T.unsafe(nil), comments=T.unsafe(nil)); end

  def register_group(object, group=T.unsafe(nil)); end

  def register_module_function(object); end

  def register_source(object, source=T.unsafe(nil), type=T.unsafe(nil)); end

  def register_transitive_tags(object); end

  def register_visibility(object, visibility=T.unsafe(nil)); end

  def scope(); end

  def scope=(v); end

  def statement(); end

  def visibility(); end

  def visibility=(v); end
end

class YARD::Handlers::Base
  def self.clear_subclasses(); end

  def self.handlers(); end

  def self.handles(*matches); end

  def self.handles?(statement); end

  def self.in_file(filename); end

  def self.inherited(subclass); end

  def self.matches_file?(filename); end

  def self.namespace_only(); end

  def self.namespace_only?(); end

  def self.process(&block); end
end

module YARD::Handlers::C
end

class YARD::Handlers::C::AliasHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::AliasHandler
end

class YARD::Handlers::C::AttributeHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::AttributeHandler
end

class YARD::Handlers::C::Base
  include ::YARD::Handlers::C::HandlerMethods
  include ::YARD::Parser::C
  include ::YARD::Handlers::Common::MethodHandler
  def ensure_variable_defined!(var, max_retries=T.unsafe(nil)); end

  def namespace_for_variable(var); end

  def namespaces(); end

  def override_comments(); end

  def parse_block(opts=T.unsafe(nil)); end

  def process_file(file, object); end

  def processed_files(); end

  def symbols(); end
end

class YARD::Handlers::C::Base
  def self.handles?(statement, processor); end

  def self.statement_class(type=T.unsafe(nil)); end
end

class YARD::Handlers::C::ClassHandler
  MATCH1 = ::T.let(nil, ::T.untyped)
  MATCH2 = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::ClassHandler
end

class YARD::Handlers::C::ConstantHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::ConstantHandler
end

module YARD::Handlers::C::HandlerMethods
  include ::YARD::Parser::C
  include ::YARD::CodeObjects
  include ::YARD::Handlers::Common::MethodHandler
  def handle_alias(var_name, new_name, old_name); end

  def handle_attribute(var_name, name, read, write); end

  def handle_class(var_name, class_name, parent, in_module=T.unsafe(nil)); end

  def handle_constants(type, var_name, const_name, value); end

  def handle_method(scope, var_name, name, func_name, _source_file=T.unsafe(nil)); end

  def handle_module(var_name, module_name, in_module=T.unsafe(nil)); end
end

module YARD::Handlers::C::HandlerMethods
end

class YARD::Handlers::C::InitHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::InitHandler
end

class YARD::Handlers::C::MethodHandler
  MATCH1 = ::T.let(nil, ::T.untyped)
  MATCH2 = ::T.let(nil, ::T.untyped)
  MATCH3 = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::MethodHandler
end

class YARD::Handlers::C::MixinHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::MixinHandler
end

class YARD::Handlers::C::ModuleHandler
  MATCH1 = ::T.let(nil, ::T.untyped)
  MATCH2 = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::ModuleHandler
end

class YARD::Handlers::C::OverrideCommentHandler
end

class YARD::Handlers::C::OverrideCommentHandler
end

class YARD::Handlers::C::PathHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::PathHandler
end

class YARD::Handlers::C::StructHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::StructHandler
end

class YARD::Handlers::C::SymbolHandler
  MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::C::SymbolHandler
end

module YARD::Handlers::C
end

module YARD::Handlers::Common
end

module YARD::Handlers::Common::MethodHandler
  def add_predicate_return_tag(obj); end
end

module YARD::Handlers::Common::MethodHandler
end

module YARD::Handlers::Common
end

class YARD::Handlers::HandlerAborted
end

class YARD::Handlers::HandlerAborted
end

class YARD::Handlers::NamespaceMissingError
  def initialize(object); end

  def object(); end

  def object=(object); end
end

class YARD::Handlers::NamespaceMissingError
end

class YARD::Handlers::Processor
  def extra_state(); end

  def extra_state=(extra_state); end

  def file(); end

  def file=(file); end

  def find_handlers(statement); end

  def globals(); end

  def globals=(globals); end

  def initialize(parser); end

  def namespace(); end

  def namespace=(namespace); end

  def owner(); end

  def owner=(owner); end

  def parse_remaining_files(); end

  def parser_type(); end

  def parser_type=(parser_type); end

  def process(statements); end

  def scope(); end

  def scope=(scope); end

  def visibility(); end

  def visibility=(visibility); end
end

class YARD::Handlers::Processor
  def self.namespace_for_handler(); end

  def self.register_handler_namespace(type, ns); end
end

module YARD::Handlers::Ruby
end

class YARD::Handlers::Ruby::AliasHandler
end

class YARD::Handlers::Ruby::AliasHandler
end

class YARD::Handlers::Ruby::AttributeHandler
  def validated_attribute_names(params); end
end

class YARD::Handlers::Ruby::AttributeHandler
end

class YARD::Handlers::Ruby::Base
  include ::YARD::Parser::Ruby
  def parse_block(inner_node, opts=T.unsafe(nil)); end
end

class YARD::Handlers::Ruby::Base
  extend ::YARD::Parser::Ruby
  def self.handles?(node); end

  def self.meta_type(type); end

  def self.method_call(name=T.unsafe(nil)); end
end

class YARD::Handlers::Ruby::ClassConditionHandler
  def parse_condition(); end

  def parse_else_block(); end

  def parse_then_block(); end
end

class YARD::Handlers::Ruby::ClassConditionHandler
end

class YARD::Handlers::Ruby::ClassHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
end

class YARD::Handlers::Ruby::ClassHandler
end

class YARD::Handlers::Ruby::ClassVariableHandler
end

class YARD::Handlers::Ruby::ClassVariableHandler
end

class YARD::Handlers::Ruby::CommentHandler
end

class YARD::Handlers::Ruby::CommentHandler
end

class YARD::Handlers::Ruby::ConstantHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
end

class YARD::Handlers::Ruby::ConstantHandler
end

class YARD::Handlers::Ruby::DSLHandler
  include ::YARD::Handlers::Ruby::DSLHandlerMethods
end

class YARD::Handlers::Ruby::DSLHandler
end

module YARD::Handlers::Ruby::DSLHandlerMethods
  include ::YARD::CodeObjects
  include ::YARD::Parser
  def handle_comments(); end

  def register_docstring(object, docstring=T.unsafe(nil), stmt=T.unsafe(nil)); end
  IGNORE_METHODS = ::T.let(nil, ::T.untyped)
end

module YARD::Handlers::Ruby::DSLHandlerMethods
end

module YARD::Handlers::Ruby::DecoratorHandlerMethods
  def process_decorator(*nodes, &block); end
end

module YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::ExceptionHandler
end

class YARD::Handlers::Ruby::ExceptionHandler
end

class YARD::Handlers::Ruby::ExtendHandler
end

class YARD::Handlers::Ruby::ExtendHandler
end

class YARD::Handlers::Ruby::HandlesExtension
  def initialize(name); end

  def matches?(node); end

  def name(); end
end

class YARD::Handlers::Ruby::HandlesExtension
end

module YARD::Handlers::Ruby::Legacy
end

class YARD::Handlers::Ruby::Legacy::AliasHandler
end

class YARD::Handlers::Ruby::Legacy::AliasHandler
end

class YARD::Handlers::Ruby::Legacy::AttributeHandler
end

class YARD::Handlers::Ruby::Legacy::AttributeHandler
end

class YARD::Handlers::Ruby::Legacy::Base
  include ::YARD::Parser::Ruby::Legacy::RubyToken
  def parse_block(opts=T.unsafe(nil)); end
end

class YARD::Handlers::Ruby::Legacy::Base
  def self.handles?(stmt); end
end

class YARD::Handlers::Ruby::Legacy::ClassConditionHandler
  def parse_condition(); end

  def parse_else_block(); end

  def parse_then_block(); end
end

class YARD::Handlers::Ruby::Legacy::ClassConditionHandler
end

class YARD::Handlers::Ruby::Legacy::ClassHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
end

class YARD::Handlers::Ruby::Legacy::ClassHandler
end

class YARD::Handlers::Ruby::Legacy::ClassVariableHandler
  HANDLER_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::Ruby::Legacy::ClassVariableHandler
end

class YARD::Handlers::Ruby::Legacy::CommentHandler
end

class YARD::Handlers::Ruby::Legacy::CommentHandler
end

class YARD::Handlers::Ruby::Legacy::ConstantHandler
  include ::YARD::Handlers::Ruby::StructHandlerMethods
  HANDLER_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Handlers::Ruby::Legacy::ConstantHandler
end

class YARD::Handlers::Ruby::Legacy::DSLHandler
  include ::YARD::Handlers::Ruby::DSLHandlerMethods
end

class YARD::Handlers::Ruby::Legacy::DSLHandler
end

class YARD::Handlers::Ruby::Legacy::ExceptionHandler
end

class YARD::Handlers::Ruby::Legacy::ExceptionHandler
end

class YARD::Handlers::Ruby::Legacy::ExtendHandler
end

class YARD::Handlers::Ruby::Legacy::ExtendHandler
end

class YARD::Handlers::Ruby::Legacy::MethodHandler
end

class YARD::Handlers::Ruby::Legacy::MethodHandler
end

class YARD::Handlers::Ruby::Legacy::MixinHandler
end

class YARD::Handlers::Ruby::Legacy::MixinHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleFunctionHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleFunctionHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleHandler
end

class YARD::Handlers::Ruby::Legacy::ModuleHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateClassMethodHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateClassMethodHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateConstantHandler
end

class YARD::Handlers::Ruby::Legacy::PrivateConstantHandler
end

class YARD::Handlers::Ruby::Legacy::VisibilityHandler
end

class YARD::Handlers::Ruby::Legacy::VisibilityHandler
end

class YARD::Handlers::Ruby::Legacy::YieldHandler
end

class YARD::Handlers::Ruby::Legacy::YieldHandler
end

module YARD::Handlers::Ruby::Legacy
end

class YARD::Handlers::Ruby::MethodCallWrapper
end

class YARD::Handlers::Ruby::MethodCallWrapper
end

class YARD::Handlers::Ruby::MethodConditionHandler
end

class YARD::Handlers::Ruby::MethodConditionHandler
end

class YARD::Handlers::Ruby::MethodHandler
  include ::YARD::Handlers::Common::MethodHandler
  def format_args(); end
end

class YARD::Handlers::Ruby::MethodHandler
end

class YARD::Handlers::Ruby::MixinHandler
  def process_mixin(mixin); end

  def recipient(mixin); end
end

class YARD::Handlers::Ruby::MixinHandler
end

class YARD::Handlers::Ruby::ModuleFunctionHandler
end

class YARD::Handlers::Ruby::ModuleFunctionHandler
end

class YARD::Handlers::Ruby::ModuleHandler
end

class YARD::Handlers::Ruby::ModuleHandler
end

class YARD::Handlers::Ruby::PrivateClassMethodHandler
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::PrivateClassMethodHandler
end

class YARD::Handlers::Ruby::PrivateConstantHandler
end

class YARD::Handlers::Ruby::PrivateConstantHandler
end

class YARD::Handlers::Ruby::PublicClassMethodHandler
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::PublicClassMethodHandler
end

module YARD::Handlers::Ruby::StructHandlerMethods
  include ::YARD::CodeObjects
  def add_reader_tags(klass, new_method, member); end

  def add_writer_tags(klass, new_method, member); end

  def create_attributes(klass, members); end

  def create_class(classname, superclass); end

  def create_member_method?(klass, member, type=T.unsafe(nil)); end

  def create_reader(klass, member); end

  def create_writer(klass, member); end

  def member_tag_for_member(klass, member, type=T.unsafe(nil)); end

  def members_from_tags(klass); end

  def return_type_from_tag(member_tag); end
end

module YARD::Handlers::Ruby::StructHandlerMethods
end

class YARD::Handlers::Ruby::TestNodeWrapper
end

class YARD::Handlers::Ruby::TestNodeWrapper
end

class YARD::Handlers::Ruby::VisibilityHandler
  include ::YARD::Handlers::Ruby::DecoratorHandlerMethods
end

class YARD::Handlers::Ruby::VisibilityHandler
end

class YARD::Handlers::Ruby::YieldHandler
end

class YARD::Handlers::Ruby::YieldHandler
end

module YARD::Handlers::Ruby
end

module YARD::Handlers
end

module YARD::I18n
end

class YARD::I18n::Locale
  def initialize(name); end

  def load(locale_directory); end

  def name(); end

  def translate(message); end
end

class YARD::I18n::Locale
  def self.default(); end

  def self.default=(locale); end
end

class YARD::I18n::Message
  def ==(other); end

  def add_comment(comment); end

  def add_location(path, line); end

  def comments(); end

  def id(); end

  def initialize(id); end

  def locations(); end
end

class YARD::I18n::Message
end

class YARD::I18n::Messages
  include ::Enumerable
  def ==(other); end

  def [](id); end

  def each(&block); end

  def messages(); end

  def register(id); end
end

class YARD::I18n::Messages
end

class YARD::I18n::PotGenerator
  def generate(); end

  def initialize(relative_base_path); end

  def messages(); end

  def parse_files(files); end

  def parse_objects(objects); end
end

class YARD::I18n::PotGenerator
end

class YARD::I18n::Text
  def extract_messages(); end

  def initialize(input, options=T.unsafe(nil)); end

  def translate(locale); end
end

class YARD::I18n::Text
end

module YARD::I18n
end

class YARD::Logger
  def <<(msg=T.unsafe(nil)); end

  def backtrace(exc, level_meth=T.unsafe(nil)); end

  def capture(msg, nontty_log=T.unsafe(nil)); end

  def clear_progress(); end

  def debug(*args); end

  def enter_level(new_level=T.unsafe(nil)); end

  def initialize(pipe, *args); end

  def io(); end

  def io=(pipe); end

  def print(msg=T.unsafe(nil)); end

  def progress(msg, nontty_log=T.unsafe(nil)); end

  def puts(msg=T.unsafe(nil)); end

  def show_backtraces(); end

  def show_backtraces=(show_backtraces); end

  def show_progress(); end

  def show_progress=(show_progress); end

  def warn(*args); end

  def warn_no_continuations(); end

  def warned(); end

  def warned=(warned); end
  PROGRESS_INDICATORS = ::T.let(nil, ::T.untyped)
end

class YARD::Logger
  def self.instance(pipe=T.unsafe(nil)); end
end

class YARD::Options
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def delete(key); end

  def each(&blk); end

  def merge(opts); end

  def method_missing(meth, *args, &block); end

  def reset_defaults(); end

  def to_hash(); end

  def update(opts); end
end

class YARD::Options
  def self.default_attr(key, default); end
end

module YARD::Parser
end

class YARD::Parser::Base
  def enumerator(); end

  def initialize(source, filename); end

  def parse(); end

  def tokenize(); end
end

class YARD::Parser::Base
  def self.parse(source, filename=T.unsafe(nil)); end
end

module YARD::Parser::C
end

module YARD::Parser::C
end

class YARD::Parser::OrderedParser
  def files(); end

  def files=(files); end

  def initialize(global_state, files); end

  def parse(); end
end

class YARD::Parser::OrderedParser
end

class YARD::Parser::ParserSyntaxError
end

class YARD::Parser::ParserSyntaxError
end

module YARD::Parser::Ruby
  def s(*args); end
end

module YARD::Parser::Ruby::Legacy::RubyToken
  def Token(token, value=T.unsafe(nil)); end

  def set_token_position(line, char); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  NEWLINE_TOKEN = ::T.let(nil, ::T.untyped)
  TkReading2Token = ::T.let(nil, ::T.untyped)
  TkSymbol2Token = ::T.let(nil, ::T.untyped)
  TokenDefinitions = ::T.let(nil, ::T.untyped)
end

module YARD::Parser::Ruby::Legacy::RubyToken
  def self.def_token(token_n, super_token=T.unsafe(nil), reading=T.unsafe(nil), *opts); end
end

module YARD::Parser::Ruby
end

class YARD::Parser::SourceParser
  def contents(); end

  def file(); end

  def file=(file); end

  def globals(); end

  def initialize(parser_type=T.unsafe(nil), globals1=T.unsafe(nil), globals2=T.unsafe(nil)); end

  def parse(content=T.unsafe(nil)); end

  def parser_type(); end

  def tokenize(content); end
  DEFAULT_PATH_GLOB = ::T.let(nil, ::T.untyped)
  ENCODING_BYTE_ORDER_MARKS = ::T.let(nil, ::T.untyped)
  ENCODING_LINE = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LINE = ::T.let(nil, ::T.untyped)
  SHEBANG_LINE = ::T.let(nil, ::T.untyped)
end

class YARD::Parser::SourceParser
  def self.after_parse_file(&block); end

  def self.after_parse_file_callbacks(); end

  def self.after_parse_list(&block); end

  def self.after_parse_list_callbacks(); end

  def self.before_parse_file(&block); end

  def self.before_parse_file_callbacks(); end

  def self.before_parse_list(&block); end

  def self.before_parse_list_callbacks(); end

  def self.parse(paths=T.unsafe(nil), excluded=T.unsafe(nil), level=T.unsafe(nil)); end

  def self.parse_string(content, ptype=T.unsafe(nil)); end

  def self.parser_type(); end

  def self.parser_type=(value); end

  def self.parser_type_extensions(); end

  def self.parser_type_extensions=(value); end

  def self.parser_type_for_extension(extension); end

  def self.parser_types(); end

  def self.parser_types=(value); end

  def self.register_parser_type(type, parser_klass, extensions=T.unsafe(nil)); end

  def self.tokenize(content, ptype=T.unsafe(nil)); end

  def self.validated_parser_type(type); end
end

class YARD::Parser::UndocumentableError
end

class YARD::Parser::UndocumentableError
end

module YARD::Parser
end

module YARD::Rake
end

class YARD::Rake::YardocTask
  def after(); end

  def after=(after); end

  def before(); end

  def before=(before); end

  def define(); end

  def files(); end

  def files=(files); end

  def initialize(name=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def options(); end

  def options=(options); end

  def stats_options(); end

  def stats_options=(stats_options); end

  def verifier(); end

  def verifier=(verifier); end
end

class YARD::Rake::YardocTask
end

module YARD::Rake
end

module YARD::Registry
  DEFAULT_PO_DIR = ::T.let(nil, ::T.untyped)
  DEFAULT_YARDOC_FILE = ::T.let(nil, ::T.untyped)
  LOCAL_YARDOC_INDEX = ::T.let(nil, ::T.untyped)
end

module YARD::Registry
  extend ::Enumerable
  def self.[](path); end

  def self.all(*types); end

  def self.at(path); end

  def self.checksum_for(data); end

  def self.checksums(); end

  def self.clear(); end

  def self.delete(object); end

  def self.delete_from_disk(); end

  def self.each(&block); end

  def self.instance(); end

  def self.load(files=T.unsafe(nil), reparse=T.unsafe(nil)); end

  def self.load!(file=T.unsafe(nil)); end

  def self.load_all(); end

  def self.load_yardoc(file=T.unsafe(nil)); end

  def self.locale(name); end

  def self.lock_for_writing(file=T.unsafe(nil), &block); end

  def self.locked_for_writing?(file=T.unsafe(nil)); end

  def self.paths(reload=T.unsafe(nil)); end

  def self.po_dir(); end

  def self.po_dir=(dir); end

  def self.proxy_types(); end

  def self.register(object); end

  def self.resolve(namespace, name, inheritance=T.unsafe(nil), proxy_fallback=T.unsafe(nil), type=T.unsafe(nil)); end

  def self.root(); end

  def self.save(merge=T.unsafe(nil), file=T.unsafe(nil)); end

  def self.single_object_db(); end

  def self.single_object_db=(v); end

  def self.yardoc_file(); end

  def self.yardoc_file=(v); end

  def self.yardoc_file_for_gem(gem, ver_require=T.unsafe(nil), for_writing=T.unsafe(nil)); end
end

class YARD::RegistryResolver
  include ::YARD::CodeObjects::NamespaceMapper
  def initialize(registry=T.unsafe(nil)); end

  def lookup_by_path(path, opts=T.unsafe(nil)); end
end

class YARD::RegistryResolver
end

class YARD::RegistryStore
  def [](key); end

  def []=(key, value); end

  def checksums(); end

  def checksums_path(); end

  def delete(key); end

  def destroy(force=T.unsafe(nil)); end

  def file(); end

  def get(key); end

  def keys(reload=T.unsafe(nil)); end

  def load(file=T.unsafe(nil)); end

  def load!(file=T.unsafe(nil)); end

  def load_all(); end

  def load_yardoc(); end

  def locale(name); end

  def lock_for_writing(file=T.unsafe(nil), &block); end

  def locked_for_writing?(file=T.unsafe(nil)); end

  def object_types_path(); end

  def objects_path(); end

  def paths_for_type(type, reload=T.unsafe(nil)); end

  def proxy_types(); end

  def proxy_types_path(); end

  def put(key, value); end

  def root(); end

  def save(merge=T.unsafe(nil), file=T.unsafe(nil)); end

  def values(reload=T.unsafe(nil)); end

  def values_for_type(type, reload=T.unsafe(nil)); end
end

class YARD::RegistryStore
end

module YARD::Serializers
end

class YARD::Serializers::Base
  def after_serialize(data); end

  def before_serialize(); end

  def exists?(object); end

  def initialize(opts=T.unsafe(nil)); end

  def options(); end

  def serialize(object, data); end

  def serialized_path(object); end
end

class YARD::Serializers::Base
end

class YARD::Serializers::FileSystemSerializer
  def basepath(); end

  def basepath=(value); end

  def extension(); end

  def extension=(value); end
end

class YARD::Serializers::FileSystemSerializer
end

class YARD::Serializers::ProcessSerializer
  def initialize(cmd); end

  def serialize(_object, data); end
end

class YARD::Serializers::ProcessSerializer
end

class YARD::Serializers::StdoutSerializer
  def initialize(wrap=T.unsafe(nil)); end

  def serialize(_object, data); end
end

class YARD::Serializers::StdoutSerializer
end

class YARD::Serializers::YardocSerializer
  def checksums_path(); end

  def complete?(); end

  def complete_lock_path(); end

  def deserialize(path, is_path=T.unsafe(nil)); end

  def initialize(yfile); end

  def lock_for_writing(); end

  def locked_for_writing?(); end

  def object_types_path(); end

  def objects_path(); end

  def processing_path(); end

  def proxy_types_path(); end

  def serialize(object); end
end

class YARD::Serializers::YardocSerializer
end

module YARD::Serializers
end

module YARD::Server
end

class YARD::Server::Adapter
  def add_library(library); end

  def document_root(); end

  def document_root=(document_root); end

  def initialize(libs, opts=T.unsafe(nil), server_opts=T.unsafe(nil)); end

  def libraries(); end

  def libraries=(libraries); end

  def options(); end

  def options=(options); end

  def router(); end

  def router=(router); end

  def server_options(); end

  def server_options=(server_options); end

  def start(); end
end

class YARD::Server::Adapter
  def self.setup(); end

  def self.shutdown(); end
end

module YARD::Server::Commands
end

class YARD::Server::Commands::Base
  def adapter(); end

  def adapter=(adapter); end

  def body(); end

  def body=(body); end

  def cache(data); end

  def caching(); end

  def caching=(caching); end

  def call(request); end

  def command_options(); end

  def command_options=(command_options); end

  def headers(); end

  def headers=(headers); end

  def initialize(opts=T.unsafe(nil)); end

  def not_found(); end

  def path(); end

  def path=(path); end

  def redirect(url); end

  def render(object=T.unsafe(nil)); end

  def request(); end

  def request=(request); end

  def run(); end

  def status(); end

  def status=(status); end
end

class YARD::Server::Commands::Base
end

class YARD::Server::Commands::DisplayFileCommand
  def index(); end

  def index=(index); end
end

class YARD::Server::Commands::DisplayFileCommand
end

class YARD::Server::Commands::DisplayObjectCommand
  include ::YARD::Server::DocServerHelper
  def index(); end
end

class YARD::Server::Commands::DisplayObjectCommand
end

class YARD::Server::Commands::FramesCommand
end

class YARD::Server::Commands::FramesCommand
end

class YARD::Server::Commands::LibraryCommand
  def incremental(); end

  def incremental=(incremental); end

  def library(); end

  def library=(library); end

  def options(); end

  def options=(options); end

  def serializer(); end

  def serializer=(serializer); end

  def single_library(); end

  def single_library=(single_library); end

  def use_fork(); end

  def use_fork=(use_fork); end
  CAN_FORK = ::T.let(nil, ::T.untyped)
end

class YARD::Server::Commands::LibraryCommand
end

class YARD::Server::Commands::LibraryIndexCommand
  def options(); end

  def options=(options); end
end

class YARD::Server::Commands::LibraryIndexCommand
end

class YARD::Server::Commands::ListCommand
  include ::YARD::Templates::Helpers::BaseHelper
end

class YARD::Server::Commands::ListCommand
end

class YARD::Server::Commands::RootRequestCommand
  include ::YARD::Server::Commands::StaticFileHelpers
  include ::WEBrick::HTTPUtils
end

class YARD::Server::Commands::RootRequestCommand
end

class YARD::Server::Commands::SearchCommand
  include ::YARD::Templates::Helpers::BaseHelper
  include ::YARD::Templates::Helpers::ModuleHelper
  include ::YARD::Server::DocServerHelper
  def query(); end

  def query=(query); end

  def results(); end

  def results=(results); end

  def visible_results(); end
end

class YARD::Server::Commands::SearchCommand
end

class YARD::Server::Commands::StaticFileCommand
  include ::YARD::Server::Commands::StaticFileHelpers
  include ::WEBrick::HTTPUtils
  STATIC_PATHS = ::T.let(nil, ::T.untyped)
end

class YARD::Server::Commands::StaticFileCommand
end

module YARD::Server::Commands::StaticFileHelpers
  include ::WEBrick::HTTPUtils
  def favicon?(); end

  def static_template_file?(); end
end

module YARD::Server::Commands::StaticFileHelpers
  def self.find_file(adapter, url); end
end

module YARD::Server::Commands
end

module YARD::Server::DocServerHelper
  def abs_url(*path_components); end

  def base_path(path); end

  def mtime(file); end

  def mtime_url(file); end

  def router(); end

  def url_for(obj, anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def url_for_file(filename, anchor=T.unsafe(nil)); end

  def url_for_frameset(); end

  def url_for_index(); end

  def url_for_list(type); end

  def url_for_main(); end
end

module YARD::Server::DocServerHelper
end

class YARD::Server::DocServerSerializer
  def initialize(_command=T.unsafe(nil)); end
end

class YARD::Server::DocServerSerializer
end

class YARD::Server::FinishRequest
end

class YARD::Server::FinishRequest
end

class YARD::Server::LibraryVersion
  def ==(other); end

  def eql?(other); end

  def equal?(other); end

  def gemspec(); end

  def initialize(name, version=T.unsafe(nil), yardoc=T.unsafe(nil), source=T.unsafe(nil)); end

  def load_yardoc_from_disk(); end

  def load_yardoc_from_gem(); end

  def name(); end

  def name=(name); end

  def prepare!(); end

  def ready?(); end

  def source(); end

  def source=(source); end

  def source_path(); end

  def source_path=(source_path); end

  def source_path_for_disk(); end

  def source_path_for_gem(); end

  def to_s(url_format=T.unsafe(nil)); end

  def version(); end

  def version=(version); end

  def yardoc_file(); end

  def yardoc_file=(yardoc_file); end

  def yardoc_file_for_gem(); end
end

class YARD::Server::LibraryVersion
end

class YARD::Server::NotFoundError
end

class YARD::Server::NotFoundError
end

class YARD::Server::RackAdapter
  include ::WEBrick::HTTPUtils
  def call(env); end
end

class YARD::Server::RackAdapter
end

class YARD::Server::RackMiddleware
  def call(env); end

  def initialize(app, opts=T.unsafe(nil)); end
end

class YARD::Server::RackMiddleware
end

class YARD::Server::Router
  include ::YARD::Server::StaticCaching
  include ::YARD::Server::Commands
  def adapter(); end

  def adapter=(adapter); end

  def call(request); end

  def docs_prefix(); end

  def final_options(library, paths); end

  def initialize(adapter); end

  def list_prefix(); end

  def parse_library_from_path(paths); end

  def request(); end

  def request=(request); end

  def route(path=T.unsafe(nil)); end

  def route_docs(library, paths); end

  def route_index(); end

  def route_list(library, paths); end

  def route_search(library, paths); end

  def route_static(library, paths); end

  def search_prefix(); end

  def static_prefix(); end
end

class YARD::Server::Router
end

module YARD::Server::StaticCaching
  def check_static_cache(); end
end

module YARD::Server::StaticCaching
end

class YARD::Server::WebrickAdapter
end

class YARD::Server::WebrickAdapter
end

class YARD::Server::WebrickServlet
  def adapter(); end

  def adapter=(adapter); end

  def do_GET(request, response); end

  def initialize(server, adapter); end
end

class YARD::Server::WebrickServlet
end

module YARD::Server
  def self.register_static_path(path); end
end

class YARD::StubProxy
  def _dump(_depth); end

  def initialize(path, transient=T.unsafe(nil)); end

  def method_missing(meth, *args, &block); end
  FILELEN = ::T.let(nil, ::T.untyped)
end

class YARD::StubProxy
  def self._load(str); end
end

module YARD::Tags
end

class YARD::Tags::AttributeDirective
end

class YARD::Tags::AttributeDirective
end

class YARD::Tags::DefaultFactory
  def parse_tag(tag_name, text); end

  def parse_tag_with_name(tag_name, text); end

  def parse_tag_with_options(tag_name, text); end

  def parse_tag_with_title_and_text(tag_name, text); end

  def parse_tag_with_types(tag_name, text); end

  def parse_tag_with_types_and_name(tag_name, text); end

  def parse_tag_with_types_and_title(tag_name, text); end

  def parse_tag_with_types_name_and_default(tag_name, text); end
  TYPELIST_CLOSING_CHARS = ::T.let(nil, ::T.untyped)
  TYPELIST_OPENING_CHARS = ::T.let(nil, ::T.untyped)
end

class YARD::Tags::DefaultFactory
end

class YARD::Tags::DefaultTag
  def defaults(); end

  def initialize(tag_name, text, types=T.unsafe(nil), name=T.unsafe(nil), defaults=T.unsafe(nil)); end
end

class YARD::Tags::DefaultTag
end

class YARD::Tags::Directive
  def after_parse(); end

  def call(); end

  def expanded_text(); end

  def expanded_text=(expanded_text); end

  def handler(); end

  def initialize(tag, parser); end

  def object(); end

  def parser(); end

  def parser=(parser); end

  def tag(); end

  def tag=(tag); end
end

class YARD::Tags::Directive
end

class YARD::Tags::EndGroupDirective
end

class YARD::Tags::EndGroupDirective
end

class YARD::Tags::GroupDirective
end

class YARD::Tags::GroupDirective
end

class YARD::Tags::Library
  def abstract_tag(text); end

  def api_tag(text); end

  def attr_reader_tag(text); end

  def attr_tag(text); end

  def attr_writer_tag(text); end

  def attribute_directive(tag, parser); end

  def author_tag(text); end

  def deprecated_tag(text); end

  def directive_create(tag_name, tag_buf, parser); end

  def domain_directive(tag, parser); end

  def endgroup_directive(tag, parser); end

  def example_tag(text); end

  def factory(); end

  def factory=(factory); end

  def group_directive(tag, parser); end

  def has_directive?(tag_name); end

  def has_tag?(tag_name); end

  def initialize(factory=T.unsafe(nil)); end

  def macro_directive(tag, parser); end

  def method_directive(tag, parser); end

  def note_tag(text); end

  def option_tag(text); end

  def overload_tag(text); end

  def override_directive(tag, parser); end

  def param_tag(text); end

  def param_tuple_tag(text); end

  def parse_directive(tag, parser); end

  def private_tag(text); end

  def raise_tag(text); end

  def return_single_parameter_tag(text); end

  def return_tag(text); end

  def return_value_parameter_tag(text); end

  def scope_directive(tag, parser); end

  def see_tag(text); end

  def since_tag(text); end

  def tag_create(tag_name, tag_buf); end

  def todo_tag(text); end

  def type_tag(text); end

  def version_tag(text); end

  def visibility_directive(tag, parser); end

  def yield_tag(text); end

  def yieldparam_single_parameter_tag(text); end

  def yieldparam_tag(text); end

  def yieldpublic_tag(text); end

  def yieldreturn_tag(text); end

  def yieldself_tag(text); end
end

class YARD::Tags::Library
  def self.default_factory(); end

  def self.default_factory=(factory); end

  def self.define_directive(tag, tag_meth=T.unsafe(nil), directive_class=T.unsafe(nil)); end

  def self.define_tag(label, tag, meth=T.unsafe(nil)); end

  def self.directive_method_name(tag_name); end

  def self.factory_method_for(tag); end

  def self.factory_method_for_directive(directive); end

  def self.instance(); end

  def self.labels(); end

  def self.sorted_labels(); end

  def self.tag_method_name(tag_name); end

  def self.transitive_tags(); end

  def self.transitive_tags=(transitive_tags); end

  def self.visible_tags(); end

  def self.visible_tags=(visible_tags); end
end

class YARD::Tags::MacroDirective
end

class YARD::Tags::MacroDirective
end

class YARD::Tags::MethodDirective
  def create_object(); end

  def method_name(); end

  def method_signature(); end

  def sanitized_tag_signature(); end

  def use_indented_text(); end
  SCOPE_MATCH = ::T.let(nil, ::T.untyped)
end

class YARD::Tags::MethodDirective
end

class YARD::Tags::OptionTag
  def initialize(tag_name, name, pair); end

  def pair(); end

  def pair=(pair); end
end

class YARD::Tags::OptionTag
end

class YARD::Tags::OverloadTag
  def docstring(); end

  def has_tag?(name); end

  def initialize(tag_name, text); end

  def is_a?(other); end

  def kind_of?(other); end

  def method_missing(*args, &block); end

  def name(prefix=T.unsafe(nil)); end

  def object=(value); end

  def parameters(); end

  def signature(); end

  def tag(name); end

  def tags(name=T.unsafe(nil)); end
end

class YARD::Tags::OverloadTag
end

class YARD::Tags::ParseDirective
end

class YARD::Tags::ParseDirective
end

module YARD::Tags::RefTag
  def owner(); end

  def owner=(owner); end
end

module YARD::Tags::RefTag
end

class YARD::Tags::RefTagList
  def initialize(tag_name, owner, name=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def owner(); end

  def owner=(owner); end

  def tag_name(); end

  def tag_name=(tag_name); end

  def tags(); end
end

class YARD::Tags::RefTagList
end

class YARD::Tags::ScopeDirective
end

class YARD::Tags::ScopeDirective
end

class YARD::Tags::Tag
  def explain_types(); end

  def initialize(tag_name, text, types=T.unsafe(nil), name=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def object(); end

  def object=(object); end

  def tag_name(); end

  def tag_name=(tag_name); end

  def text(); end

  def text=(text); end

  def type(); end

  def types(); end

  def types=(types); end
end

class YARD::Tags::Tag
end

class YARD::Tags::TagFormatError
end

class YARD::Tags::TagFormatError
end

class YARD::Tags::TypesExplainer
end

class YARD::Tags::TypesExplainer::CollectionType
  def initialize(name, types); end

  def to_s(_singular=T.unsafe(nil)); end

  def types(); end

  def types=(types); end
end

class YARD::Tags::TypesExplainer::CollectionType
end

class YARD::Tags::TypesExplainer::FixedCollectionType
end

class YARD::Tags::TypesExplainer::FixedCollectionType
end

class YARD::Tags::TypesExplainer::HashCollectionType
  def initialize(name, key_types, value_types); end

  def key_types(); end

  def key_types=(key_types); end

  def to_s(_singular=T.unsafe(nil)); end

  def value_types(); end

  def value_types=(value_types); end
end

class YARD::Tags::TypesExplainer::HashCollectionType
end

class YARD::Tags::TypesExplainer::Parser
  include ::YARD::CodeObjects
  def initialize(string); end

  def parse(); end
  TOKENS = ::T.let(nil, ::T.untyped)
end

class YARD::Tags::TypesExplainer::Parser
  def self.parse(string); end
end

class YARD::Tags::TypesExplainer::Type
  def initialize(name); end

  def name(); end

  def name=(name); end

  def to_s(singular=T.unsafe(nil)); end
end

class YARD::Tags::TypesExplainer::Type
end

class YARD::Tags::TypesExplainer
  def self.explain(*types); end

  def self.explain!(*types); end
end

class YARD::Tags::VisibilityDirective
end

class YARD::Tags::VisibilityDirective
end

module YARD::Tags
end

module YARD::Templates
end

module YARD::Templates::Engine
end

module YARD::Templates::Engine
  def self.generate(objects, options=T.unsafe(nil)); end

  def self.register_template_path(path); end

  def self.render(options=T.unsafe(nil)); end

  def self.template(*path); end

  def self.template!(path, full_paths=T.unsafe(nil)); end

  def self.template_paths(); end

  def self.template_paths=(template_paths); end

  def self.with_serializer(object, serializer); end
end

module YARD::Templates::ErbCache
end

module YARD::Templates::ErbCache
  def self.clear!(); end

  def self.method_for(filename); end
end

module YARD::Templates::Helpers
end

module YARD::Templates::Helpers::BaseHelper
  def format_object_title(object); end

  def format_object_type(object); end

  def format_source(value); end

  def format_types(list, brackets=T.unsafe(nil)); end

  def globals(); end

  def h(text); end

  def link_file(filename, title=T.unsafe(nil), anchor=T.unsafe(nil)); end

  def link_include_file(file); end

  def link_include_object(obj); end

  def link_object(obj, title=T.unsafe(nil)); end

  def link_url(url, title=T.unsafe(nil), params=T.unsafe(nil)); end

  def linkify(*args); end

  def object(); end

  def object=(object); end

  def owner(); end

  def run_verifier(list); end

  def serializer(); end

  def serializer=(serializer); end
end

module YARD::Templates::Helpers::BaseHelper
end

module YARD::Templates::Helpers::FilterHelper
  def is_class?(object); end

  def is_method?(object); end

  def is_module?(object); end

  def is_namespace?(object); end
end

module YARD::Templates::Helpers::FilterHelper
end

module YARD::Templates::Helpers::HtmlHelper
  include ::YARD::Templates::Helpers::MarkupHelper
  include ::YARD::Templates::Helpers::HtmlSyntaxHighlightHelper
  include ::YARD::Templates::Helpers::ModuleHelper
  def anchor_for(object); end

  def charset(); end

  def format_object_name_list(objects); end

  def format_types(typelist, brackets=T.unsafe(nil)); end

  def h(text); end

  def html_markup_asciidoc(text); end

  def html_markup_html(text); end

  def html_markup_markdown(text); end

  def html_markup_none(text); end

  def html_markup_org(text); end

  def html_markup_pre(text); end

  def html_markup_rdoc(text); end

  def html_markup_ruby(source); end

  def html_markup_text(text); end

  def html_markup_textile(text); end

  def html_markup_textile_strict(text); end

  def html_syntax_highlight(source, type=T.unsafe(nil)); end

  def html_syntax_highlight_plain(source); end

  def htmlify(text, markup=T.unsafe(nil)); end

  def htmlify_line(*args); end

  def insert_include(text, markup=T.unsafe(nil)); end

  def link_file(filename, title=T.unsafe(nil), anchor=T.unsafe(nil)); end

  def link_include_file(file); end

  def link_include_object(obj); end

  def link_object(obj, title=T.unsafe(nil), anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def link_url(url, title=T.unsafe(nil), params=T.unsafe(nil)); end

  def mtime(_file); end

  def mtime_url(obj, anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def resolve_links(text); end

  def signature(meth, link=T.unsafe(nil), show_extras=T.unsafe(nil), full_attr_name=T.unsafe(nil)); end

  def signature_types(meth, link=T.unsafe(nil)); end

  def url_for(obj, anchor=T.unsafe(nil), relative=T.unsafe(nil)); end

  def url_for_file(filename, anchor=T.unsafe(nil)); end

  def url_for_frameset(); end

  def url_for_index(); end

  def url_for_list(type); end

  def url_for_main(); end
  ASCIIDOC_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  URLMATCH = ::T.let(nil, ::T.untyped)
end

module YARD::Templates::Helpers::HtmlHelper
  def self.urlencode(text); end
end

module YARD::Templates::Helpers::HtmlSyntaxHighlightHelper
  include ::YARD::Templates::Helpers::ModuleHelper
  def html_syntax_highlight_ruby(source); end
end

module YARD::Templates::Helpers::HtmlSyntaxHighlightHelper
end

module YARD::Templates::Helpers::Markup
end

class YARD::Templates::Helpers::Markup::RDocMarkdown
  def fix_typewriter(html); end
end

class YARD::Templates::Helpers::Markup::RDocMarkdown
end

class YARD::Templates::Helpers::Markup::RDocMarkup
  def from_path(); end

  def from_path=(from_path); end

  def initialize(text); end

  def to_html(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP
  def add_html(tag, name); end

  def add_regexp_handling(pattern, name); end

  def add_word_pair(start, stop, name); end

  def attribute_manager(); end

  def convert(input, formatter); end

  def initialize(attribute_manager=T.unsafe(nil)); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::AttrChanger
  def turn_off(); end

  def turn_off=(_); end

  def turn_on(); end

  def turn_on=(_); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::AttrChanger
  def self.[](*_); end

  def self.members(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::AttrSpan
  def [](n); end

  def initialize(length); end

  def set_attrs(start, length, bits); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::AttrSpan
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::AttributeManager
  def add_html(tag, name); end

  def add_regexp_handling(pattern, name); end

  def add_word_pair(start, stop, name); end

  def attribute(turn_on, turn_off); end

  def attributes(); end

  def change_attribute(current, new); end

  def changed_attribute_by_name(current_set, new_set); end

  def convert_attrs(str, attrs); end

  def convert_html(str, attrs); end

  def convert_regexp_handlings(str, attrs); end

  def copy_string(start_pos, end_pos); end

  def display_attributes(); end

  def flow(str); end

  def html_tags(); end

  def mask_protected_sequences(); end

  def matching_word_pairs(); end

  def protectable(); end

  def regexp_handlings(); end

  def split_into_flow(); end

  def unmask_protected_sequences(); end

  def word_pair_map(); end
  A_PROTECT = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  PROTECT_ATTR = ::T.let(nil, ::T.untyped)
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::AttributeManager
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Attributes
  def as_string(bitmap); end

  def bitmap_for(name); end

  def each_name_of(bitmap); end

  def regexp_handling(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Attributes
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::BlankLine
  def accept(visitor); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::BlankLine
  def self.new(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::BlockQuote
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::BlockQuote
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Document
  include ::Enumerable
  def <<(part); end

  def ==(other); end

  def accept(visitor); end

  def concat(parts); end

  def each(&block); end

  def empty?(); end

  def file(); end

  def file=(location); end

  def initialize(*parts); end

  def merge(other); end

  def merged?(); end

  def omit_headings_below(); end

  def omit_headings_below=(omit_headings_below); end

  def parts(); end

  def push(*parts); end

  def table_of_contents(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Document
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Formatter
  def accept_document(document); end

  def add_regexp_handling_RDOCLINK(); end

  def add_regexp_handling_TIDYLINK(); end

  def add_tag(name, start, stop); end

  def annotate(tag); end

  def convert(content); end

  def convert_flow(flow); end

  def convert_regexp_handling(target); end

  def convert_string(string); end

  def ignore(*node); end

  def in_tt?(); end

  def initialize(options, markup=T.unsafe(nil)); end

  def off_tags(res, item); end

  def on_tags(res, item); end

  def parse_url(url); end

  def tt?(tag); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Formatter::InlineTag
  def bit(); end

  def bit=(_); end

  def off(); end

  def off=(_); end

  def on(); end

  def on=(_); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Formatter::InlineTag
  def self.[](*_); end

  def self.members(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Formatter
  def self.gen_relative_url(path, target); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::HardBreak
  def ==(other); end

  def accept(visitor); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::HardBreak
  def self.new(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Heading
  def accept(visitor); end

  def aref(); end

  def label(context=T.unsafe(nil)); end

  def level(); end

  def level=(_); end

  def plain_html(); end

  def text(); end

  def text=(_); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Heading
  def self.[](*_); end

  def self.members(); end

  def self.to_html(); end

  def self.to_label(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Include
  def ==(other); end

  def file(); end

  def include_path(); end

  def initialize(file, include_path); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Include
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::IndentedParagraph
  def indent(); end

  def initialize(indent, *parts); end

  def text(hard_break=T.unsafe(nil)); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::IndentedParagraph
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::List
  def <<(item); end

  def ==(other); end

  def accept(visitor); end

  def empty?(); end

  def initialize(type=T.unsafe(nil), *items); end

  def items(); end

  def last(); end

  def push(*items); end

  def type(); end

  def type=(type); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::List
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ListItem
  def <<(part); end

  def ==(other); end

  def accept(visitor); end

  def empty?(); end

  def initialize(label=T.unsafe(nil), *parts); end

  def label(); end

  def label=(label); end

  def length(); end

  def parts(); end

  def push(*parts); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ListItem
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Paragraph
  def text(hard_break=T.unsafe(nil)); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Paragraph
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Parser
  include ::RDoc::Text
  def build_heading(level); end

  def build_list(margin); end

  def build_paragraph(margin); end

  def build_verbatim(margin); end

  def char_pos(byte_offset); end

  def debug(); end

  def debug=(debug); end

  def get(); end

  def parse(parent, indent=T.unsafe(nil)); end

  def parse_text(parent, indent); end

  def peek_token(); end

  def setup_scanner(input); end

  def skip(token_type, error=T.unsafe(nil)); end

  def token_pos(byte_offset); end

  def tokenize(input); end

  def tokens(); end

  def unget(); end
  LIST_TOKENS = ::T.let(nil, ::T.untyped)
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Parser::Error
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Parser::Error
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Parser::ParseError
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Parser::ParseError
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Parser
  def self.parse(str); end

  def self.tokenize(str); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::PreProcess
  def find_include_file(name); end

  def handle(text, code_object=T.unsafe(nil), &block); end

  def handle_directive(prefix, directive, param, code_object=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def include_file(name, indent, encoding); end

  def initialize(input_file_name, include_path); end

  def options(); end

  def options=(options); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::PreProcess
  def self.post_process(&block); end

  def self.post_processors(); end

  def self.register(directive, &block); end

  def self.registered(); end

  def self.reset(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Raw
  def <<(text); end

  def ==(other); end

  def accept(visitor); end

  def initialize(*parts); end

  def merge(other); end

  def parts(); end

  def push(*texts); end

  def text(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Raw
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::RegexpHandling
  def ==(o); end

  def initialize(type, text); end

  def text(); end

  def text=(text); end

  def type(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::RegexpHandling
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Rule
  def accept(visitor); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Rule
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToAnsi
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToAnsi
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToBs
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToBs
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToHtml
  include ::RDoc::Text
  def accept_blank_line(blank_line); end

  def accept_block_quote(block_quote); end

  def accept_heading(heading); end

  def accept_list_end(list); end

  def accept_list_item_end(list_item); end

  def accept_list_item_start(list_item); end

  def accept_list_start(list); end

  def accept_paragraph(paragraph); end

  def accept_raw(raw); end

  def accept_rule(rule); end

  def accept_verbatim(verbatim); end

  def code_object(); end

  def code_object=(code_object); end

  def convert_string(text); end

  def end_accepting(); end

  def from_path(); end

  def from_path=(from_path); end

  def gen_url(url, text); end

  def handle_RDOCLINK(url); end

  def handle_regexp_HARD_BREAK(target); end

  def handle_regexp_HYPERLINK(target); end

  def handle_regexp_RDOCLINK(target); end

  def handle_regexp_TIDYLINK(target); end

  def html_list_name(list_type, open_tag); end

  def in_list_entry(); end

  def init_tags(); end

  def list(); end

  def list_end_for(list_type); end

  def list_item_start(list_item, list_type); end

  def parseable?(text); end

  def res(); end

  def start_accepting(); end

  def to_html(item); end
  LIST_TYPE_TO_HTML = ::T.let(nil, ::T.untyped)
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToHtml
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToHtmlCrossref
  def context(); end

  def context=(context); end

  def cross_reference(name, text=T.unsafe(nil), code=T.unsafe(nil)); end

  def handle_regexp_CROSSREF(target); end

  def initialize(options, from_path, context, markup=T.unsafe(nil)); end

  def link(name, text, code=T.unsafe(nil)); end

  def show_hash(); end

  def show_hash=(show_hash); end
  ALL_CROSSREF_REGEXP = ::T.let(nil, ::T.untyped)
  CLASS_REGEXP_STR = ::T.let(nil, ::T.untyped)
  CROSSREF_REGEXP = ::T.let(nil, ::T.untyped)
  METHOD_REGEXP_STR = ::T.let(nil, ::T.untyped)
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToHtmlCrossref
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToHtmlSnippet
  def accept_raw(*node); end

  def accept_rule(*node); end

  def add_paragraph(); end

  def character_limit(); end

  def characters(); end

  def handle_regexp_CROSSREF(target); end

  def initialize(options, characters=T.unsafe(nil), paragraphs=T.unsafe(nil), markup=T.unsafe(nil)); end

  def mask(); end

  def paragraph_limit(); end

  def paragraphs(); end

  def truncate(text); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToHtmlSnippet
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToJoinedParagraph
  def accept_block_quote(*node); end

  def accept_heading(*node); end

  def accept_list_end(*node); end

  def accept_list_item_end(*node); end

  def accept_list_item_start(*node); end

  def accept_list_start(*node); end

  def accept_paragraph(paragraph); end

  def accept_raw(*node); end

  def accept_rule(*node); end

  def accept_verbatim(*node); end

  def end_accepting(); end

  def initialize(); end

  def start_accepting(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToJoinedParagraph
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToLabel
  def accept_blank_line(*node); end

  def accept_block_quote(*node); end

  def accept_heading(*node); end

  def accept_list_end(*node); end

  def accept_list_item_end(*node); end

  def accept_list_item_start(*node); end

  def accept_list_start(*node); end

  def accept_paragraph(*node); end

  def accept_raw(*node); end

  def accept_rule(*node); end

  def accept_verbatim(*node); end

  def convert(text); end

  def end_accepting(*node); end

  def handle_regexp_CROSSREF(target); end

  def handle_regexp_HARD_BREAK(*node); end

  def handle_regexp_TIDYLINK(target); end

  def initialize(markup=T.unsafe(nil)); end

  def res(); end

  def start_accepting(*node); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToLabel
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToMarkdown
  def gen_url(url, text); end

  def handle_rdoc_link(url); end

  def handle_regexp_RDOCLINK(target); end

  def handle_regexp_TIDYLINK(target); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToMarkdown
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToRdoc
  def accept_blank_line(blank_line); end

  def accept_block_quote(block_quote); end

  def accept_heading(heading); end

  def accept_indented_paragraph(paragraph); end

  def accept_list_end(list); end

  def accept_list_item_end(list_item); end

  def accept_list_item_start(list_item); end

  def accept_list_start(list); end

  def accept_paragraph(paragraph); end

  def accept_raw(raw); end

  def accept_rule(rule); end

  def accept_verbatim(verbatim); end

  def attributes(text); end

  def end_accepting(); end

  def handle_regexp_HARD_BREAK(target); end

  def handle_regexp_SUPPRESSED_CROSSREF(target); end

  def indent(); end

  def indent=(indent); end

  def init_tags(); end

  def initialize(markup=T.unsafe(nil)); end

  def list_index(); end

  def list_type(); end

  def list_width(); end

  def prefix(); end

  def res(); end

  def start_accepting(); end

  def use_prefix(); end

  def width(); end

  def width=(width); end

  def wrap(text); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToRdoc
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToTableOfContents
  def accept_blank_line(*node); end

  def accept_block_quote(*node); end

  def accept_heading(heading); end

  def accept_list_end(*node); end

  def accept_list_end_bullet(*node); end

  def accept_list_item_end(*node); end

  def accept_list_item_start(*node); end

  def accept_list_start(*node); end

  def accept_paragraph(*node); end

  def accept_raw(*node); end

  def accept_rule(*node); end

  def accept_verbatim(*node); end

  def end_accepting(); end

  def initialize(); end

  def omit_headings_below(); end

  def omit_headings_below=(omit_headings_below); end

  def res(); end

  def start_accepting(); end

  def suppressed?(heading); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToTableOfContents
  def self.to_toc(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToTest
  def accept_blank_line(blank_line); end

  def accept_heading(heading); end

  def accept_list_end(list); end

  def accept_list_item_end(list_item); end

  def accept_list_item_start(list_item); end

  def accept_list_start(list); end

  def accept_paragraph(paragraph); end

  def accept_raw(raw); end

  def accept_rule(rule); end

  def accept_verbatim(verbatim); end

  def end_accepting(); end

  def start_accepting(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToTest
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToTtOnly
  def accept_blank_line(markup_item); end

  def accept_block_quote(block_quote); end

  def accept_heading(markup_item); end

  def accept_list_end(list); end

  def accept_list_item_end(markup_item); end

  def accept_list_item_start(list_item); end

  def accept_list_start(list); end

  def accept_paragraph(paragraph); end

  def accept_raw(markup_item); end

  def accept_rule(markup_item); end

  def accept_verbatim(markup_item); end

  def do_nothing(markup_item); end

  def end_accepting(); end

  def initialize(markup=T.unsafe(nil)); end

  def list_type(); end

  def res(); end

  def start_accepting(); end

  def tt_sections(text); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::ToTtOnly
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Verbatim
  def format(); end

  def format=(format); end

  def normalize(); end

  def ruby?(); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP::Verbatim
end

class YARD::Templates::Helpers::Markup::RDocMarkup::MARKUP
  def self.parse(str); end
end

class YARD::Templates::Helpers::Markup::RDocMarkup
end

module YARD::Templates::Helpers::Markup
end

module YARD::Templates::Helpers::MarkupHelper
  def load_markup_provider(type=T.unsafe(nil)); end

  def markup_class(type=T.unsafe(nil)); end

  def markup_file_contents(contents); end

  def markup_for_file(contents, filename); end

  def markup_provider(type=T.unsafe(nil)); end
  MARKUP_EXTENSIONS = ::T.let(nil, ::T.untyped)
  MARKUP_FILE_SHEBANG = ::T.let(nil, ::T.untyped)
  MARKUP_PROVIDERS = ::T.let(nil, ::T.untyped)
end

module YARD::Templates::Helpers::MarkupHelper
  def self.clear_markup_cache(); end

  def self.markup_cache(); end

  def self.markup_cache=(markup_cache); end
end

module YARD::Templates::Helpers::MethodHelper
  def format_args(object); end

  def format_block(object); end

  def format_code(object, _show_lines=T.unsafe(nil)); end

  def format_constant(value); end

  def format_lines(object); end

  def format_return_types(object); end
end

module YARD::Templates::Helpers::MethodHelper
end

module YARD::Templates::Helpers::ModuleHelper
  def prune_method_listing(list, hide_attributes=T.unsafe(nil)); end
end

module YARD::Templates::Helpers::ModuleHelper
end

module YARD::Templates::Helpers::TextHelper
  def align_right(text, spacer=T.unsafe(nil), col=T.unsafe(nil)); end

  def h(text); end

  def hr(col=T.unsafe(nil), sep=T.unsafe(nil)); end

  def indent(text, len=T.unsafe(nil)); end

  def signature(meth); end

  def title_align_right(text, col=T.unsafe(nil)); end

  def wrap(text, col=T.unsafe(nil)); end
end

module YARD::Templates::Helpers::TextHelper
end

module YARD::Templates::Helpers::UMLHelper
  def format_path(object); end

  def h(text); end

  def tidy(data); end

  def uml_visibility(object); end
end

module YARD::Templates::Helpers::UMLHelper
end

module YARD::Templates::Helpers
end

class YARD::Templates::Section
  def <<(*args); end

  def ==(other); end

  def [](*args); end

  def any(item); end

  def eql?(other); end

  def initialize(name, *args); end

  def name(); end

  def name=(name); end

  def place(*args); end

  def push(*args); end

  def unshift(*args); end
end

class YARD::Templates::Section
end

module YARD::Templates::Template
  include ::YARD::Templates::ErbCache
  include ::YARD::Templates::Helpers::BaseHelper
  include ::YARD::Templates::Helpers::MethodHelper
  def T(*path); end

  def class(); end

  def class=(_); end

  def erb(section, &block); end

  def erb_file_for(section); end

  def erb_with(content, filename=T.unsafe(nil)); end

  def file(basename, allow_inherited=T.unsafe(nil)); end

  def init(); end

  def initialize(opts=T.unsafe(nil)); end

  def inspect(); end

  def options(); end

  def options=(value); end

  def run(opts=T.unsafe(nil), sects=T.unsafe(nil), start_at=T.unsafe(nil), break_first=T.unsafe(nil), &block); end

  def section(); end

  def section=(section); end

  def sections(*args); end

  def superb(sect=T.unsafe(nil), &block); end

  def yieldall(opts=T.unsafe(nil), &block); end
end

module YARD::Templates::Template::ClassMethods
  def S(*args); end

  def T(*path); end

  def find_file(basename); end

  def find_nth_file(basename, index=T.unsafe(nil)); end

  def full_path(); end

  def full_path=(full_path); end

  def full_paths(); end

  def initialize(path, full_paths); end

  def is_a?(klass); end

  def new(*args); end

  def path(); end

  def path=(path); end

  def reset_full_paths(); end

  def run(*args); end
end

module YARD::Templates::Template::ClassMethods
end

module YARD::Templates::Template
  def self.extra_includes(); end

  def self.extra_includes=(extra_includes); end

  def self.include_extra(template, options); end

  def self.included(klass); end
end

class YARD::Templates::TemplateOptions
  def __globals(); end

  def default_return(); end

  def default_return=(default_return); end

  def embed_mixins(); end

  def embed_mixins=(embed_mixins); end

  def embed_mixins_match?(mixin); end

  def format(); end

  def format=(format); end

  def globals(); end

  def globals=(globals); end

  def hide_void_return(); end

  def hide_void_return=(hide_void_return); end

  def highlight(); end

  def highlight=(highlight); end

  def index(); end

  def index=(index); end

  def markup(); end

  def markup=(markup); end

  def markup_provider(); end

  def markup_provider=(markup_provider); end

  def no_highlight(); end

  def no_highlight=(value); end

  def object(); end

  def object=(object); end

  def owner(); end

  def owner=(owner); end

  def page_title(); end

  def page_title=(page_title); end

  def serialize(); end

  def serialize=(serialize); end

  def serializer(); end

  def serializer=(serializer); end

  def template(); end

  def template=(template); end

  def type(); end

  def type=(type); end

  def verifier(); end

  def verifier=(verifier); end
end

class YARD::Templates::TemplateOptions
end

module YARD::Templates
end

class YARD::Verifier
  def add_expressions(*expressions); end

  def call(object); end

  def expressions(); end

  def expressions=(value); end

  def initialize(*expressions); end

  def method_missing(sym, *args, &block); end

  def o(); end

  def object(); end

  def run(list); end
  NILCLASS_METHODS = ::T.let(nil, ::T.untyped)
end

class YARD::Verifier
end

module YARD
  def self.load_plugins(); end

  def self.parse(*args); end

  def self.parse_string(*args); end

  def self.ruby18?(); end

  def self.ruby19?(); end

  def self.ruby2?(); end

  def self.windows?(); end
end

module Zeitwerk::ExplicitNamespace
  extend ::Zeitwerk::RealModName
end

module Zip
  CDIR_ENTRY_STATIC_HEADER_LENGTH = ::T.let(nil, ::T.untyped)
  CENTRAL_DIRECTORY_ENTRY_SIGNATURE = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHODS = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_AES = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_BZIP2 = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_DEFLATE = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_DEFLATE_64 = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_IBM_CMPSC = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_IBM_LZ77 = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_IBM_TERSE = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_IMPLODE = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_JPEG = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_LZMA = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_PKWARE_DCLI = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_PPMD = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_REDUCE_1 = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_REDUCE_2 = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_REDUCE_3 = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_REDUCE_4 = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_SHRINK = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_STORE = ::T.let(nil, ::T.untyped)
  COMPRESSION_METHOD_WAVPACK = ::T.let(nil, ::T.untyped)
  FILE_TYPE_DIR = ::T.let(nil, ::T.untyped)
  FILE_TYPE_FILE = ::T.let(nil, ::T.untyped)
  FILE_TYPE_SYMLINK = ::T.let(nil, ::T.untyped)
  FSTYPES = ::T.let(nil, ::T.untyped)
  FSTYPE_ACORN = ::T.let(nil, ::T.untyped)
  FSTYPE_AMIGA = ::T.let(nil, ::T.untyped)
  FSTYPE_ATARI = ::T.let(nil, ::T.untyped)
  FSTYPE_ATHEOS = ::T.let(nil, ::T.untyped)
  FSTYPE_BEOS = ::T.let(nil, ::T.untyped)
  FSTYPE_CPM = ::T.let(nil, ::T.untyped)
  FSTYPE_FAT = ::T.let(nil, ::T.untyped)
  FSTYPE_HPFS = ::T.let(nil, ::T.untyped)
  FSTYPE_MAC = ::T.let(nil, ::T.untyped)
  FSTYPE_MAC_OSX = ::T.let(nil, ::T.untyped)
  FSTYPE_MVS = ::T.let(nil, ::T.untyped)
  FSTYPE_NTFS = ::T.let(nil, ::T.untyped)
  FSTYPE_QDOS = ::T.let(nil, ::T.untyped)
  FSTYPE_TANDEM = ::T.let(nil, ::T.untyped)
  FSTYPE_THEOS = ::T.let(nil, ::T.untyped)
  FSTYPE_TOPS20 = ::T.let(nil, ::T.untyped)
  FSTYPE_UNIX = ::T.let(nil, ::T.untyped)
  FSTYPE_VFAT = ::T.let(nil, ::T.untyped)
  FSTYPE_VMS = ::T.let(nil, ::T.untyped)
  FSTYPE_VM_CMS = ::T.let(nil, ::T.untyped)
  FSTYPE_Z_SYSTEM = ::T.let(nil, ::T.untyped)
  LOCAL_ENTRY_SIGNATURE = ::T.let(nil, ::T.untyped)
  LOCAL_ENTRY_STATIC_HEADER_LENGTH = ::T.let(nil, ::T.untyped)
  LOCAL_ENTRY_TRAILING_DESCRIPTOR_LENGTH = ::T.let(nil, ::T.untyped)
  RUNNING_ON_WINDOWS = ::T.let(nil, ::T.untyped)
  VERSION_MADE_BY = ::T.let(nil, ::T.untyped)
  VERSION_NEEDED_TO_EXTRACT = ::T.let(nil, ::T.untyped)
  VERSION_NEEDED_TO_EXTRACT_ZIP64 = ::T.let(nil, ::T.untyped)
end

class Zip::CentralDirectory
  END_OF_CDS = ::T.let(nil, ::T.untyped)
  MAX_END_OF_CDS_SIZE = ::T.let(nil, ::T.untyped)
  STATIC_EOCD_SIZE = ::T.let(nil, ::T.untyped)
  ZIP64_END_OF_CDS = ::T.let(nil, ::T.untyped)
  ZIP64_EOCD_LOCATOR = ::T.let(nil, ::T.untyped)
end

class Zip::Decompressor
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
end

class Zip::DecryptedIo
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
end

class Zip::Entry
  DEFLATED = ::T.let(nil, ::T.untyped)
  EFS = ::T.let(nil, ::T.untyped)
  STORED = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField
  ID_MAP = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::IUnix
  HEADER_ID = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::NTFS
  HEADER_ID = ::T.let(nil, ::T.untyped)
  SEC_TO_UNIX_EPOCH = ::T.let(nil, ::T.untyped)
  WINDOWS_TICK = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::OldUnix
  HEADER_ID = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::UniversalTime
  ATIME_MASK = ::T.let(nil, ::T.untyped)
  CTIME_MASK = ::T.let(nil, ::T.untyped)
  HEADER_ID = ::T.let(nil, ::T.untyped)
  MTIME_MASK = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::Zip64
  HEADER_ID = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::Zip64Placeholder
  HEADER_ID = ::T.let(nil, ::T.untyped)
end

class Zip::File
  CREATE = ::T.let(nil, ::T.untyped)
  DATA_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  IO_METHODS = ::T.let(nil, ::T.untyped)
  MAX_SEGMENT_SIZE = ::T.let(nil, ::T.untyped)
  MIN_SEGMENT_SIZE = ::T.let(nil, ::T.untyped)
  SPLIT_SIGNATURE = ::T.let(nil, ::T.untyped)
  ZIP64_EOCD_SIGNATURE = ::T.let(nil, ::T.untyped)
end

module Zip::IOExtras
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
  RANGE_ALL = ::T.let(nil, ::T.untyped)
end

module Zip::IOExtras::AbstractInputStream
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Zip::InputStream
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
end

module Zip::NullInputStream
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

Zip::ZipCompressionMethodError = Zip::CompressionMethodError

Zip::ZipDestinationFileExistsError = Zip::DestinationFileExistsError

Zip::ZipEntryExistsError = Zip::EntryExistsError

Zip::ZipEntryNameError = Zip::EntryNameError

Zip::ZipError = Zip::Error

Zip::ZipInternalError = Zip::InternalError

module Zlib
  ASCII = ::T.let(nil, ::T.untyped)
  BEST_COMPRESSION = ::T.let(nil, ::T.untyped)
  BEST_SPEED = ::T.let(nil, ::T.untyped)
  BINARY = ::T.let(nil, ::T.untyped)
  DEFAULT_COMPRESSION = ::T.let(nil, ::T.untyped)
  DEFAULT_STRATEGY = ::T.let(nil, ::T.untyped)
  DEF_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  FILTERED = ::T.let(nil, ::T.untyped)
  FINISH = ::T.let(nil, ::T.untyped)
  FIXED = ::T.let(nil, ::T.untyped)
  FULL_FLUSH = ::T.let(nil, ::T.untyped)
  HUFFMAN_ONLY = ::T.let(nil, ::T.untyped)
  MAX_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  MAX_WBITS = ::T.let(nil, ::T.untyped)
  NO_COMPRESSION = ::T.let(nil, ::T.untyped)
  NO_FLUSH = ::T.let(nil, ::T.untyped)
  OS_AMIGA = ::T.let(nil, ::T.untyped)
  OS_ATARI = ::T.let(nil, ::T.untyped)
  OS_CODE = ::T.let(nil, ::T.untyped)
  OS_CPM = ::T.let(nil, ::T.untyped)
  OS_MACOS = ::T.let(nil, ::T.untyped)
  OS_MSDOS = ::T.let(nil, ::T.untyped)
  OS_OS2 = ::T.let(nil, ::T.untyped)
  OS_QDOS = ::T.let(nil, ::T.untyped)
  OS_RISCOS = ::T.let(nil, ::T.untyped)
  OS_TOPS20 = ::T.let(nil, ::T.untyped)
  OS_UNIX = ::T.let(nil, ::T.untyped)
  OS_UNKNOWN = ::T.let(nil, ::T.untyped)
  OS_VMCMS = ::T.let(nil, ::T.untyped)
  OS_VMS = ::T.let(nil, ::T.untyped)
  OS_WIN32 = ::T.let(nil, ::T.untyped)
  OS_ZSYSTEM = ::T.let(nil, ::T.untyped)
  RLE = ::T.let(nil, ::T.untyped)
  SYNC_FLUSH = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  ZLIB_VERSION = ::T.let(nil, ::T.untyped)
end

class Zlib::BufError
end

class Zlib::BufError
end

class Zlib::DataError
end

class Zlib::DataError
end

class Zlib::Deflate
  def <<(_); end

  def deflate(*_); end

  def flush(*_); end

  def initialize(*_); end

  def params(_, _1); end

  def set_dictionary(_); end
end

class Zlib::Deflate
  def self.deflate(*_); end
end

class Zlib::Error
end

class Zlib::Error
end

class Zlib::GzipFile
  def close(); end

  def closed?(); end

  def comment(); end

  def crc(); end

  def finish(); end

  def level(); end

  def mtime(); end

  def orig_name(); end

  def os_code(); end

  def sync(); end

  def sync=(sync); end

  def to_io(); end
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::Error
  def input(); end
end

class Zlib::GzipFile::Error
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile
  def self.wrap(*_); end
end

class Zlib::GzipReader
  include ::Enumerable
  def bytes(); end

  def each(*_, &blk); end

  def each_byte(); end

  def each_char(); end

  def each_line(*_); end

  def eof(); end

  def eof?(); end

  def external_encoding(); end

  def getbyte(); end

  def getc(); end

  def initialize(*_); end

  def lineno(); end

  def lineno=(lineno); end

  def lines(*_); end

  def pos(); end

  def read(*_); end

  def readbyte(); end

  def readchar(); end

  def readpartial(*_); end

  def rewind(); end

  def tell(); end

  def ungetbyte(_); end

  def ungetc(_); end

  def unused(); end
end

class Zlib::GzipReader
  def self.open(*_); end
end

class Zlib::GzipWriter
  def <<(_); end

  def comment=(comment); end

  def flush(*_); end

  def initialize(*_); end

  def mtime=(mtime); end

  def orig_name=(orig_name); end

  def pos(); end

  def tell(); end

  def write(*_); end
end

class Zlib::GzipWriter
  def self.open(*_); end
end

class Zlib::Inflate
  def <<(_); end

  def add_dictionary(_); end

  def inflate(_); end

  def initialize(*_); end

  def set_dictionary(_); end

  def sync(_); end

  def sync_point?(); end
end

class Zlib::Inflate
  def self.inflate(_); end
end

class Zlib::MemError
end

class Zlib::MemError
end

class Zlib::NeedDict
end

class Zlib::NeedDict
end

class Zlib::StreamEnd
end

class Zlib::StreamEnd
end

class Zlib::StreamError
end

class Zlib::StreamError
end

class Zlib::VersionError
end

class Zlib::VersionError
end

class Zlib::ZStream
  def adler(); end

  def avail_in(); end

  def avail_out(); end

  def avail_out=(avail_out); end

  def close(); end

  def closed?(); end

  def data_type(); end

  def end(); end

  def ended?(); end

  def finish(); end

  def finished?(); end

  def flush_next_in(); end

  def flush_next_out(); end

  def reset(); end

  def stream_end?(); end

  def total_in(); end

  def total_out(); end
end

class Zlib::ZStream
end

module Zlib
  def self.adler32(*_); end

  def self.adler32_combine(_, _1, _2); end

  def self.crc32(*_); end

  def self.crc32_combine(_, _1, _2); end

  def self.crc_table(); end

  def self.deflate(*_); end

  def self.gunzip(_); end

  def self.gzip(*_); end

  def self.inflate(_); end

  def self.zlib_version(); end
end
